<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-12-10T02:52:55.692Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[再学Android：应用启动流程]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidying-yong-qi-dong-liu-cheng</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidying-yong-qi-dong-liu-cheng">
        </link>
        <updated>2019-12-10T02:51:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="基础理论">基础理论</h4>
<p>Android系统是基于Linux，每个APP都是运行在独立的空间内，进程是系统上应用的最小单元。Android为每个进程都分配了独立的jvm,所以基本上是应用隔离的。<br></br><br>
Android并没有自己程序的main方法，但是内部的组件可以被其他程序的组件启动。同样本身也可以启动其他的。</p>
<h4 id="点击启动">点击启动</h4>
<p>直接从打开一个没有启动过的应用来讲:</p>
<ul>
<li>用户在launcher桌面点击应用图标，对于launcher来讲已经知道对应的应用对应什么包名以及入口activity，这个都是安装的时候以及解析出来的了。</li>
<li>调用<code>startActivity()</code>方法，通过ipc告诉<code>ActivityManagerService</code>我要启动这个activity了。</li>
<li>ams在在内部会进行如下操作:
<ul>
<li>通过<code>PackageManager</code>的<code>resloveIntent()</code>方法来收集这个intent对象的指向信息。</li>
<li>指向信息被储存到一个intent对象中。</li>
<li>通过<code>grantUriPermissionLocaked()</code>方法来判断当前应用是否有权限来调用对应的activity。</li>
<li>有权限，ams会在新的task中启动activity(我们在自身应用打开其他应用的界面都是需要添加newTask的flag的)</li>
<li>现在去检查ProcessRecord是否存在，如果不存在，那么ams会创建新的进程来实例化activity</li>
</ul>
</li>
<li>对于Android系统来说，当前需要被启动的activity已经属于一个新的应用了，但是还没有给它分配过uid。此时会通过<code>zygote</code>进程来孵化出一个进程来作为需要被打开的应用的承载。(zygote是所有Java进程的爸爸，这个在系统启动分析中有说过)</li>
<li>ams会调用<code>startProcessLocked()</code>方法来创建新的进程，这个时候<code>zygote</code>会孵化自身，并调用zygote的main方法来实例化<code>ActivityThread</code>对象并且返回新进程的pid.</li>
</ul>
<p><code>activityThread</code>会依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>方法来开启消息循环。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qm7zgvbyj30xc0j878a.jpg" alt=""></figure>
<h4 id="绑定application">绑定Application</h4>
<p>接着就是将进程和<code>Application</code>绑定起来了。绑定流程是通过<code>ActivityThread</code>的<code>bindApplication()</code>方法来完成的。绑定过程中会构造一个<code>AppBindData</code>的对象，然后会将其作为参数通过<code>sendMessage()</code>方法发送一个<code>H.BIND_APPLICATION</code>标识的消息。然后通过<code>handleMessage()</code>方法来处理这条消息，接着调用<code>handleBindApplication()</code>，最终调用<code>makeApplication()</code>方法来构造出一个application对象，接着调用applicaton的onCrate()方法。<br></p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9rel617hnj30x50gfjvb.jpg" alt=""></figure>
<h4 id="启动activity">启动Activity</h4>
<p>经过前面的步骤，系统已经拥有了<code>Application</code>的进程。后面的调用顺序就是从一个已经存在的进程启动一个新进程的activity了。实际调用的方法是<code>realStartActivity()</code>,它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个<code>LAUNCH_ACTIVITY</code>消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。<br>
<img src="https://i.loli.net/2019/12/10/5JfkVocGy3PSKUI.png" alt=""><br>
至此，一个应用的启动流程就结束了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：系统开机流程]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidxi-tong-kai-ji-liu-cheng</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidxi-tong-kai-ji-liu-cheng">
        </link>
        <updated>2019-12-09T08:07:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="整体流程">整体流程</h4>
<ul>
<li>Android开机时按照<code>loader</code>-&gt;<code>kernel</code>-&gt;<code>framework</code>-&gt;<code>application</code>的流程来进行的。附上Android架构图<br></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qaqc8eosj30lm0fita7.jpg" alt=""><br>
<br><br>
再附图一张，启动流程图<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qazhj6tzj30tc0qowif.jpg" alt=""></p>
<h4 id="loader层">loader层</h4>
<p><code>boot rom</code>手机处于关机状态下，长按开机键开机，会引导芯片从烧录在rom里面预设的代码开始执行，加载引导程序到ram。<br><br>
<code>boot loader</code>:启动Android系统之前的引导程序，主要是检查ram,初始化参数。</p>
<h4 id="kernel层">kernel层</h4>
<p>指的就是Android内核层，一般指的是开机刚刚结束进入到Android系统，<code>kernel</code>层启动流程如下:</p>
<ul>
<li>启动<code>swapper</code>进程，pid=0。系统初始化kernel创建的第一个进程，用户初始化进程管理、内存管理、加载<code>display</code>,<code>camera</code>,<code>binder</code>等驱动。<mark>拓展：systemServer是什么时候启动的？binder服务是cs架构，既然ams等都是基于binder的那么先有鸡还是先有蛋</mark>分析见下文</li>
<li>启动<code>kthreadd</code>进程，这里是加载linux系统的内核进程，会创建内核工作线程<code>kworker</code>、软中断线程<code>ksoftirqd</code>和<code>thermal</code>等内核守护进程。<code>kthreadd</code>是所有内核进程的老爹。</li>
</ul>
<h4 id="native层">native层</h4>
<p>这里的<code>native</code>层主要包括由<code>init</code>进程孵化出来的用户空间的守护进程，<code>bootanim</code>开机动画和<code>hal</code>层等。<code>init</code>是<code>linux</code>系统的守护进程，是所有用户空间进程的老爹;<mark>注意区分内核进程和用户进程的区别</mark></p>
<ul>
<li>init进程还会孵化出<code>ueventd</code>,<code>logd</code>,<code>adbd</code>,<code>healthd</code>,<code>installd</code>,<code>adbd</code>等用户守护进程</li>
<li>init进程还会启动<code>serviceManager</code>进程(用来管理binder)，bootanim等服务</li>
<li>init进程还会孵化出<code>zygote</code>进程，<code>zygote</code>是Android系统上面第一个<code>java</code>进程，它是所有Java进程的爸爸。</li>
</ul>
<h4 id="framework层">framework层</h4>
<p><code>framework</code>层是由<code>native</code>和<code>java</code>层共同组成的，协调系统平稳有序的工作。<code>framework</code>层主要包括以下内容。</p>
<ul>
<li><code>Media Server</code>进程，是由<code>init</code>进程<code>fork</code>而来，负责启动和管理这个那个<code>c++ framework</code>,包含<code>AudioFlinger</code>,<code>cameraService</code>等服务。</li>
<li><code>zygote</code>进程是虚拟机孵化的第一个Java进程，是所有Java进程的老爹。</li>
<li><code>System server</code>是由<code>zygote</code>进程fork而来，是<code>zygot</code>进程的第一个子进程，负责启动和管理整个Java framework。包括不限于ams、pms。</li>
</ul>
<h4 id="app层">app层</h4>
<p><code>zygote</code>进程孵化的第一个<code>app</code>进程就是<code>launcher</code>.就是我们看到的桌面应用。因为在前面的framework中生成了各种守护进程和管理进程，对于<code>launcer</code>也就有对应的点击、长按、滑动、卸载等监听。<code>zygote</code>也会创建<code>browser</code>、<code>phone</code>、<code>email</code>等app进程。也就是说所有的app进程都是由<code>zygote</code>进程孵化而来。</p>
<h4 id="拓展">拓展:</h4>
<ul>
<li>
<p>为什么Android系统第一次开机时间会比较长</p>
<ul>
<li>Android系统刷机后第一次开机启动时，需要扫描所有预装的apk文件，提取dex字节码，优化并且拷贝到/data/dalvik-cache缓存目录中，因此，第一次启动耗时会明显更高。</li>
<li>如果手动的删除了<code>/data/dalvik-cache</code>目录下的东西，那么下次在卡机时也会重新走一遍dex优化流程。</li>
<li>sample：线下终端在升级读取流量卡号过程中，流程没有走完，导致<code>telephone.jar</code>没有被授予足够的权限，导致开机之后没法访问<code>telephoneService</code>。
<ul>
<li>修复办法：重新赋予权限，并且删除<code>data/dalvik-cache</code>下面的dex.oat文件，然后重启系统。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>dalvik&amp;art虚拟的区别？</p>
<ul>
<li>dalvik
<ul>
<li>是jit模式，just-in-time，即时编译的，在程序运行时候将代码逐行逐行便已成为机器码。</li>
</ul>
</li>
<li>art
<ul>
<li>AOT模式 ahead-of-time.预编译。</li>
</ul>
</li>
<li>art 优缺点总结：
<ul>
<li>优点
<ul>
<li>系统性能的显著提升</li>
<li>应用速度会更快</li>
<li>节省电量</li>
<li>硬件支持版本会更低</li>
</ul>
</li>
<li>缺点
<ul>
<li>应用占用的系统空间会更大</li>
<li>应用安装时间会更长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Android不同版本虚拟机演进史</p>
<ul>
<li>在5.0以前都是dalvik虚拟机，是jit编译模式</li>
<li>5.0以后添加了art虚拟机，ahead-of-time</li>
<li>7.0以后引入了全新的JIT编译器，在这个版本是art+jit混合编译。在初次安装的时候并不是全部预编译，而是通过jit编译期的分析结果进行编译。</li>
</ul>
</li>
<li>
<p>android在关机状态下是怎么做到定时开机的？</p>
<ul>
<li>可以定时开机的前提是有RTC部件，以及可以单独供电的纽扣电池。RTC会记录设置的时间，时间到之后会引导程序走开机流程。</li>
</ul>
</li>
<li>
<p>watchDog概念是什么？</p>
<ul>
<li>WatchDog <a href="http://gityuan.com/2016/06/21/watchdog/">WatchDog工作原理</a>
<ul>
<li><code>WatchDog</code>是一个运行在<code>system_server</code>名为<code>watchDog</code>的线程。</li>
<li>运行过程中，如果阻塞时间超过1分钟则会触发一次watchDog,会杀死<code>system_server</code>。触发上层重启。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>binder是什么时候被启动或者binder服务是先有鸡还是先有蛋</p>
<ul>
<li>通过前文分析是知道system_server是在<code>zygote</code>进程孵化出来的就是在系统启动framework层进行的</li>
</ul>
</li>
<li>
<p>怎么将一个应用变为系统系统？</p>
<ul>
<li>在manifest中添加:<code>andoid:shareUserId</code>=&quot;android.uid.system&quot;</li>
<li>使用通用签名打包</li>
<li>获取root权限，将apk Push到<code>system/app</code>目录下面自定义的目录。</li>
<li>给system/app目录下的app增加权限</li>
</ul>
</li>
<li>
<p>怎么将一个应用修改为launcher桌面？</p>
<ul>
<li>在主activity的intent-filter中添加</li>
</ul>
<pre><code class="language-java">&lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;

</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：EventBus源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-28T10:04:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>EventBus对于Android开发着来讲可以说是再熟悉不过了。不管是最开始的mvc模式还是现在的组件化开发模式，EventBus一直没有没落下去，今天我们就来详细分析一下EventBus的内部原理。</p>
<h4 id="介绍">介绍</h4>
<p>官方介绍中，EventBus是一个Android或者Java可以使用的基于发布、订阅的框架。这里放上官方的流程图:<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/27/16eacfa9e88928f9?w=1280&amp;h=479&amp;f=png&amp;s=28898" alt=""><br>
通过流程图可以发现，EventBus的整体使用的是非常的简单，发布者post一个事件，所有消费者监听到之后消费。这就是一点典型的观察者模式的设计模式。</p>
<table><tr><td bgcolor="#f7f6f3">
观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
</td></tr></table>
<h4 id="上手使用">上手使用</h4>
<p>跟之前一样，我们还是先从使用开始，其实这步好像可以省略。大家对EventBus的使用应该非常熟悉，但是流程还是要走一下的。<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb12aa3c70c7fa?w=1572&amp;h=616&amp;f=jpeg&amp;s=70991" alt=""><br>
在<code>onStart()</code>方法中注册，<code>onStop()</code>中销毁。再来定义一个event,在<code>onResume</code>中发送，并且直接注册一个观察者来接受这个event。</p>
<pre><code class="language-kotlin">    @Subscribe(threadMode = ThreadMode.MAIN)
    fun onReceiveEvent(event: TestEvent) {
        Log.d(&quot;EventBus&quot;, &quot;receive event&quot;)
    }
</code></pre>
<p>运行上面这段代码可以在控制台看到输出:</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb13094fde6dc4?w=1142&amp;h=64&amp;f=jpeg&amp;s=16319" alt=""><br>
可以看到EventBus整个的使用流程是非常简单的，当然也可以在发送事件的时候携带参数，直接在event类中定义就ok。下面我们将详细分析一下EventBus的内部流程。</p>
<h4 id="源码探究">源码探究</h4>
<p>还是老规矩，我们将按照使用流程来一点点剥开它的外壳，发现它的内部纹路。</p>
<h5 id="获取eventbus">获取EventBus</h5>
<p>EventBus在构造方法执行的时候会通过<code>builder</code>模式来设置一些常用参数，先来看一下这些设置：</p>
<pre><code class="language-java">    EventBus(EventBusBuilder builder) {
        //log打印器
        logger = builder.getLogger();
        //Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType
        //以event为key,订阅列表为value，是一个线程安全的容器
        subscriptionsByEventType = new HashMap&lt;&gt;();
        //Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;
        //订阅者为key,event为value的容器 
        typesBySubscriber = new HashMap&lt;&gt;();
        //粘性事件的容器
        stickyEvents = new ConcurrentHashMap&lt;&gt;();
        //是否支持主线程
        mainThreadSupport = builder.getMainThreadSupport();
        //如果支持主线程，构建出来一个主线程发射器
        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
        //初始化BackgroundPoster
        backgroundPoster = new BackgroundPoster(this);
        //初始化AsyncPoster
        asyncPoster = new AsyncPoster(this);
        //是否有编译期已经生成的索引类，关于索引将会在列表中放出解析文章链接
        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
        //初始化注册时间寻找器，具体将在后续分析
        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                builder.strictMethodVerification, builder.ignoreGeneratedIndex);
        //是否打印出订阅异常
        logSubscriberExceptions = builder.logSubscriberExceptions;
        logNoSubscriberMessages = builder.logNoSubscriberMessages;
        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
        throwSubscriberException = builder.throwSubscriberException;
        eventInheritance = builder.eventInheritance;
        //当接收模式为backGroud和async时的线程调度器，默认为缓存线程池
        executorService = builder.executorService;
    }
</code></pre>
<p>当然如果我们在使用的时候也可以自定义配置。配置方式如下:</p>
<pre><code class="language-java">EventBus eventBus = EventBus.builder()
    .logNoSubscriberMessages(false)
    .sendNoSubscriberEvent(false)
    .build();
</code></pre>
<p>分析过构造方法之后再来看一下<code>getDefault()</code>:</p>
<pre><code class="language-java">    public static EventBus getDefault() {
        if (defaultInstance == null) {
            synchronized (EventBus.class) {
                if (defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }
        return defaultInstance;
    }
</code></pre>
<p>可以看到这里是使用了单例模式的<strong>双重检查模式</strong>,关于单例模式的多种不同写法可以<a href="https://blog.csdn.net/itachi85/article/details/50510124">参考</a>。只有第一次使用的时候才会初始化，最大限度的保证了资源的利用效率。</p>
<h4 id="注册">注册</h4>
<p>要想通过EventBus来观察被观察者，首先是需要注册，来告诉程序你需要观察某个对象的改变。我们来看一下<code>register</code>是做了什么事情。</p>
<pre><code class="language-java">    将给定的对象注册用来接收event，当不在需要观察event的变化时，必须调用unregister。
    同时，注册的对象内部必须有Subscribe注解的方法。
    public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>可以看到会通过<code>subscriberMethodFinder</code>当前对象注册的所有事件监听的方法，然后通过<code>subscribe()</code>方法来将注册的所有监听都添加到监听列表中。来分析下具体方法；</p>
<h6 id="findsubscribermethods">findSubscriberMethods</h6>
<p>根据方法名就可以很方便的理解，根据传入的观察者对象去寻找其内部定义的全部观察方法。首先根据<code>METHOD_CACHE.get(subscriberClass);</code>去获取到之前可能已经缓存的全部订阅方法。如果之前已经获取过那么直接返回，前面有提到过EventBus是全局单例，所以就很好理解了。如果缓存没有就需要重新去获取。</p>
<p>接着会根据build期间设置的是否忽略索引来获取，前文也有提到EventBus在编译期会提前生成索引，那么索引是怎么生成的呢？</p>
<table><tr>
<td bgcolor="#f7f6f3">
在3.0版本中，EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解，并解析和处理其中所包含的信息，然后生成java类来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。<br>
此处为引用
</td>
</tr></table>
<p>如果观察者内部并没有定义<code>@Subscribe</code>注解的方法会抛出异常。</p>
<p>通过<code>findSubscriberMethods</code>方法我们已经找到了观察者内部定义的全部标有<code>@Subscribe</code>的方法。接着就是在线程同步锁中调用<code>subcribe</code>方法。</p>
<h5 id="subscribe">subscribe</h5>
<p>前文已经拿到了当前订阅的事件类型，这里会根据<code>eventType</code>放入上文提到的<code>subscriptionsByEventType</code>线程安全的map中,当然会有一些安全检查。接着会根据注册时定义的优先级对订阅同一个事件的观察者进行排序。</p>
<p>紧接着将当前观察者中所有的订阅方法添加进以<code>subscriber</code>为key的map中。</p>
<p>最后是对粘性事件的处理,与<code>StickyBroadcast</code>是同一个概念。EventBus在定义订阅方法时，除了可以指定接收的线程之外还设有另外两个参数可以设定：</p>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Subscribe {
    //接收的线程
    ThreadMode threadMode() default ThreadMode.POSTING;
    //是否是粘性事件
    boolean sticky() default false;
    //事件优先级
    int priority() default 0;
}

</code></pre>
<p>继续看是怎么处理粘性事件的注册,直接判断当前注册进来的粘性事件是否存储在本地的<code>stickyEvents</code>。如果匹配上那么就会最终调用<code>postToSubscription()</code>方法。</p>
<h4 id="发送事件">发送事件</h4>
<p>EventBus的事件发送其实是非常简单的。我们来看一下:</p>
<ul>
<li>普通事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().post(TestEvent())
</code></pre>
<ul>
<li>粘性事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().postSticky(TestEvent())
</code></pre>
<h5 id="post方法">post方法</h5>
<pre><code class="language-java">   public void post(Object event) {
        PostingThreadState postingState = currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue = postingState.eventQueue;
        eventQueue.add(event);

        if (!postingState.isPosting) {
            postingState.isMainThread = isMainThread();
            postingState.isPosting = true;
            if (postingState.canceled) {
                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
            }
            try {
                while (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(0), postingState);
                }
            } finally {
                postingState.isPosting = false;
                postingState.isMainThread = false;
            }
        }
    }
</code></pre>
<ul>
<li>首先会从<code>currentPostingThreadState</code>中取出发送线程的状态机。<code>currentPostingThreadState</code>其实是一个<code>ThreadLocal</code>，关于<code>ThreadLocal</code>推荐一篇文章:<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a>。</li>
<li></li>
<li>拿到状态机中的事件队列</li>
<li>将事件添加到事件队列中</li>
<li>判断当前发送线程没有堆积任务正在处理才进入到发送逻辑</li>
<li>while循环中不断的从队列中取出第一个任务，调用<code>postSingleEvent</code>进行发送</li>
</ul>
<h5 id="postsingleevent方法">postSingleEvent方法</h5>
<p>上面说到，post方法实际上是将event添加到队列中，然后通过不断的从队列中取出第一个来进行处理。</p>
<pre><code class="language-java">   private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
        Class&lt;?&gt; eventClass = event.getClass();
        boolean subscriptionFound = false;
        if (eventInheritance) {
            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
            int countTypes = eventTypes.size();
            for (int h = 0; h &lt; countTypes; h++) {
                Class&lt;?&gt; clazz = eventTypes.get(h);
                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
        }
        if (!subscriptionFound) {
            if (logNoSubscriberMessages) {
                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);
            }
            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                    eventClass != SubscriberExceptionEvent.class) {
                post(new NoSubscriberEvent(this, event));
            }
        }
    }
</code></pre>
<p>对这个方法进行一个简单的总结:</p>
<ul>
<li>获取到发送的事件类型</li>
<li>调用<code>lookupAllEventTypes</code>方法从缓存中或者通过立即获取方式取到所有注册了此种事件类型的观察者们，包括被继承的类也会被找出来</li>
<li>调用<code>postSingleEventForEventType</code>来将事件发送</li>
</ul>
<p>postSingleEventForEventType实际上从本地缓存中取到对象中后还是调用我们上文分析粘性事件时最终调用的<code>postToSubscription</code>方法。</p>
<h5 id="posttosubscription-方法">postToSubscription 方法</h5>
<pre><code class="language-java">    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case MAIN_ORDERED:
                if (mainThreadPoster != null) {
                    mainThreadPoster.enqueue(subscription, event);
                } else {
                    // temporary: technically not correct as poster not decoupled from subscriber
                    invokeSubscriber(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
        }
    }
</code></pre>
<p>可以说这个方法是观察者接收事件时绝对会调用的方法。可以看到根据threadMode是区分了不同的逻辑，那threadMode是干嘛的呢？</p>
<pre><code class="language-java">//定义用来表示EventBus的方法在哪个线程被调用的枚举类
public enum ThreadMode {
    //与post方是在同一个线程
    POSTING,
    //直接在主线程中调用这个方法
    MAIN,
    //同样也是在主线程中调用 ，但是与Main有区别的地方在于它是通过队列来进行的，不是直接调用
    MAIN_ORDERED,
    //Android上将会在异步线程调用subscribler的方法，如果本身post方不是主线程，那么会直接在当前线程执行，跟`post`类似。如果是在主线程post，那么会直接在一个新的异步线程执行。
    BACKGROUND,
    //这个模式下，总是在一个单独的线程执行，不会在post线程以及主线程。可以用来执行一些耗时任务。内部是采用线程池来做线程的复用
    ASYNC
}
</code></pre>
<p>分析到这里也就差不多可以理解<code>postToSubscription</code>是按照方法注解中定义的<code>ThreadMode</code>来进行观察者接收事件的线程调度管理。不轮其是直接调用方法还是放入队列中进行管理最终都是通过反射在当前线程对方法进行调用。</p>
<h5 id="poststicky方法">postSticky方法</h5>
<pre><code class="language-java">  public void postSticky(Object event) {
        synchronized (stickyEvents) {
            stickyEvents.put(event.getClass(), event);
        }
        // Should be posted after it is putted, in case the subscriber wants to remove immediately
        post(event);
    }
</code></pre>
<p>可以看到<code>postSticky</code>内部逻辑也是非常简单，就是将event注册为粘性事件存放入本地缓存。后续逻辑与正常事件的发送一样。</p>
<h4 id="取消注册">取消注册</h4>
<p>分析完了注册和发送，我们必须要来讲一下反注册。我们平常在activity中使用广播的时候有注册，那么在activity销毁的时候一定要记得进行反注册，不然就会引起内存泄漏。同样的道理，假如我们某个观察者类在销毁的时候没有从eventBus中进行取消注册。eventBus全局单例就一直会持有当前观察者的引用，从而造成了内存泄漏。</p>
<pre><code class="language-java">    public synchronized void unregister(Object subscriber) {
        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);
        if (subscribedTypes != null) {
            for (Class&lt;?&gt; eventType : subscribedTypes) {
                unsubscribeByEventType(subscriber, eventType);
            }
            typesBySubscriber.remove(subscriber);
        } else {
            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
        }
    }
</code></pre>
<p>可以看到，取消注册的逻辑其实是非常简单的，无非是将要取消注册的观察者对象从本地缓存中和相关的map中都统一移除。</p>
<h4 id="总结">总结</h4>
<p>写到这里，基本上<code>EventBus</code>整个使用流程的代码分析都已完成，我们来大概总结一下：</p>
<ul>
<li>EventBus核心是使用观察者模式</li>
<li>通过builder模式设置参数，一般情况下使用默认</li>
<li>EventBus是使用<strong>双重检查模式</strong>的全局单例</li>
<li>注册时通过索引或者反射来获取订阅者中的所有订阅方法，粘性事件注册时会根据本地粘性事件map是否存在当前注册进来需要监听的订阅类型来决定要不要发送一次。</li>
<li>发送时根据事件类型等从本地在注册时就已经换成的对象进行发送，发送有接收线程、优先级以及是否粘性事件的区分。最终都是通过反射调用方法来进行通知的</li>
<li>取消注册，将订阅者对象从EventBus类的相关缓存中移除</li>
</ul>
<p>以上就是EventBus整体的大概流程分析，大概还是会有很多语意不明或者逻辑漏洞的地方，希望大家指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://blog.csdn.net/a553181867/article/details/52531479">EventBus 3.0进阶：源码及其设计模式 完全解析</a><br><br>
<a href="https://blog.csdn.net/qq_19431333/article/details/81173432">EventBus配置、粘性事件、优先级和取消事件分发</a><br><br>
<a href="https://www.jianshu.com/p/ed417a9cd7d6">EventBus3.0新特性之Subscriber Index</a><br><br>
<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:Retrofit源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-26T08:17:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>之前的文章，我们分析了okhttp一个网络请求的一些关键的步骤。今天会再来分析一下基本相当于其孪生兄弟的存在<strong>Retrofit</strong>。他们都是<strong>square</strong>公司出品的Android常用开发框架。那么关于<strong>Retrofit</strong>很多人其实都说是一个网络请求框架，类似于okhttp。那么它真的是这样的吗？我们今天就来看一下:</p>
<h4 id="使用retrofit进行一次网络请求">使用Retrofit进行一次网络请求</h4>
<p>既然是开发框架，按照规矩当然是首先会使用啦。关于使用文档，官方提供了<a href="https://square.github.io/retrofit/">github.io页面</a>。既然官方提供了示例，我们按照说明来操作一下，这是获取github某个用户repo的示例。</p>
<h5 id="api定义">API定义</h5>
<p>retrofit的使用首先要定义一个接口来说明需要请求的接口:</p>
<pre><code class="language-java">public interface GithubService {
    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
    
}
</code></pre>
<p>注意:retrofit中使用了大量的注解，在这个请求定义中可以看到。使用@get表示这个请求为get类型,使用path来与url中已经定义好的参数做映射。</p>
<h5 id="发出请求">发出请求</h5>
<pre><code class="language-kotlin"> private fun makeRetrofitCall() {
        val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            //相对官方示例，我们多了添加gson解析器这一步。一般如果不添加这里会抛出can not convert exception.
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val githubService = retrofit.create(GithubService::class.java)
        githubService.listRepos(&quot;alsowell&quot;).enqueue(object : retrofit2.Callback&lt;List&lt;Any&gt;&gt; {
            override fun onFailure(call: retrofit2.Call&lt;List&lt;Any&gt;&gt;, t: Throwable) {

            }
            override fun onResponse(
                call: retrofit2.Call&lt;List&lt;Any&gt;&gt;,
                response: retrofit2.Response&lt;List&lt;Any&gt;&gt;
            ) {
            Log.d(&quot;Retrofit&quot;,response.body().toString())
            }
        })
    }
</code></pre>
<p>到这里，使用retrofit进行的一个完整的网络请求就完成了。retrofit会使用我们设置的GsonConvertFactory来将response解析成用户希望的格式。使用的时候直接调用response.body()就可以拿到我们想要的数据。下面我一点一点的分析retrofit内部究竟做了什么。</p>
<h4 id="retrofitbuilder">Retrofit.builder()</h4>
<p>上面的网络请求中发现，首先要构造出来一个retrofit对象。retrofit跟okhttpclient一样也是使用建造者模式构建出来的，我们来看一下里面有哪些参数:</p>
<pre><code class="language-java">    private final Platform platform;
    private @Nullable okhttp3.Call.Factory callFactory;
    private @Nullable HttpUrl baseUrl;
    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();
    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();
    private @Nullable Executor callbackExecutor;
    private boolean validateEagerly;
</code></pre>
<h5 id="platform">Platform</h5>
<p>platform是retrofit判断当前运行平台的类。目前支持Android、java两个运行平台。在调用Retrofit.builder()方法时就通过调用Platform.get()方法来获取平台类型。同时也会进行一些对应平台的初始化工作。</p>
<h5 id="callfactory">callFactory</h5>
<p>字面意思就是请求工厂类。可以看到其类型是okhttp3定义的call对象。这里其实可以知道retrofit内部请求使用的仍然是okhttp，只不过是对其进行了一次封装，用户可以更方便的进行使用。关于callFactory也是支持用户进行设置进去的。</p>
<pre><code class="language-kotlin">  val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            .addConverterFactory(GsonConverterFactory.create())
            .callFactory(OkHttpClient.Builder().build())
            .build()
</code></pre>
<p>可以看到通过callFactory方法，就可以使用用户自己定义的<strong>OkHttpClient</strong>对象了。那如果用户没有设置呢？</p>
<pre><code class="language-kotlin"> public Retrofit build() {
    //省略代码
      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }
      //省略代码
    }
</code></pre>
<p>会发现，在调用build方法时,retrofit会对当前的callFactory进行空判断。如果当前为null，那么会直接new OkHttpClient()。</p>
<h5 id="httpurl">HttpUrl</h5>
<p>HttpUrl其实也是okHttp包中的类，通过源码可以看到我们设置baseUrl为https://api.github.com/时，内部也是通过HttpUrl.get()方法来进行一些url合法性的校验，以及解析设置后续网络请求会用到的一些参数。具体可在之前OkHttp系列文章中找到。</p>
<h5 id="converterfactories">converterFactories</h5>
<p>看见名字我们就知道其实是转换器的工厂。例如我们在前面进行请求时设置了一个GsonConvertFactory来将网络请求的数据解析成我们真正想要的返回。关于Converte和Factory我们将在下文进行详细的分析，这里先保留一些疑问。</p>
<h5 id="calladapterfactories">callAdapterFactories</h5>
<p>翻译过来就是请求适配器工厂,见名知其意即为对请求进行包装来适配不同框架的工厂集。一般我们在使用retrofit时都会结合RxJava来一起使用,那么就是通过callAdapter来进行使用的。同样我们也还是保持一些疑问留给下文详细探究。</p>
<h5 id="callbackexecutor">callbackExecutor</h5>
<p>回调执行器，是不是很好理解?就是我们请求完成之后对我们回调的数据进行线程切换的执行器。同样也可以通过在build过程中用户动态的设置进来。如果没有设置那么retrofit是怎么做的呢?</p>
<pre><code class="language-java">  Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }
</code></pre>
<p>上文我们有说到过platform其实就是运行平台的意思。defaultCallbackExecutor()其实是Platform中定义的方法,每个平台对应其有自己的实现。在Android平台下:</p>
<pre><code class="language-kotlin">    @Override public Executor defaultCallbackExecutor() {
      return new MainThreadExecutor();
    }
    //静态内部类
     static class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());

      @Override public void execute(Runnable r) {
        handler.post(r);
      }
    }
</code></pre>
<p>可以看到默认是在主线程回调返回的，拿到主线程的handler对象，拿到解析完成后的响应数据后通过mainHandler的post方法直接回调到主线程，让用户可以直接在主线程中去更新UI。</p>
<h5 id="validateeagerly">validateEagerly</h5>
<p>用来配置在使用retrofit.crate()时是否对接口中定义的所有方法进行解析。</p>
<p><br></br><br>
上文说到通过Retrofit.builder.xxx.xxx.build()方法最终是拿到一个Retrofit对象的。那我们来接着看一下</p>
<h4 id="retrofit">Retrofit</h4>
<p>首先看一下构造方法:</p>
<pre><code class="language-java"> Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,
      @Nullable Executor callbackExecutor, boolean validateEagerly) {
    this.callFactory = callFactory;
    this.baseUrl = baseUrl;
    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
    this.callbackExecutor = callbackExecutor;
    this.validateEagerly = validateEagerly;
  }
</code></pre>
<p>既然是通过builder.build方法来构建出来我们需要的retrofit对象，那就详细的来看一下build做了哪些操作:</p>
<pre><code class="language-java">   public Retrofit build() {
      if (baseUrl == null) {
        throw new IllegalStateException(&quot;Base URL required.&quot;);
      }

      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }

      Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }

      // Make a defensive copy of the adapters and add the default Call adapter.
      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);
      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));

      // Make a defensive copy of the converters.
      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(
          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

      // Add the built-in converter factory first. This prevents overriding its behavior but also
      // ensures correct behavior when using converters that consume all types.
      converterFactories.add(new BuiltInConverters());
      converterFactories.addAll(this.converterFactories);
      converterFactories.addAll(platform.defaultConverterFactories());

      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
    }
</code></pre>
<p>按照调用步骤分析如下:</p>
<ul>
<li>先判断baseUrl是否为null,为null直接抛出异常</li>
<li>判断是否有设置callFactory和callBackExecutor，无则使用默认的。具体前文有介绍</li>
<li>将平台默认的适配器添加到最后，来看一下Android平台默认的适配器<pre><code class="language-java">//这里传入的executor为上文中用户自定义或者android平台的默认MainExecutor
//关于DefaultCallAdapterFactory将在后续详细分析
List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(
  @Nullable Executor callbackExecutor) {
return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
}
</code></pre>
</li>
<li>定义一个大小为1+用户设置转换器集合size+系统默认转换器size的集合</li>
<li>将retrofit内置的转换器添加进去</li>
<li>将用户设置的转换器添加进去</li>
<li>添加平台默认的转换器
<ul>
<li>Android平台下仅仅在api&gt;24时候添加进来一个OptionalConverterFactory,其他时候为一个空数组</li>
</ul>
</li>
<li>最终通过调用Retrofit的构造方法来成功构建出Retrofit对象</li>
</ul>
<p>构造无非是把我们在builder中设置的参数传递进来并赋值给类中定义的变量。我们来看一下Retrofit类中定义的一些变量:</p>
<pre><code class="language-java">  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();
  final okhttp3.Call.Factory callFactory;
  final HttpUrl baseUrl;
  final List&lt;Converter.Factory&gt; converterFactories;
  final List&lt;CallAdapter.Factory&gt; callAdapterFactories;
  final @Nullable Executor callbackExecutor;
  final boolean validateEagerly;
</code></pre>
<p>除了serviceMethodCache，其他变量均已经在我们在build时设置过。</p>
<h5 id="servicemethodcache">serviceMethodCache</h5>
<p>可以看到serviceMethodCache是一个HahshMap集合,实际上是对我们在接口中定义的方法的缓存。是否还记得我们通过注解定义了请求方法类型、请求参数等。我们来看一下ServiceMethod这个类</p>
<pre><code class="language-java">abstract class ServiceMethod&lt;T&gt; {
  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {
    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);

    Type returnType = method.getGenericReturnType();
    if (Utils.hasUnresolvableType(returnType)) {
      throw methodError(method,
          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
    }
    if (returnType == void.class) {
      throw methodError(method, &quot;Service methods cannot return void.&quot;);
    }

    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
  }

  abstract @Nullable T invoke(Object[] args);
}

</code></pre>
<p>这里是定义的一个带有泛型的抽象类，通过parseAnnotations()来对我们在定义方法时候的注解进行解析。我们具体来看一下parseAnnotations()方法</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea72855f7c884f?w=2150&amp;h=1094&amp;f=jpeg&amp;s=410765" alt=""><br>
可以看到这里是根据HTTP协议来传入方法类型以及是否有body体，具体实现也是很简单。</p>
<h4 id="retrofitcreate">Retrofit.create()</h4>
<p>按照调用流程我们拿到retrofit对象之后会通过retrofit.create(service)方法来拿到一个Service。来看一下具体实现:</p>
<pre><code class="language-java"> public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();
          private final Object[] emptyArgs = new Object[0];

          @Override public @Nullable Object invoke(Object proxy, Method method,
              @Nullable Object[] args) throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
          }
        });
  }
</code></pre>
<p>简单翻译一下注释:是我们在service接口中定义的方法的具体实现。具体来看代码:</p>
<ul>
<li>通过validateEagerly变量来判断是否提前将接口类中的所有方法解析出来。具体解析分析见下文</li>
<li>验证接口类的合法性
<ul>
<li>必须是接口定义</li>
<li>接口类中不能有内部接口类</li>
</ul>
</li>
<li>返回动态代理的具体实现（关于动态代理，这里提供一篇优秀的文章:<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a>）
<ul>
<li>先来看一下Proxy.newProxyInstance这个方法传入的参数。
<ul>
<li>ClassLoader:对应我们传入的service的classLoader</li>
<li>Class&lt;?&gt;[]:需要被代理的接口类,这里传入我们定义的service</li>
<li>InvocationHandler:使用默认的InvocationHandler</li>
</ul>
</li>
<li>具体看一下InvocationHandler方法里面做了什么事情?
<ul>
<li>首先拿到当前运行的平台（这里特指android）</li>
<li>定义一个空的对象数组</li>
<li>看一下invoke方法里面的调用逻辑
<ul>
<li>如果代理的方法是从一个object中的那么直接走原来的方法</li>
<li>根据平台类型来判断执行分支(android version 24以后可能是发生了改动)Android platform这里是做了兼容是不会进来的</li>
<li>返回loadServiceMethod.invoke()方法的返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="loadservicemethod">loadServiceMethod</h5>
<p>经过上面的分析知道，retrofit.create()方法返回的是loadServiceMethod.invoke()的代理实现。那来看一下这个是做了什么事情。<br></p>
<ul>
<li>注:上文说到的提前解析其实也是调用的这个方法，在for循环中进行</li>
</ul>
<pre><code class="language-java">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
    if (result != null) return result;

    synchronized (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      if (result == null) {
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }
</code></pre>
<ul>
<li>首先从缓存中去取看是否已经存在,存在的话直接返回</li>
<li>在代码锁中再次尝试从缓存中取出，我的理解是为了防止请求进行时，之前提前解析时才完成，这样就避免重复的去解析接口中定义的方法造成资源浪费</li>
<li>通过ServiceMethod.parseAnnotations()方法将定义的请求解析出来并缓存(关于解析的具体逻辑，上文也说到过看似复杂其实就是按照特定的规则将定义的信息取出，感兴趣的同学可以具体看一下)。这里详细解析一下在解析之外做的事情，见下文。</li>
</ul>
<h5 id="httpservicemethod">HttpServiceMethod</h5>
<p>在loadServiceMethod方法中调用了ServiceMethod.parseAnnotations()来解析我们在接口方法中定义的一些参数,最终返回的是HttpServiceMethod.parseAnnotations（）的返回。</p>
<p>HttpServiceMethod其实继承于ServiceMethod,ServiceMethod定义了一个invoke的抽象方法。还记得在retrofit create中返回的是ServiceMethod.invoke()吗？</p>
<p>还是先看一下在HttpServiceMethod的parseAnnotations中做了什么事情</p>
<pre><code class="language-java"> static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
      Retrofit retrofit, Method method, RequestFactory requestFactory) {
    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
    boolean continuationWantsResponse = false;
    boolean continuationBodyNullable = false;

    Annotation[] annotations = method.getAnnotations();
    Type adapterType;
    if (isKotlinSuspendFunction) {
      Type[] parameterTypes = method.getGenericParameterTypes();
      Type responseType = Utils.getParameterLowerBound(0,
          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
      if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) {
        // Unwrap the actual body type from Response&lt;T&gt;.
        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
        continuationWantsResponse = true;
      } else {
        // TODO figure out if type is nullable or not
        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
        // Find the entry for method
        // Determine if return type is nullable or not
      }

      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
    } else {
      adapterType = method.getGenericReturnType();
    }
    //创建请求适配器
    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =
        createCallAdapter(retrofit, method, adapterType, annotations);
    Type responseType = callAdapter.responseType();
    if (responseType == okhttp3.Response.class) {
      throw methodError(method, &quot;'&quot;
          + getRawType(responseType).getName()
          + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;);
    }
    if (responseType == Response.class) {
      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);
    }
    // TODO support Unit for Kotlin?
    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) {
      throw methodError(method, &quot;HEAD method must use Void as response type.&quot;);
    }
    //创建响应体转换器 
    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =
        createResponseConverter(retrofit, method, responseType);

    okhttp3.Call.Factory callFactory = retrofit.callFactory;
    if (!isKotlinSuspendFunction) {
      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);
    } else if (continuationWantsResponse) {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);
    } else {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,
          continuationBodyNullable);
    }
  }
</code></pre>
<p>这里我们来分析几个主要的函数:</p>
<ul>
<li>createCallAdapter
<ul>
<li>创建请求适配器，这里只放一些关键代码。<pre><code class="language-java">//createCallAdapter
return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);

//retrofit.callAdapter
return nextCallAdapter(null, returnType, annotations);

//nextCallAdapter
int start = callAdapterFactories.indexOf(skipPast) + 1;
for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {
  CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
  if (adapter != null) {
    return adapter;
  }
}

</code></pre>
<ul>
<li>可以看到这里是从我们之前在创建retrofit时候定义的callAdapterFactories中取出一个CallAdapter(DefaultCallAdapterFactory)</li>
</ul>
</li>
</ul>
</li>
<li>createResponseConverter
<ul>
<li>创建响应转换器<pre><code class="language-java">//createResponseConverter
return retrofit.responseBodyConverter(responseType, annotations);
//retrofit.responseBodyConverter
return nextResponseBodyConverter(null, type, annotations);
//nextResponseBodyConverter
int start = converterFactories.indexOf(skipPast) + 1;
for (int i = start, count = converterFactories.size(); i &lt; count; i++) {
  Converter&lt;ResponseBody, ?&gt; converter =
      converterFactories.get(i).responseBodyConverter(type, annotations, this);
  if (converter != null) {
    //noinspection unchecked
    return (Converter&lt;ResponseBody, T&gt;) converter;
  }
}
</code></pre>
<ul>
<li>可以看到createResponseConverter与createCallAdapter类似，均是从之前定义的列表中返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<tr>
<td bgcolor="f7f6f3">
题外话：曾经遇到一道面试题:retrofit是什么时候将接口中定义的方法解析出来的？是一次性将所有方法解析出来还是使用到的时候在解析?<br>
分析到这里，答案其实很简单了。默认情况下，用户没有通过validateEagerly()方法设置提前解析的话，retrofit是地用到具体方法的时候才会将方法解析出来，这样就可能尽可能的降低内存消耗。如果设置为true的情况，那么就是直接在create创建retrofit对象的时候将接口类中定义的方法一次性全部解析出来。
</td>
</tr>
</table>
<h4 id="方法调用">方法调用</h4>
<p>我们分析了retrofit的create方法其实动态代理了我们在接口中定义的方法。那接着来看一下在调用方法的时候是干了什么</p>
<pre><code class="language-java">    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
</code></pre>
<pre><code class="language-kotlin"> val listRepos = githubService.listRepos(&quot;alsowell&quot;)
</code></pre>
<p>可以看到我们在接口中定义的方法的返回其实是一个call对象，还记得okhttp中的call吗？你是不是以为是一个东西？但是其实这个是retrofit内部自己定义的。</p>
<p>经过前文的分析我们知道当我们调用接口里面的方法时候，其实会调用invoke方法。并且这里实际调用的是HttpServiceMethod的invoke()方法。我们来看一下做了什么操作。</p>
<pre><code class="language-java">  @Override final @Nullable ReturnT invoke(Object[] args) {
    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);
    return adapt(call, args);
  }
</code></pre>
<p>这里的okhttpCall其实是retrofit对okhttp的封装，这里是进行了简单的赋值操作。<br>
最终返回的是adapt(call,args)。继续往下看，adapt其实是CallAdapter接口中定义的方法。还记得我们在build retrofit时默认的DefaultCallAdapterFactory吗？具体的实现是由它来做的。</p>
<pre><code class="language-java">   return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
      @Override public Type responseType() {
        return responseType;
      }

      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
        return executor == null
            ? call
            : new ExecutorCallbackCall&lt;&gt;(executor, call);
      }
    };
</code></pre>
<p>可以看到最终会返回ExecutorCallbackCall，他也是继承于Call</p>
<h5 id="executorcallbackcall">ExecutorCallbackCall</h5>
<pre><code class="language-java"> static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
    final Executor callbackExecutor;
    final Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
      this.callbackExecutor = callbackExecutor;
      this.delegate = delegate;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      checkNotNull(callback, &quot;callback == null&quot;);

      delegate.enqueue(new Callback&lt;T&gt;() {
        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              if (delegate.isCanceled()) {
                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));
              } else {
                callback.onResponse(ExecutorCallbackCall.this, response);
              }
            }
          });
        }

        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              callback.onFailure(ExecutorCallbackCall.this, t);
            }
          });
        }
      });
    }

    @Override public boolean isExecuted() {
      return delegate.isExecuted();
    }

    @Override public Response&lt;T&gt; execute() throws IOException {
      return delegate.execute();
    }

    @Override public void cancel() {
      delegate.cancel();
    }

    @Override public boolean isCanceled() {
      return delegate.isCanceled();
    }

    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.
    @Override public Call&lt;T&gt; clone() {
      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());
    }

    @Override public Request request() {
      return delegate.request();
    }
  }
</code></pre>
<p>上文介绍过retrofit的call对象其实是对okhttpcall的封装。基本上与ok的方法相同。通过create动态代理拿到接口的代理类后可以直接调其中定义的方法。那么在执行enqueue方法时的具体实现可以在上文中代码看到，retrofit是定义了</p>
<pre><code class="language-java"> final Call&lt;T&gt; delegate;
</code></pre>
<p>这么一个泛型对象来进行真正的执行。其实在上文也分析到了这里的delegate其实是retrofit内部封装的OkHttpCall类，这个也是我们在build retrofit时通过addConverterFactory设置进来或者默认的。</p>
<ul>
<li>所以可以说retrofit执行网络请求的底层依然是okhttp，此结论成立。</li>
</ul>
<p>执行完毕后会推过设置的callBackExecutor回调出去，默认是主线程。</p>
<h4 id="解析阶段">解析阶段</h4>
<p>上文既然说到我们是通过retrofit封装的OkhttpCall对象实际调用的还是okhttp来进行网络请求，之后拿到响应再回调到主线程。但是我们在ExecutorCallbackCall好像并没有看到解析response的过程，那用户是怎么拿到解析之后的返回呢？</p>
<p>既然这里没有，那我们肯定要追根溯源去实际返回响应的地方找一下:</p>
<pre><code class="language-java">   call.enqueue(new okhttp3.Callback() {
      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
        Response&lt;T&gt; response;
        try {
          response = parseResponse(rawResponse);
        } catch (Throwable e) {
          throwIfFatal(e);
          callFailure(e);
          return;
        }

        try {
          callback.onResponse(OkHttpCall.this, response);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }

      @Override public void onFailure(okhttp3.Call call, IOException e) {
        callFailure(e);
      }

      private void callFailure(Throwable e) {
        try {
          callback.onFailure(OkHttpCall.this, e);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }
    });
</code></pre>
<p>可以看到里面有一句关键的代码<strong>parseResponse(rawResponse);</strong>，继续往下看:</p>
<pre><code class="language-java">      T body = responseConverter.convert(catchingBody);
</code></pre>
<p>在这个方法里面找到这个关键的一句，经过我们之前设置的converter转换之后返回的是我们在方法里面定义的泛型。</p>
<h4 id="总结">总结</h4>
<p>上面分析了这么多，先来总结一下Retrofit的大概流程</p>
<ul>
<li>定义一个接口类，定义出我们需要请求的方法</li>
<li>通过builder模式构建出retrofit对象</li>
<li>调用create()方法通过动态代理的方式返回实际的代理对象</li>
<li>通过代理对象来调用接口中定义的方法</li>
<li>enqueue或者excute实际上是调用addCallAdapterFactory中设置的(默认是okhttp)</li>
<li>通过okhttp来进行实际的网络请求</li>
<li>通过设置的converter来对返回的response进行解析成用户定义的格式</li>
<li>通过callBackExecutor回调给调用方（默认是主线程）</li>
</ul>
<p>至此，我们对Retrofit源码的探究终于可以说是告一段落了，跟OkHttp一样，retrofit的源码同样有很多值得我们学习的地方，例如动态代理的实现。整篇文章下来可能有很多不严谨的地方，这里只是记录个人对于Retrofit的理解，希望大家多多指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee">Retrofit源码解析</a><br><br>
<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(七)CallServerInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor">
        </link>
        <updated>2019-11-26T02:53:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>终于！我们来到了ok内置五大拦截器最后一个拦截器的探究。关于这个拦截器我们直接来看一下源码的注释:</p>
<table><tr><td>
This is the last interceptor in the chain. It makes a network call to the server.
</td></tr></table>
<p>看到这里是不是有种拨开云雾见明月的感觉。话不多说我们继续先看下源码:</p>
<pre><code class="language-kotlin">
  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

    exchange.writeRequestHeaders(request)

    var responseHeadersStarted = false
    var responseBuilder: Response.Builder? = null
    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) {
      // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100
      // Continue&quot; response before transmitting the request body. If we don't get that, return
      // what we did get (such as a 4xx response) without ever transmitting the request body.
      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase = true)) {
        exchange.flushRequest()
        responseHeadersStarted = true
        exchange.responseHeadersStart()
        responseBuilder = exchange.readResponseHeaders(true)
      }
      if (responseBuilder == null) {
        if (requestBody.isDuplex()) {
          // Prepare a duplex body so that the application can send a request body later.
          exchange.flushRequest()
          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
          requestBody.writeTo(bufferedRequestBody)
        } else {
          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.
          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
          requestBody.writeTo(bufferedRequestBody)
          bufferedRequestBody.close()
        }
      } else {
        exchange.noRequestBody()
        if (!exchange.connection()!!.isMultiplexed) {
          // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 connection
          // from being reused. Otherwise we're still obligated to transmit the request body to
          // leave the connection in a consistent state.
          exchange.noNewExchangesOnConnection()
        }
      }
    } else {
      exchange.noRequestBody()
    }

    if (requestBody == null || !requestBody.isDuplex()) {
      exchange.finishRequest()
    }
    if (!responseHeadersStarted) {
      exchange.responseHeadersStart()
    }
    if (responseBuilder == null) {
      responseBuilder = exchange.readResponseHeaders(false)!!
    }
    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
    var code = response.code
    if (code == 100) {
      // server sent a 100-continue even though we did not request one.
      // try again to read the actual response
      response = exchange.readResponseHeaders(false)!!
          .request(request)
          .handshake(exchange.connection()!!.handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
      code = response.code
    }

    exchange.responseHeadersEnd(response)

    response = if (forWebSocket &amp;&amp; code == 101) {
      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
      response.newBuilder()
          .body(EMPTY_RESPONSE)
          .build()
    } else {
      response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
    }
    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase = true) ||
        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase = true)) {
      exchange.noNewExchangesOnConnection()
    }
    if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) {
      throw ProtocolException(
          &quot;HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}&quot;)
    }
    return response
  }
  
</code></pre>
<h4 id="流程分析">流程分析</h4>
<p>是不是感觉臭长臭长的，但是莫慌！我们来一点一点攻克它。<br>
我们先来看下面几行代码</p>
<pre><code class="language-kotlin">    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

</code></pre>
<p>这里几行基本上取出对应的参数，并且设置当前时间为请求发出时间。关键的是从realChain中取出Exchange对象，这个对象是后续操作的比较关键的，之前在connectInterceptor中构建出来并且传递到当前的。</p>
<p>接着网下看:通过 exchange.writeRequestHeaders(request)方法来开始写入请求头，接着根据请求方式和请求体是否为空来进入分支逻辑:</p>
<h4 id="请求体不为空主要针对post请求br">请求体不为空(主要针对POST请求)<br></h4>
<h5 id="100-continue">100-continue</h5>
<p>刚开始看到这里笔者也是有点懵逼的，这是什么鬼header。于是开始Google大法:</p>
<table>
<tr>
<td bgcolor="#f7f6f3">
http 100-continue用于客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。在现实应用中，通常在POST大数据时，才会使用100-continue协议。<br>
来源:https://zhuanlan.zhihu.com/p/30830041
</td>
</tr>
</table>
<p>接着就是读取响应头，同时通知eventListener响应头开始读取。我们看源码的调用链是调用ExchangeCodec的readResponseHeaders()方法来读取响应头，具体类似于BridgeInterceptor中的intercept方法。</p>
<p>紧接着根据responseBuilder是否为null来进入分支逻辑，这个responseBuilder是根据又是根据header中的Expect是否为<strong>100-continue</strong>来判断的。接下来就是比较简单了，根据request构建出来一个requesBody，并且把其写入到请求的body中。</p>
<h4 id="请求体为空">请求体为空</h4>
<p>请求体为null的情况下就比较简单了直接调用noRequestBody()方法。表示当前request阶段已经完成.</p>
<h4 id="response阶段">Response阶段</h4>
<p>我们知道请求响应的开始也是从读取header。在上面经过发起Request结束之后，ok就已经做好准备进行response的接收。同样事件的发生也是会回调eventListener对应的监听。</p>
<pre><code class="language-kotlin">    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
</code></pre>
<p>可以看到经过一系列操作，我们已经拿到了服务器的返回。最终就是通过:</p>
<pre><code class="language-kotlin"> response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
</code></pre>
<p>这个方法来将服务端解析为客户端真正可用的resonse。</p>
<h4 id="总结">总结</h4>
<p>CallServerInterceptor的流程解析基本上到这里就结束了。纵观ok内置几个拦截器的源码，其实都不是很复杂，内部是采用了优秀的设计模式将以此请求中的每个阶段都做了分层，然后采用递归调用的思想通过几个拦截器将一个请求由上而下、再由下而上的完成。其中的设计模式以及代码的分离都是非常值得我们来学习的。</p>
<p>基本上关于拦截器的分析到这里就告一段了。整个流程下来笔者对于ok内部的很多东西也是一笔带过，后续将会好机会再详细分析。通过对ok一次请求的整体流程的探究，深知<strong>纸上得来终觉浅，绝知此事要躬行</strong>，这句话也跟大家一起共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（六）ConnectInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor">
        </link>
        <updated>2019-11-25T07:28:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>不知不觉已经到了要分析ok内置拦截器第四个的文章了，本篇的主角就是ConnectInterceptor，看名字也就知道它是负责与服务器建立连接的拦截器也。</p>
<h4 id="源码分析">源码分析</h4>
<p>话不多说，上代码:</p>
<pre><code class="language-kotlin">   @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val request = realChain.request()
    val transmitter = realChain.transmitter()

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    val doExtensiveHealthChecks = request.method != &quot;GET&quot;
    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)

    return realChain.proceed(request, transmitter, exchange)
  }
</code></pre>
<p>可以看到这个拦截器里面的代码是异常的精简，纵观全部发现关键步骤是在于调用transmitter.newExchange()方法。前面的文章中简单分析过transmitter类还有印象吗？这里再简单回顾下</p>
<h5 id="transmitter">Transmitter</h5>
<p>Transmitter是应用层和网络层之间的桥梁，对外暴露了网络连接过程中的connection、request、response、streams。</p>
<p>我们接着看newExchange方法做了什么事情</p>
<pre><code class="language-kotlin">  /** Returns a new exchange to carry a new request and response. */
  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
    synchronized(connectionPool) {
      check(!noMoreExchanges) { &quot;released&quot; }
      check(exchange == null) {
        &quot;cannot make a new request because the previous response is still open: &quot; +
            &quot;please call response.close()&quot;
      }
    }

    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)

    synchronized(connectionPool) {
      this.exchange = result
      this.exchangeRequestDone = false
      this.exchangeResponseDone = false
      return result
    }
  }
</code></pre>
<p>首先是通过exchangeFinder调动find方法拿到codec，那这几个又是什么东西呢？</p>
<h5 id="exchangefinder">ExchangeFinder</h5>
<p>不知大家对介绍重试拦截器的过程是否还有印象？在重试拦截器中有通过transmitter调用prepareToConnect()。exchangeFinder对象同时也是那个时候初始化的，当时的介绍是为了后续的网络连接做准备。我们今天就来看看其在ConnectionInterceptor过程中是怎么做的网络连接。</p>
<p>还是简单翻译一下ExchangeFinder的类注释：</p>
<table><tr><td bgcolor=""#f7f6f3>
尝试找到请求队列中的已经存在的连接,使用下列策略：<br>
1.如果当前请求已经连接上，那么就直接使用。
2.如果连接池中有可以服用的连接，那么根据RealConnection.isEligible来判断是否使用。
3.如果当前没有存在的连接，那么就尝试从新建立一个新的连接。
</td></tr></table>
<p>可以看到ok在建立连接的时候是遵循尽量服用连接池的做法，因为这样可以大大降低在网络连接过程解析DNS耗时、以及握手耗时。<br></p>
<p>那么find()方法是做了什么事情呢？还是先看一下代码:</p>
<pre><code class="language-kotlin"> fun find(client: OkHttpClient,chain: Interceptor.Chain,doExtensiveHealthChecks: Boolean
  ): ExchangeCodec {
    //参数设置代码省略。。。。。。。
    try {
    //找到目前可用的连接
      val resultConnection = findHealthyConnection(
          connectTimeout = connectTimeout,
          readTimeout = readTimeout,
          writeTimeout = writeTimeout,
          pingIntervalMillis = pingIntervalMillis,
          connectionRetryEnabled = connectionRetryEnabled,
          doExtensiveHealthChecks = doExtensiveHealthChecks
      )
      return resultConnection.newCodec(client, chain)
    } catch (e: RouteException) {
      trackFailure()
      throw e
    } catch (e: IOException) {
      trackFailure()
      throw RouteException(e)
    }
  }
</code></pre>
<p>抛却一大推设置参数的代码可以发现主要是findHealthyConnection()来找到一个可用的connection。那它究竟是怎么找的呢？（为了分析请求流程这里可能会有大量代码）。进入到findHealthyConnection()方法中我们发现在while循环中，主要是通过findConnection()来寻找可用connection。并且方法注释如下:</p>
<pre><code class="language-kotlin">  /**
   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
   * until a healthy connection is found.
   */
</code></pre>
<h5 id="findconnection">findConnection()</h5>
<pre><code class="language-kotlin"> /**
   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
   * then the pool, finally building a new connection.
   */
</code></pre>
<p>这是每次请求过程中真正找到connection的方法，至于是使用已经存在的还是新建立的我们通过代码来分析:(方法代码有点长，为了流程连贯，将在代码中使用注释分析)</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    //使用代码块锁 保证线程同步 
    synchronized(connectionPool) {
    //前文分析过这里只会是用户主动取消，如果取消抛出异常
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)
      hasStreamFailure = false // This is a fresh attempt.

      releasedConnection = transmitter.connection
      //这里判断如果数据传输已经完成就返回需要关闭的sokcet，反之为null
      toClose = if (transmitter.connection != null &amp;&amp; transmitter.connection!!.noNewExchanges) {
        transmitter.releaseConnectionNoEvents()
      } else {
        null
      }
        //已经有一个分配好的连接 并且处于可用状态 
      if (transmitter.connection != null) {
        // We had an already-allocated connection and it's good.
        result = transmitter.connection
        releasedConnection = null
      }
    //按照之前的策略，如果当前没有已经连接好的连接，会尝试从连接池中找到一个可用的。
      if (result == null) {
        // Attempt to get a connection from the pool.
        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        } else if (retryCurrentRoute()) {
          selectedRoute = transmitter.connection!!.route()
        }
      }
    }
    //关闭之前socket 
    toClose?.closeQuietly()

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection!!)
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result!!
    }
    
    // If we need a route selection, make one. This is a blocking operation.
    var newRouteSelection = false
    if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection!!.hasNext())) {
      newRouteSelection = true
      routeSelection = routeSelector.next()
    }

    var routes: List&lt;Route&gt;? = null
    synchronized(connectionPool) {
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection!!.routes
        //再次尝试从连接池中找到可用连接
        if (connectionPool.transmitterAcquirePooledConnection(
                address, transmitter, routes, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        }
      } 
        
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }
        //再次尝试从连接池中找到可用连接失败，创建一个connection 
        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }
    //刚刚创建出来的connection 调用connect方法进行网络连接 
    // Do TCP + TLS handshakes. This is a blocking operation.
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    //将当前域名从失败的黑名单中移除掉
    connectionPool.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      //在连接过程中最后一次尝试从连接池中找到已经有的连接，防止同时有两个相对host的请求发出，这样就能复用已有的连接
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = transmitter.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
      //将这次连接放入连接池中，为了后续可能直接复用
        connectionPool.put(result!!)
        transmitter.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }

</code></pre>
<p>经过分析代码可以发现，ok在进行连接建立的时候不是直接去建立的connection，而是尽可能的寻找已经存在的连接去进行复用。如果实在没有可利用的再去创建一条新的连接并且将其放入连接池给后续请求去复用。</p>
<p>经过上面苦苦一番寻找，我们终于拿到了一条建立好的可使用的连接RealConnection。然后直接调用newCodec()方法返回一个ExchangeCodec对象。我们再来看一下是干嘛的:</p>
<pre><code class="language-kotlin"> @Throws(SocketException::class)
  internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec {
    val socket = this.socket!!
    val source = this.source!!
    val sink = this.sink!!
    val http2Connection = this.http2Connection

    return if (http2Connection != null) {
      Http2ExchangeCodec(client, this, chain, http2Connection)
    } else {
      socket.soTimeout = chain.readTimeoutMillis()
      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)
      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)
      Http1ExchangeCodec(client, this, source, sink)
    }
  }
</code></pre>
<p>可以看到关键方法就是根据当前请求协议是HTTP1还是HTTP2来返回一个codec，我们跟进到codec类去看一下注释，大概翻译如下:</p>
<table><tr><td bgcolor="#f7f6f3">
一个用来发送http/1.1消息的socket连接，并且严格遵守下列的生命周期:<br>
- 发送请求的headers[writeRequest]<br>
- 打开一个水槽（直译）去写入请求体<br>
- 开始写入请求体然后关闭这个水槽<br>
- 读取响应头
- 申请一部分资源开始读取响应体
- 读取完成响应体后关闭资源
</td></tr></table>
经过上面寻找可用连接的操作之后基本上到了newExchange的最后一步去构建出来一个Exchange并且返回。
<h5 id="exchange">Exchange</h5>
<p>类注释很简单:传输一个http的请求和响应，是真正上处理IO操作的。事件的管理是被ExchangeCodec管控。</p>
<h4 id="总结">总结</h4>
<p>到这里,关于ConnectInterceptor的源码探究基本上就告一段落了。我们大概来总结下:</p>
<ul>
<li>从chain对象中获取到Transmitter对象</li>
<li>调用transmitter的newExchange()方法</li>
<li>根据调度策略找到可用的连接并返回</li>
<li>调用proceed调用下一个拦截器</li>
</ul>
<p>上面基本上就是ConnectionInterceptor的调用流程，接下来我们会继续分析ok内置的最后一个拦截器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（五）CacheInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor">
        </link>
        <updated>2019-11-22T09:42:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了重试拦截器和BridgeInterceptor(用来处理header、设置gzip、user-agent等)。本篇文章将开始分析ok内置拦截器比较实用的缓存拦截器<strong>CacheInterceptor</strong>。</p>
<p>顾名思义，CacheInterceptor就是处理与缓存相关的。关于http中的缓存知识可以参考<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a>。这篇文章写得非常浅显易懂。</p>
<h4 id="源码探究">源码探究</h4>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val cacheCandidate = cache?.get(chain.request())

    val now = System.currentTimeMillis()

    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
    val networkRequest = strategy.networkRequest
    val cacheResponse = strategy.cacheResponse

    cache?.trackResponse(strategy)

    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
      // The cache candidate wasn't applicable. Close it.
      cacheCandidate.body?.closeQuietly()
    }

    // If we're forbidden from using the network and the cache is insufficient, fail.
    if (networkRequest == null &amp;&amp; cacheResponse == null) {
      return Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(HTTP_GATEWAY_TIMEOUT)
          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)
          .body(EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
    }

    // If we don't need the network, we're done.
    if (networkRequest == null) {
      return cacheResponse!!.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build()
    }

    var networkResponse: Response? = null
    try {
      networkResponse = chain.proceed(networkRequest)
    } finally {
      // If we're crashing on I/O or otherwise, don't leak the cache body.
      if (networkResponse == null &amp;&amp; cacheCandidate != null) {
        cacheCandidate.body?.closeQuietly()
      }
    }

    // If we have a cache response too, then we're doing a conditional get.
    if (cacheResponse != null) {
      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
        val response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers, networkResponse.headers))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()

        networkResponse.body!!.close()

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache!!.trackConditionalCacheHit()
        cache.update(cacheResponse, response)
        return response
      } else {
        cacheResponse.body?.closeQuietly()
      }
    }

    val response = networkResponse!!.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build()

    if (cache != null) {
      if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        val cacheRequest = cache.put(response)
        return cacheWritingResponse(cacheRequest, response)
      }
      
      if (HttpMethod.invalidatesCache(networkRequest.method)) {
        try {
          cache.remove(networkRequest)
        } catch (_: IOException) {
          // The cache cannot be written.
        }
      }
    }

    return response
  }

</code></pre>
<h5 id="request阶段">Request阶段</h5>
<p>可以看到，首先是通过请求的url去缓存中读取，当然取出的缓存对象可能为空。主要方法:</p>
<pre><code class="language-kotlin">   val cacheCandidate = cache?.get(chain.request())
</code></pre>
<p>那么Cache又是什么呢？还记得我们在分析OkHttpClient构造时候的cache参数吗？其实cache是ok内部实现的一个DiskLruCache。是不是很熟悉？也是三级缓存的原理。关于<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>,又是JakeWarton的一大杰作。多提一句，我们在构建client的时候可以通过builder模式设置我们想要缓存的文件夹以及最大缓存，下面放出代码。不过注意加好权限哦。</p>
<pre><code class="language-kotlin">     val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .cache(Cache(Environment.getDownloadCacheDirectory(),10000))
            .build()
</code></pre>
<p>接着是记录当前时间，他与从缓存取出的Response都是构建缓存策略的构造参数。说到缓存策略：</p>
<pre><code class="language-kotlin"> val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
</code></pre>
<p>其实结合http中的缓存原理（见上文连接）就可以很简单的理解了，无非是根据请求参数和本地的缓存是否需要使用本地或者说两者结合。</p>
<p>继续往下面看，根据networkRequest和cacheResponse 的值来判断后续流程。既然他们都是从CacheStrategy中拿到的，那我们先来了解下这两个家伙：</p>
<pre><code class="language-kotlin"> /** The request to send on the network, or null if this call doesn't use the network. */
 val networkRequest: Request?,
 /** The cached response to return or validate; or null if this call doesn't use a cache. */
 val cacheResponse: Response?
</code></pre>
<p>看了注释就非常好理解了，networkRequest在使用缓存的情况下为空，cahceRespoonse在没有使用缓存的情况下为空。<br>
那么两个都为空的情况下就直接返回一个空的响应体，并且设置状态吗为504。</p>
<p>使用缓存情况下，直接就返回缓存中存储的数据，这点在代码里可以体现：</p>
<pre><code class="language-kotlin">// If we don't need the network, we're done.
   if (networkRequest == null) {
     return cacheResponse!!.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .build()
   }
</code></pre>
<p>那么如果我们不适用缓存呢？机智的你肯定会想起来拦截器的机制，没错就是继续通过chain.proceed方法调用下一个拦截器。既然本篇是关于缓存的，我们就继续看一下在使用缓存情况下是怎么处理response的。</p>
<h5 id="response阶段">Response阶段</h5>
<p>如果你看了上面关于HTTP缓存分析的文章，你会知道在http协议中，如果数据没有发生改变那么响应码将会是304。同样ok既然作为一个网络库也是遵守同样的规则的。</p>
<p>在本地缓存不为空情况下，如果服务器返回304，那么ok将会更新header里面的一些参数，更新请求发起时间、响应接收时间等。在此之后返回networkResponse和cacheResponse结合之后的response。</p>
<p>如果用户设置了自定义的缓存目录以及大小并且当前请求是可以被缓存的，那么调用put方法将响应存储到本地磁盘中。但是如果请求的方法是 patch、put、delete、move等不支持缓存的方法，会将缓存从磁盘中清楚。</p>
<h4 id="总结">总结</h4>
<p>以上就是CacheInterceptor的全部分析啦。我们大概类总结一下流程：</p>
<ul>
<li>首先通过请求的url通过DiskLruCache拿到可能存在的响应体</li>
<li>通过请求时间和缓存中的响应体拿到缓存策略</li>
<li>通过策略判断本次请求是直接读取缓存还是请求网络获取</li>
<li>网络请求返回的数据更新到本地缓存中</li>
</ul>
<p>回头来看，其实缓存管理也是按照我们网络协议里面的规则，ok是基于这个规则对其进行了一定的封装。关键部分还是要充分的理解HTTP缓存机制，再次强烈推荐这篇<a href="https://www.cnblogs.com/chenqf/p/6386163.html">文章</a>。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://www.jianshu.com/p/963ad9ca214d">OKhttp源码学习（六）—— CacheInterceptor</a></p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（四）BridgeInterceptor]]></title>
        <id>https://alsowell.github.io//post/okhttp_two</id>
        <link href="https://alsowell.github.io//post/okhttp_two">
        </link>
        <updated>2019-11-22T02:17:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h4 id="前言">前言</h4>
<p>在上一篇文章中我们已经分析过了ok内置五个拦截器中的第一个RetryAndFollowUpInterceptor，本篇我们将继续按照顺序去探究一下BridgeInterceptor。</p>
<h4 id="介绍">介绍</h4>
<p>首先来看一下类注释：</p>
<table><tr><td bgcolor=#f7f6f3>
 Bridges from application code to network code. First it builds a network request from a user
 request. Then it proceeds to call the network. Finally it builds a user response from the network response.
<br></br>
释义：应用层和网络层之间的桥接，首先往用户发起的请求中添加一部分网络层需要的参数，接着调用网络，最后从响应体中解析出用户请求的结果
</td></tr></table>
接着我们直接上代码：
<pre><code class="language-kotlin">  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val userRequest = chain.request()
    val requestBuilder = userRequest.newBuilder()

    val body = userRequest.body
    if (body != null) {
      val contentType = body.contentType()
      if (contentType != null) {
        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())
      }
      val contentLength = body.contentLength()
      if (contentLength != -1L) {
        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())
        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)
      } else {
        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
        requestBuilder.removeHeader(&quot;Content-Length&quot;)
      }
    }
    if (userRequest.header(&quot;Host&quot;) == null) {
      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())
    }

    if (userRequest.header(&quot;Connection&quot;) == null) {
      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)
    }

    // If we add an &quot;Accept-Encoding: gzip&quot; header field we're responsible for also decompressing
    // the transfer stream.
    var transparentGzip = false
    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {
      transparentGzip = true
      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
    }

    val cookies = cookieJar.loadForRequest(userRequest.url)
    if (cookies.isNotEmpty()) {
      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))
    }

    if (userRequest.header(&quot;User-Agent&quot;) == null) {
      requestBuilder.header(&quot;User-Agent&quot;, userAgent)
    }

    val networkResponse = chain.proceed(requestBuilder.build())

    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
    
    val responseBuilder = networkResponse.newBuilder()
        .request(userRequest)
    if (transparentGzip &amp;&amp;
        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase = true) &amp;&amp;
        networkResponse.promisesBody()) {
      val responseBody = networkResponse.body
      if (responseBody != null) {
        val gzipSource = GzipSource(responseBody.source())
        val strippedHeaders = networkResponse.headers.newBuilder()
            .removeAll(&quot;Content-Encoding&quot;)
            .removeAll(&quot;Content-Length&quot;)
            .build()
        responseBuilder.headers(strippedHeaders)
        val contentType = networkResponse.header(&quot;Content-Type&quot;)
        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
      }
    }
    return responseBuilder.build()
  }
</code></pre>
<p>相对于上一篇的重试拦截器，bridge拦截器的代码相对来说是非常容易看懂的。我们将按照interceptor的调用来分为两个阶段分析：</p>
<h4 id="request阶段">Request阶段</h4>
<ul>
<li>
<p>取出body的contentType设置到header里面</p>
</li>
<li>
<p>获取请求体的长度放入header</p>
<ul>
<li>Transfer-Encoding 字面意思也很好理解，即为传输过程中的编码格式<br>
根据网上资料:首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP1.1的传输编码方式仅对分块传输编码有效。值为 chunked 表示请求体的内容大小是未知的。    因此Transfer-Encoding与Content-Length两个首部不能共存。</li>
</ul>
</li>
<li>
<p>将请求的host放入到header里面</p>
<ul>
<li>
<p>Host即对应请求中的域名 对此HttpUrl中有详细的注释解释</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left"><code>host()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>http://android.com/</code></td>
<td style="text-align:left"><code>&quot;android.com&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://127.0.0.1/</code></td>
<td style="text-align:left"><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://[::1]/</code></td>
<td style="text-align:left"><code>&quot;::1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://xn--n3h.net/</code></td>
<td style="text-align:left"><code>&quot;xn--n3h.net&quot;</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>其中toHostHeader()方法会取到对应的域名并且拼接上默认的端口 http默认端口80 、https默认端口443</p>
</li>
</ul>
</li>
<li>
<p>指定连接模式为 Keep-Alive 这样就能方便的复用连接池。</p>
</li>
<li>
<p>如果用户没有设置Accept-Encoding，那么会指定数据接收格式为gzip。顺带提一下：gzip格式压缩能大大减少网络流量的消耗。</p>
</li>
<li>
<p>header中放入cookie</p>
</li>
<li>
<p>请求头中放入 user-agent 如果用户没有设置，那么放入默认 agent:okhttp/x.x.x</p>
</li>
</ul>
<h4 id="response阶段">Response阶段</h4>
<ul>
<li>首先是根据url拿到返回的cookie。</li>
<li>如果Content-Encoding是gzip类型，并且content-length &gt;0 取出body进行处理</li>
<li>对请求响应体做一遍处理，因为响应体的body的传输格式是gzip类型，通过封装的方法类解析处理</li>
<li>解析成为用户真正可使用的body</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上就是整个BridgeInterceptor的全部流程了。大概可以分为三步</p>
<ul>
<li>对用户的请求做一遍处理，如果用户设置了参数使用用户配置，如果未设置那么就使用默认的。</li>
<li>通过chain调用下一个拦截器。</li>
<li>对接口的请求做一遍处理，比如gzip、cookie 最后解析成用户真正可使用的body。</li>
</ul>
<p>可以看到整个BridgeInterceptor的流程还是非常简单的，无非就是对网络传输协议中一些必须参数的封装，这样应用层在调用的时候就省去了这些步骤。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(三) RetryAndFollowUpInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor">
        </link>
        <updated>2019-11-21T12:17:21.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了整个okhttp的核心其实是getResponseWithInterceptor方法。内部是通过一系列的拦截器调用来完成整个网络请求。我们也知道了ok内部定义了五个拦截器。拦截器又是通过责任链模式来递归进行调用。本篇文章我们将按照加载顺序来分析第一个拦截器<strong>RetryAndFollowUpInterceptor</strong></p>
<p>####介绍</p>
<p>按照字面意思来理解就是一个管理重试和后续动作的拦截器，那么究竟是怎么做的呢？简单，上注释！</p>
<pre><code class="language-kotlin">//这个拦截器主要是用来处理失败和重定向的请求，如果请求被取消可能会抛出io异常 
/**
 * This interceptor recovers from failures and follows redirects as necessary. It may throw an
 * [IOException] if the call was canceled.
 */
</code></pre>
<p>看来前面的理解也没有问题，规范的命名确实能让人一看就知道什么意思。那直接进入正文。</p>
<h4 id="核心功能">核心功能</h4>
<ul>
<li>
<p>失败重试</p>
<ul>
<li>在遇到RouteException和IOException通过recover()方法判断当前请求是否可以重新尝试。</li>
</ul>
</li>
<li>
<p>继续发起请求</p>
<ul>
<li>
<p>通过followUpRequest()方法来判断当前是否可以继续发起请求，主要根据响应码来判断</p>
<table>
<thead>
<tr>
<th>应码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>07</td>
<td>代理鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>01</td>
<td>鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>07、308</td>
<td>重定向，method不为get 和head情况下 ，重新发起新的请求</td>
</tr>
<tr>
<td>00、301、302、303</td>
<td>重定向，重新发起新的请求</td>
</tr>
<tr>
<td>08</td>
<td>客户端请求超时，会继续发起新的请求</td>
</tr>
<tr>
<td>03</td>
<td>服务不可用，会继续发起新的请求</td>
</tr>
<tr>
<td>lse</td>
<td>直接发起新的请求</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：请求重试次数是受到MAX_FOLLOW_UPS 限制的，默认是20</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>经过前面文章的分析我们知道每一个拦截器都是在intercept里面操作的，那我们直接来分析一下：</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()
    //1
    val realChain = chain as RealInterceptorChain
    val transmitter = realChain.transmitter()
    var followUpCount = 0
    var priorResponse: Response? = null
    while (true) {
      //2
      transmitter.prepareToConnect(request)
      if (transmitter.isCanceled) {
        throw IOException(&quot;Canceled&quot;)
      }
      var response: Response
      var success = false
      try {
        //3
        response = realChain.proceed(request, transmitter, null)
        success = true
      } catch (e: RouteException) {
        // The attempt to connect via a route failed. The request will not have been sent.
        if (!recover(e.lastConnectException, transmitter, false, request)) {
          throw e.firstConnectException
        }
        continue
        //4
      } catch (e: IOException) {
        // An attempt to communicate with a server failed. The request may have been sent.
        val requestSendStarted = e !is ConnectionShutdownException
        if (!recover(e, transmitter, requestSendStarted, request)) throw e
        continue
      } finally {
        // The network call threw an exception. Release any resources.
        if (!success) {
          transmitter.exchangeDoneDueToException()
        }
      }
      // Attach the prior response if it exists. Such responses never have a body.
      if (priorResponse != null) {
        response = response.newBuilder()
            .priorResponse(priorResponse.newBuilder()
                .body(null)
                .build())
            .build()
      }
      val exchange = response.exchange
      val route = exchange?.connection()?.route()
      //5
      val followUp = followUpRequest(response, route)
      if (followUp == null) {
        if (exchange != null &amp;&amp; exchange.isDuplex) {
          transmitter.timeoutEarlyExit()
        }
        return response
      }
      val followUpBody = followUp.body
      //6
      if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {
        return response
      }
      response.body?.closeQuietly()
      if (transmitter.hasExchange()) {
        exchange?.detachWithViolence()
      }
      //7
      if (++followUpCount &gt; MAX_FOLLOW_UPS) {
        throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)
      }
      request = followUp
      priorResponse = response
    }
  }
</code></pre>
<h4 id="主要步骤">主要步骤</h4>
<ul>
<li>
<p>在上一篇文章中我们分析过，拦截器会通过构造RealInterceptorChain对象，并且把其作为参数通过调用当前interceptor的intercept方法来进行递归调用。并且也知道可以通过chain来获取到request、connection等对象。同样在重试拦截器中也是一样。第一步首先是拿到request 、realChain、transmitter对象。</p>
</li>
<li>
<p>进入到while循环中，首先调用transmitter的prepareToConnect方法。我们跟进去看一下：</p>
<pre><code class="language-kotlin">fun prepareToConnect(request: Request) {
    if (this.request != null) {
      if (this.request!!.url.canReuseConnectionFor(request.url) &amp;&amp; exchangeFinder!!.hasRouteToTry()) {
        return // Already ready.
      }
      check(exchange == null)
      if (exchangeFinder != null) {
        maybeReleaseConnection(null, true)
        exchangeFinder = null
      }
    }
    this.request = request
    this.exchangeFinder = ExchangeFinder(
        this, connectionPool, createAddress(request.url), call, eventListener)
  }
</code></pre>
<ul>
<li>不是第一次进入这个方法的时候
<ul>
<li>首先会判断是否可以服用连接池并且仍然处于重试过程中。</li>
<li>如果exchangeFinder不为空情况下 尝试关闭连接。并且回调eventListener connectionReleased方法，接着根据请求是否失败回调callFailed或者callEnd</li>
</ul>
</li>
<li>首次进入情况下
<ul>
<li>构建出exchangeFinder对象，为后续的网络连接做准备</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断请求是否被取消，如果取消抛出异常。</p>
<ul>
<li>
<pre><code class="language-kotlin">  fun cancel() {
    val exchangeToCancel: Exchange?
    val connectionToCancel: RealConnection?
    synchronized(connectionPool) {
      canceled = true
      exchangeToCancel = exchange
      connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
    }
    exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
  }
</code></pre>
</li>
</ul>
<p>通过调用链我们可以发现，这个方法只会在应用层通过Call对象的cancel方法调用到。</p>
</li>
<li>
<p>调用realChain的proceed方法</p>
<ul>
<li>
<p>还记得我们在上一篇文章中分析过这个方法其实是递归调用后续的拦截器并且将下一级的结果返回到当前处理。</p>
</li>
<li>
<p>通过try-catch 捕获在网络请求过程中可能出现的异常，如果未发生异常success为true，反之为false。</p>
<ul>
<li>
<p>RouteException</p>
<ul>
<li>异常发生在请求还没发出之前，追溯源码会发现其实是发生在connect过程中。</li>
</ul>
</li>
<li>
<p>IOException</p>
<ul>
<li>异常发生请求可能已经发出，并且在读取服务端的响应过程中出错。</li>
</ul>
</li>
<li>
<p>通过recover方法判断是否是值得重试的异常，判断依据如下：</p>
<pre><code class="language-kotlin"> private fun recover(
    e: IOException,
    transmitter: Transmitter,
    requestSendStarted: Boolean,
    userRequest: Request
  ): Boolean {
    // The application layer has forbidden retries.
    if (!client.retryOnConnectionFailure) return false
    // We can't send the request body again.
    if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false
    // This exception is fatal.
    if (!isRecoverable(e, requestSendStarted)) return false
    // No more routes to attempt.
    if (!transmitter.canRetry()) return false
    // For failure recovery, use the same route selector with a new connection.
    return true
  }
</code></pre>
<ul>
<li>
<p>应用层设置失败是否重试</p>
<figure data-type="image" tabindex="1"><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/WechatIMG133355.tiff" alt=""></figure>
</li>
<li>
<p>是否有相同的请求正在执行</p>
</li>
<li>
<p>是否是可恢复的异常</p>
</li>
<li>
<pre><code class="language-kotlin">private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean {
    if (e is ProtocolException) {
      return false
    }
    if (e is InterruptedIOException) {
      return e is SocketTimeoutException &amp;&amp; !requestSendStarted
    }
    if (e is SSLHandshakeException) {
      if (e.cause is CertificateException) {
        return false
      }
    }
    if (e is SSLPeerUnverifiedException) {
      return false
    }
    return true
  }
</code></pre>
<ul>
<li>
<p>ProtocolException 协议异常</p>
<p><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/1574337835415.jpg" alt="">主要发生在 RealConnection 中创建 HTTPS 通过 HTTP 代理进行连接重试超过 21 次。</p>
</li>
</ul>
</li>
<li>
<p>InterruptedIOException</p>
<ul>
<li>io终端异常，但是如果当前是一个连接超时异常，会进入到后续的判断，即根据响应码判断是否可重试。</li>
</ul>
</li>
<li>
<p>SSLHandshakeException</p>
<ul>
<li>https握手失败异常，不可重试。</li>
</ul>
</li>
<li>
<p>SSLPeerUnverifiedException</p>
<ul>
<li>网站的证书是不可信任的异常，不可重试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>是否已经失败过并且具有可以重试的route</p>
</li>
<li>
<p>如果请求未成功那么释放在上一次请求过程中的所有资源</p>
</li>
<li>
<p>从response中获取到 exchange、route对象。</p>
</li>
<li>
<p>调用followUpRequest方法 根据上次请求的返回码来确定是否需要重新尝试，关于响应码的分析在文章开头已经介绍过。</p>
</li>
<li>
<p>自增记录重试次数并且判断是否超过默认值</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>经过上面的分析我们可以知道：重试拦截器其实内部的逻辑还是有点小复杂的，首先定义了每个请求的最大默认尝试次数。然后在请求没有获取到响应时通过异常类型来判断是否可以继续重试。在获取到响应体阶段则是通过状态吗来判断。这里是不是更好理解：okhttp每个拦截器都是分为了Request阶段和Response阶段。到这里，我们对RetryAndFollowUpInterceptor的分析就告一段落了，下一章将会分析BridgeInterceptor。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5aa23fa46fb9a028cb2d3a96">源码分析三：OkHttp—RetryAndFollowUpInterceptor</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(二)getResponseWithInterceptorChain]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain">
        </link>
        <updated>2019-11-21T03:18:33.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>上一篇文章中我们简单的总结了ok发起请求并接收响应的整个流程，我们发现关键步骤是getResponseWithInterceptorChain这个方法。那这里面又做了什么事情呢？还是首先来看一下代码：</p>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  fun getResponseWithInterceptorChain(): Response {
    // Build a full stack of interceptors.
    val interceptors = mutableListOf&lt;Interceptor&gt;()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)

    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)

    var calledNoMoreExchanges = false
    try {
      val response = chain.proceed(originalRequest)
      if (transmitter.isCanceled) {
        response.closeQuietly()
        throw IOException(&quot;Canceled&quot;)
      }
      return response
    } catch (e: IOException) {
      calledNoMoreExchanges = true
      throw transmitter.noMoreExchanges(e) as Throwable
    } finally {
      if (!calledNoMoreExchanges) {
        transmitter.noMoreExchanges(null)
      }
    }
  }
</code></pre>
<p>可以说这个方法是整个okhttp的核心，通过这么几行代码就实现了整个请求的过程。这里不得不提到ok的拦截器机制。大多数人说到okhttp优秀的地方基本上都会脱口而出通过设置拦截器可以很方便的实现网络请求的打印、添加一些公共参数等等。而拦截器真正的运行其实就是在这个方法中。</p>
<ul>
<li>首先在interceptors中添加用户自定义的拦截器</li>
<li>然后按顺序添加各种系统内置的拦截器</li>
<li>通过RealInterceptorChain方法获取一个chain对象</li>
<li>通过chain.proceed获取response</li>
</ul>
<h4 id="拦截器">拦截器</h4>
<p>说了这么久的拦截器，肯定会好奇它究竟是个什么妖魔鬼怪：</p>
<pre><code class="language-kotlin">/**
 * Observes, modifies, and potentially short-circuits requests going out and the corresponding
 * responses coming back in. Typically interceptors add, remove, or transform headers on the request
 * or response.
 */
interface Interceptor {
  @Throws(IOException::class)
  fun intercept(chain: Chain): Response

  companion object {
    inline operator fun invoke(crossinline block: (chain: Chain) -&gt; Response): Interceptor =
        object : Interceptor {
          override fun intercept(chain: Chain) = block(chain)
        }
  }
  interface Chain {
    fun request(): Request

    @Throws(IOException::class)
    fun proceed(request: Request): Response
    fun connection(): Connection?
    fun call(): Call
    fun connectTimeoutMillis(): Int
    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
    fun readTimeoutMillis(): Int
    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
    fun writeTimeoutMillis(): Int
    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
  }
}

</code></pre>
<p>Interceptor实际上是一个接口，里面定义了一个intercept方法和chain的接口类。</p>
<h5 id="intercept">intercept</h5>
<p>关于intercept方法是不是很熟悉？我们在自定义拦截器的时候往往都是在这里面做一些瞎操作。</p>
<pre><code class="language-kotlin">   override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val realInterceptorChain = chain as RealInterceptorChain
        val transmitter = realInterceptorChain.transmitter()
        val response = realInterceptorChain.proceed(request, transmitter, null)
        return response

    }
</code></pre>
<ul>
<li>这里首先是通过chain.request获取请求的request对象</li>
<li>通过chain.proceed 递归调用下一个拦截器的intercept方法</li>
<li>最终返回chain.proceed的response到上一级拦截器</li>
</ul>
<h5 id="分层">分层</h5>
<p>这里其实是将每个拦截器分为了两个阶段：</p>
<ul>
<li>Request阶段：执行该拦截器在请求前做的事，例如：bridgeInterceptor添加一些请求参数</li>
<li>Response阶段：执行拦截器在获取响应之后做的事，例如：打印出请求体的返回</li>
</ul>
<p>拦截器的设计其实是采用了递归调用的思想，仔细想想其实是非常巧妙的，这样可以保证不论是系统内置还是用户自定义的拦截器都可以得到最终执行。如果在某个拦截器中出现了错误，还可以把错误抛给上一层来处理。</p>
<h5 id="内置拦截器">内置拦截器</h5>
<p>通过剖析源码我们会发现,ok内部其实是帮我们内置了好几种拦截器，每次请求都会添加进去，我们按照添加顺序整理如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截器</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RetryAndFollowUpInterceptor</td>
<td style="text-align:center">负责实现重定向功能</td>
</tr>
<tr>
<td style="text-align:center">BridgeInterceptor</td>
<td style="text-align:center">将用户构造的请求转换为向服务器发送的请求，将服务器返回的响应转换为对用户友好的响应</td>
</tr>
<tr>
<td style="text-align:center">CacheInterceptor</td>
<td style="text-align:center">读取缓存、更新缓存</td>
</tr>
<tr>
<td style="text-align:center">ConnectInterceptor</td>
<td style="text-align:center">建立与服务器的连接</td>
</tr>
<tr>
<td style="text-align:center">CallServerInterceptor</td>
<td style="text-align:center">从服务器读取响应</td>
</tr>
</tbody>
</table>
<p>可以看出，整个网络请求的过程是通过各个拦截器相互配合来实现，假如我们在网络请求过程中设置允许缓存，那么在请求网络之前会预先获取缓存，然后再去跟服务器建立连接。通过拦截器的机制，我们可以很方便的控制整个网络请求的过程以及添加我们自己的拓展。</p>
<p>整个网络请求过程中，用户其实是可以添加两种不同类型的拦截器的。</p>
<ul>
<li>通过 addInterceptor()在网络请求前后添加拦截器</li>
<li>通过networkInterceptors()在获取响应前后添加拦截器</li>
</ul>
<p>这一点在getResponseWithInterceptorChain（）方法中添加拦截器的顺序是可以分析出来的。</p>
<h5 id="整体流程">整体流程</h5>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/21/16e8bf6522fc07a5?w=1064&amp;h=1004&amp;f=jpeg&amp;s=89681" alt=""><br>
图片来源:https://blog.n0texpecterr0r.cn/?p=717</p>
<h4 id="realinterceptorchain">RealInterceptorChain</h4>
<p>经过上面的分析我们知道okhttp的实际请求和响应过程是通过一个个拦截器的递归调用来实现的。主要方法就是</p>
<p>realInterceptorChain.proceed。我们先来看一下RealInterceptorChain的构造方法</p>
<pre><code class="language-kotlin">class RealInterceptorChain(
  private val interceptors: List&lt;Interceptor&gt;,
  private val transmitter: Transmitter,
  private val exchange: Exchange?,
  private val index: Int,
  private val request: Request,
  private val call: Call,
  private val connectTimeout: Int,
  private val readTimeout: Int,
  private val writeTimeout: Int
) 
</code></pre>
<p>这里其实是将上一个拦截器的一些参数传递进来并且赋值的简单实现。包括所有的拦截器、以及我们在第一篇文章提到的transmitter等。整个类中最关键的还是proceed方法</p>
<pre><code class="language-kotlin">  @Throws(IOException::class)
  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
    if (index &gt;= interceptors.size) throw AssertionError()
    calls++
    // If we already have a stream, confirm that the incoming request will use it.
    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
      &quot;network interceptor ${interceptors[index - 1]} must retain the same host and port&quot;
    }
    // If we already have a stream, confirm that this is the only call to chain.proceed().
    check(this.exchange == null || calls &lt;= 1) {
      &quot;network interceptor ${interceptors[index - 1]} must call proceed() exactly once&quot;
    }
    // Call the next interceptor in the chain.
    val next = RealInterceptorChain(interceptors, transmitter, exchange,
        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
    val interceptor = interceptors[index]
    @Suppress(&quot;USELESS_ELVIS&quot;)
    val response = interceptor.intercept(next) ?: throw NullPointerException(
        &quot;interceptor $interceptor returned null&quot;)
    // Confirm that the next interceptor made its required call to chain.proceed().
    check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) {
      &quot;network interceptor $interceptor must call proceed() exactly once&quot;
    }
    check(response.body != null) { &quot;interceptor $interceptor returned a response with no body&quot; }
    return response
  }
</code></pre>
<p>可以看到这个方法中除了大量的判读逻辑，比较关键的就是通过index+1取到下一个RealInterceptorChain对象 。</p>
<p>然后获取当前的拦截器并且调用其intercept方法 ，方法参数中传入了下一个拦截器的对应的chain。就是这样通过递归调用的设计，实现了由上而下，再由下而上实现了递与归的过程。从而非常漂亮的实现了http请求的全链路。</p>
<p>看到这里有没有觉得这种设计模式很熟悉，没错就是责任链模式。这种设计模式在一个流程会有多种操作的业务场景下会非常实用。</p>
<h4 id="总结">总结</h4>
<p>本篇文章我们主要是分析了整个网络请求过程中非常重要的getResponseWithInterceptorChain()方法，内部通过责任链的模式递归调用用户自定义拦截器和内置拦截器来完成整个网络请求。通过对整个方法的分析，我们会更清晰的知道ok内部是怎么实现通过设置拦截器来完成我们想要的功能的。同时也是我们学习责任链模式非常好的实践。后续文章将逐个分析ok内置拦截器的具体作用。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://blog.n0texpecterr0r.cn/?p=717">OkHttp 源码剖析系列（一）——请求的发起及拦截器机制概述</a></p>
]]></content>
    </entry>
</feed>