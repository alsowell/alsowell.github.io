<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-12-05T13:44:53.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[面试官问：volatile和synchronized都介绍下，他们之间有什么 不同呢？]]></title>
        <id>https://alsowell.github.io//post/mian-shi-guan-wen-xi-lie</id>
        <link href="https://alsowell.github.io//post/mian-shi-guan-wen-xi-lie">
        </link>
        <updated>2019-12-01T08:54:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="知道volatile与synchronized的区别吗">知道volatile与synchronized的区别吗？</h4>
<ul>
<li>分析文章: <a href="https://juejin.im/post/5ae134e76fb9a07acb3c8ea7">volatile与synchronized的区别</a><br><br>
<a href="https://www.hollischuang.com/archives/2648">深入理解Java中的volatile关键字</a></li>
<li>概述:
<ul>
<li>
<p>volatile修饰的变量遵守<code>缓存一致性</code>。</p>
<ul>
<li>可见性
<ul>
<li>某个线程修改过这个值，其值都会被强制刷新到主内存。保证了被<code>volatile</code>修饰过的变量在并发编程中在多个缓存中是可见的。</li>
</ul>
</li>
<li>有序性
<ul>
<li>即指程序执行的顺序按照代码的先后顺序执行
<ul>
<li>sample:由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</li>
<li>但是<code>volatile</code>除了可以保证数据的有序性之外，可以进制指令重排优化。</li>
</ul>
</li>
</ul>
</li>
<li>原子性
<ul>
<li>原子性是指一个操作是不可中断的，要么全部执行完成。
<ul>
<li>线程是cpu调度的基本单位，CPU有时间片的概念，会按照不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</li>
</ul>
</li>
<li><code>volatile</code>是不能保证原子性的。</li>
<li>使用<code>volatile</code>的场景
<ul>
<li>运算结果并不一依赖变量的当前值，或者能过确保只有单一的线程会修改变量的值</li>
<li>变量不需要与其他状态变量共同参与不变约束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>synchronized</p>
<ul>
<li>synchonized 可以保证 可见性、有序性、原子性。<code>volatile</code>只能保证可见性、有序性 无法保证原子性。</li>
<li><code>synchronized</code>是无法进制指令重排和处理器优化的。
<ul>
<li>Java程序中的天然有序性可以总结为一句话：在本线程内观察，所有操作都是有序性的。在另外一个线程观察其他线程，所有的操作都是无顺序的。
<ul>
<li><code>synchronized</code>的有序性是多个线程之间的有序性，即加锁的方法需要按照多个线程的调用顺序执行。但是内部的同步代码还是需要被指令优化并且可能发生重排。</li>
</ul>
</li>
</ul>
</li>
<li>主要有两种用法：同步方法和同步代码块
<ul>
<li>同步方法:被其修饰的方法，在同一时间只能被单个线程访问</li>
<li>同步代码块:可以减少锁的粒度
<ul>
<li>sample：如果一个方法被<code>synchronized</code>修饰，内部有一个长时间执行的任务，A线程调用方法，那么B线程必须等待很久的时间去才去执行。</li>
<li>关于同步代码块this方法。<code>synchronized</code>可以使用任意对象来标记同步，但是如果一个类中很多个<code>synchronized</code>方法。都是使用this来作为锁，那么就会造成阻塞。一个类中如果有多个同步代码块方法，一般使用不同的对象来作为锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>思考问题：为什么有了<code>synchronized</code>之后还要有<code>volatile</code>这个关键字？</p>
<ul>
<li>产生损耗
<ul>
<li>使用<code>synchronized</code>会有性能损耗，无论是同步方法还是同步代码块，都会有加锁，解锁的操作。此过程会有性能损耗的。</li>
</ul>
</li>
<li>产生阻塞
<ul>
<li><code>syncronized</code>在多线程访问场景下，某个线程访问时候会阻塞其他线程等待此线程执行完毕。而<code>volatile</code>是jvm提供的轻量级线程同步机制，其不会产生阻塞和性能损耗相当于基本对象赋值。</li>
</ul>
</li>
<li><code>volatile</code>可以避免指令重新排序是其附加有点。以<strong>单例的双重检查</strong>举例</li>
</ul>
<pre><code class="language-java">public class Singleton{
    private volatile static Singleton singleton;
    private Singleton {}
    public static Singleton getSingleton(){
        if(singleton==null){
            synchronized(Singleton.class){
                if(singleton==null){
                    singleton=new Singleton();
                }
            }
        }
        return singleton;
    }
}
</code></pre>
<ul>
<li>说明：如果仅仅使用<code>synchronized</code>，那么假如两个线程A、B同时访问此方法获取单例，A线程访问此时singleton为null开始进行初始化，此时还没有进行初始化完成。此时B线程开始访问，进入判断singleton==null 可能返回false。那么B线程拿到的线程就可能是一个空对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：EventBus源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-28T10:04:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>EventBus对于Android开发着来讲可以说是再熟悉不过了。不管是最开始的mvc模式还是现在的组件化开发模式，EventBus一直没有没落下去，今天我们就来详细分析一下EventBus的内部原理。</p>
<h4 id="介绍">介绍</h4>
<p>官方介绍中，EventBus是一个Android或者Java可以使用的基于发布、订阅的框架。这里放上官方的流程图:<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/27/16eacfa9e88928f9?w=1280&amp;h=479&amp;f=png&amp;s=28898" alt=""><br>
通过流程图可以发现，EventBus的整体使用的是非常的简单，发布者post一个事件，所有消费者监听到之后消费。这就是一点典型的观察者模式的设计模式。</p>
<table><tr><td bgcolor="#f7f6f3">
观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
</td></tr></table>
<h4 id="上手使用">上手使用</h4>
<p>跟之前一样，我们还是先从使用开始，其实这步好像可以省略。大家对EventBus的使用应该非常熟悉，但是流程还是要走一下的。<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb12aa3c70c7fa?w=1572&amp;h=616&amp;f=jpeg&amp;s=70991" alt=""><br>
在<code>onStart()</code>方法中注册，<code>onStop()</code>中销毁。再来定义一个event,在<code>onResume</code>中发送，并且直接注册一个观察者来接受这个event。</p>
<pre><code class="language-kotlin">    @Subscribe(threadMode = ThreadMode.MAIN)
    fun onReceiveEvent(event: TestEvent) {
        Log.d(&quot;EventBus&quot;, &quot;receive event&quot;)
    }
</code></pre>
<p>运行上面这段代码可以在控制台看到输出:</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb13094fde6dc4?w=1142&amp;h=64&amp;f=jpeg&amp;s=16319" alt=""><br>
可以看到EventBus整个的使用流程是非常简单的，当然也可以在发送事件的时候携带参数，直接在event类中定义就ok。下面我们将详细分析一下EventBus的内部流程。</p>
<h4 id="源码探究">源码探究</h4>
<p>还是老规矩，我们将按照使用流程来一点点剥开它的外壳，发现它的内部纹路。</p>
<h5 id="获取eventbus">获取EventBus</h5>
<p>EventBus在构造方法执行的时候会通过<code>builder</code>模式来设置一些常用参数，先来看一下这些设置：</p>
<pre><code class="language-java">    EventBus(EventBusBuilder builder) {
        //log打印器
        logger = builder.getLogger();
        //Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType
        //以event为key,订阅列表为value，是一个线程安全的容器
        subscriptionsByEventType = new HashMap&lt;&gt;();
        //Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;
        //订阅者为key,event为value的容器 
        typesBySubscriber = new HashMap&lt;&gt;();
        //粘性事件的容器
        stickyEvents = new ConcurrentHashMap&lt;&gt;();
        //是否支持主线程
        mainThreadSupport = builder.getMainThreadSupport();
        //如果支持主线程，构建出来一个主线程发射器
        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
        //初始化BackgroundPoster
        backgroundPoster = new BackgroundPoster(this);
        //初始化AsyncPoster
        asyncPoster = new AsyncPoster(this);
        //是否有编译期已经生成的索引类，关于索引将会在列表中放出解析文章链接
        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
        //初始化注册时间寻找器，具体将在后续分析
        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                builder.strictMethodVerification, builder.ignoreGeneratedIndex);
        //是否打印出订阅异常
        logSubscriberExceptions = builder.logSubscriberExceptions;
        logNoSubscriberMessages = builder.logNoSubscriberMessages;
        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
        throwSubscriberException = builder.throwSubscriberException;
        eventInheritance = builder.eventInheritance;
        //当接收模式为backGroud和async时的线程调度器，默认为缓存线程池
        executorService = builder.executorService;
    }
</code></pre>
<p>当然如果我们在使用的时候也可以自定义配置。配置方式如下:</p>
<pre><code class="language-java">EventBus eventBus = EventBus.builder()
    .logNoSubscriberMessages(false)
    .sendNoSubscriberEvent(false)
    .build();
</code></pre>
<p>分析过构造方法之后再来看一下<code>getDefault()</code>:</p>
<pre><code class="language-java">    public static EventBus getDefault() {
        if (defaultInstance == null) {
            synchronized (EventBus.class) {
                if (defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }
        return defaultInstance;
    }
</code></pre>
<p>可以看到这里是使用了单例模式的<strong>双重检查模式</strong>,关于单例模式的多种不同写法可以<a href="https://blog.csdn.net/itachi85/article/details/50510124">参考</a>。只有第一次使用的时候才会初始化，最大限度的保证了资源的利用效率。</p>
<h4 id="注册">注册</h4>
<p>要想通过EventBus来观察被观察者，首先是需要注册，来告诉程序你需要观察某个对象的改变。我们来看一下<code>register</code>是做了什么事情。</p>
<pre><code class="language-java">    将给定的对象注册用来接收event，当不在需要观察event的变化时，必须调用unregister。
    同时，注册的对象内部必须有Subscribe注解的方法。
    public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>可以看到会通过<code>subscriberMethodFinder</code>当前对象注册的所有事件监听的方法，然后通过<code>subscribe()</code>方法来将注册的所有监听都添加到监听列表中。来分析下具体方法；</p>
<h6 id="findsubscribermethods">findSubscriberMethods</h6>
<p>根据方法名就可以很方便的理解，根据传入的观察者对象去寻找其内部定义的全部观察方法。首先根据<code>METHOD_CACHE.get(subscriberClass);</code>去获取到之前可能已经缓存的全部订阅方法。如果之前已经获取过那么直接返回，前面有提到过EventBus是全局单例，所以就很好理解了。如果缓存没有就需要重新去获取。</p>
<p>接着会根据build期间设置的是否忽略索引来获取，前文也有提到EventBus在编译期会提前生成索引，那么索引是怎么生成的呢？</p>
<table><tr>
<td bgcolor="#f7f6f3">
在3.0版本中，EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解，并解析和处理其中所包含的信息，然后生成java类来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。<br>
此处为引用
</td>
</tr></table>
<p>如果观察者内部并没有定义<code>@Subscribe</code>注解的方法会抛出异常。</p>
<p>通过<code>findSubscriberMethods</code>方法我们已经找到了观察者内部定义的全部标有<code>@Subscribe</code>的方法。接着就是在线程同步锁中调用<code>subcribe</code>方法。</p>
<h5 id="subscribe">subscribe</h5>
<p>前文已经拿到了当前订阅的事件类型，这里会根据<code>eventType</code>放入上文提到的<code>subscriptionsByEventType</code>线程安全的map中,当然会有一些安全检查。接着会根据注册时定义的优先级对订阅同一个事件的观察者进行排序。</p>
<p>紧接着将当前观察者中所有的订阅方法添加进以<code>subscriber</code>为key的map中。</p>
<p>最后是对粘性事件的处理,与<code>StickyBroadcast</code>是同一个概念。EventBus在定义订阅方法时，除了可以指定接收的线程之外还设有另外两个参数可以设定：</p>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Subscribe {
    //接收的线程
    ThreadMode threadMode() default ThreadMode.POSTING;
    //是否是粘性事件
    boolean sticky() default false;
    //事件优先级
    int priority() default 0;
}

</code></pre>
<p>继续看是怎么处理粘性事件的注册,直接判断当前注册进来的粘性事件是否存储在本地的<code>stickyEvents</code>。如果匹配上那么就会最终调用<code>postToSubscription()</code>方法。</p>
<h4 id="发送事件">发送事件</h4>
<p>EventBus的事件发送其实是非常简单的。我们来看一下:</p>
<ul>
<li>普通事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().post(TestEvent())
</code></pre>
<ul>
<li>粘性事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().postSticky(TestEvent())
</code></pre>
<h5 id="post方法">post方法</h5>
<pre><code class="language-java">   public void post(Object event) {
        PostingThreadState postingState = currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue = postingState.eventQueue;
        eventQueue.add(event);

        if (!postingState.isPosting) {
            postingState.isMainThread = isMainThread();
            postingState.isPosting = true;
            if (postingState.canceled) {
                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
            }
            try {
                while (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(0), postingState);
                }
            } finally {
                postingState.isPosting = false;
                postingState.isMainThread = false;
            }
        }
    }
</code></pre>
<ul>
<li>首先会从<code>currentPostingThreadState</code>中取出发送线程的状态机。<code>currentPostingThreadState</code>其实是一个<code>ThreadLocal</code>，关于<code>ThreadLocal</code>推荐一篇文章:<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a>。</li>
<li></li>
<li>拿到状态机中的事件队列</li>
<li>将事件添加到事件队列中</li>
<li>判断当前发送线程没有堆积任务正在处理才进入到发送逻辑</li>
<li>while循环中不断的从队列中取出第一个任务，调用<code>postSingleEvent</code>进行发送</li>
</ul>
<h5 id="postsingleevent方法">postSingleEvent方法</h5>
<p>上面说到，post方法实际上是将event添加到队列中，然后通过不断的从队列中取出第一个来进行处理。</p>
<pre><code class="language-java">   private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
        Class&lt;?&gt; eventClass = event.getClass();
        boolean subscriptionFound = false;
        if (eventInheritance) {
            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
            int countTypes = eventTypes.size();
            for (int h = 0; h &lt; countTypes; h++) {
                Class&lt;?&gt; clazz = eventTypes.get(h);
                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
        }
        if (!subscriptionFound) {
            if (logNoSubscriberMessages) {
                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);
            }
            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                    eventClass != SubscriberExceptionEvent.class) {
                post(new NoSubscriberEvent(this, event));
            }
        }
    }
</code></pre>
<p>对这个方法进行一个简单的总结:</p>
<ul>
<li>获取到发送的事件类型</li>
<li>调用<code>lookupAllEventTypes</code>方法从缓存中或者通过立即获取方式取到所有注册了此种事件类型的观察者们，包括被继承的类也会被找出来</li>
<li>调用<code>postSingleEventForEventType</code>来将事件发送</li>
</ul>
<p>postSingleEventForEventType实际上从本地缓存中取到对象中后还是调用我们上文分析粘性事件时最终调用的<code>postToSubscription</code>方法。</p>
<h5 id="posttosubscription-方法">postToSubscription 方法</h5>
<pre><code class="language-java">    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case MAIN_ORDERED:
                if (mainThreadPoster != null) {
                    mainThreadPoster.enqueue(subscription, event);
                } else {
                    // temporary: technically not correct as poster not decoupled from subscriber
                    invokeSubscriber(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
        }
    }
</code></pre>
<p>可以说这个方法是观察者接收事件时绝对会调用的方法。可以看到根据threadMode是区分了不同的逻辑，那threadMode是干嘛的呢？</p>
<pre><code class="language-java">//定义用来表示EventBus的方法在哪个线程被调用的枚举类
public enum ThreadMode {
    //与post方是在同一个线程
    POSTING,
    //直接在主线程中调用这个方法
    MAIN,
    //同样也是在主线程中调用 ，但是与Main有区别的地方在于它是通过队列来进行的，不是直接调用
    MAIN_ORDERED,
    //Android上将会在异步线程调用subscribler的方法，如果本身post方不是主线程，那么会直接在当前线程执行，跟`post`类似。如果是在主线程post，那么会直接在一个新的异步线程执行。
    BACKGROUND,
    //这个模式下，总是在一个单独的线程执行，不会在post线程以及主线程。可以用来执行一些耗时任务。内部是采用线程池来做线程的复用
    ASYNC
}
</code></pre>
<p>分析到这里也就差不多可以理解<code>postToSubscription</code>是按照方法注解中定义的<code>ThreadMode</code>来进行观察者接收事件的线程调度管理。不轮其是直接调用方法还是放入队列中进行管理最终都是通过反射在当前线程对方法进行调用。</p>
<h5 id="poststicky方法">postSticky方法</h5>
<pre><code class="language-java">  public void postSticky(Object event) {
        synchronized (stickyEvents) {
            stickyEvents.put(event.getClass(), event);
        }
        // Should be posted after it is putted, in case the subscriber wants to remove immediately
        post(event);
    }
</code></pre>
<p>可以看到<code>postSticky</code>内部逻辑也是非常简单，就是将event注册为粘性事件存放入本地缓存。后续逻辑与正常事件的发送一样。</p>
<h4 id="取消注册">取消注册</h4>
<p>分析完了注册和发送，我们必须要来讲一下反注册。我们平常在activity中使用广播的时候有注册，那么在activity销毁的时候一定要记得进行反注册，不然就会引起内存泄漏。同样的道理，假如我们某个观察者类在销毁的时候没有从eventBus中进行取消注册。eventBus全局单例就一直会持有当前观察者的引用，从而造成了内存泄漏。</p>
<pre><code class="language-java">    public synchronized void unregister(Object subscriber) {
        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);
        if (subscribedTypes != null) {
            for (Class&lt;?&gt; eventType : subscribedTypes) {
                unsubscribeByEventType(subscriber, eventType);
            }
            typesBySubscriber.remove(subscriber);
        } else {
            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
        }
    }
</code></pre>
<p>可以看到，取消注册的逻辑其实是非常简单的，无非是将要取消注册的观察者对象从本地缓存中和相关的map中都统一移除。</p>
<h4 id="总结">总结</h4>
<p>写到这里，基本上<code>EventBus</code>整个使用流程的代码分析都已完成，我们来大概总结一下：</p>
<ul>
<li>EventBus核心是使用观察者模式</li>
<li>通过builder模式设置参数，一般情况下使用默认</li>
<li>EventBus是使用<strong>双重检查模式</strong>的全局单例</li>
<li>注册时通过索引或者反射来获取订阅者中的所有订阅方法，粘性事件注册时会根据本地粘性事件map是否存在当前注册进来需要监听的订阅类型来决定要不要发送一次。</li>
<li>发送时根据事件类型等从本地在注册时就已经换成的对象进行发送，发送有接收线程、优先级以及是否粘性事件的区分。最终都是通过反射调用方法来进行通知的</li>
<li>取消注册，将订阅者对象从EventBus类的相关缓存中移除</li>
</ul>
<p>以上就是EventBus整体的大概流程分析，大概还是会有很多语意不明或者逻辑漏洞的地方，希望大家指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://blog.csdn.net/a553181867/article/details/52531479">EventBus 3.0进阶：源码及其设计模式 完全解析</a><br><br>
<a href="https://blog.csdn.net/qq_19431333/article/details/81173432">EventBus配置、粘性事件、优先级和取消事件分发</a><br><br>
<a href="https://www.jianshu.com/p/ed417a9cd7d6">EventBus3.0新特性之Subscriber Index</a><br><br>
<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:Retrofit源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-26T08:17:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>之前的文章，我们分析了okhttp一个网络请求的一些关键的步骤。今天会再来分析一下基本相当于其孪生兄弟的存在<strong>Retrofit</strong>。他们都是<strong>square</strong>公司出品的Android常用开发框架。那么关于<strong>Retrofit</strong>很多人其实都说是一个网络请求框架，类似于okhttp。那么它真的是这样的吗？我们今天就来看一下:</p>
<h4 id="使用retrofit进行一次网络请求">使用Retrofit进行一次网络请求</h4>
<p>既然是开发框架，按照规矩当然是首先会使用啦。关于使用文档，官方提供了<a href="https://square.github.io/retrofit/">github.io页面</a>。既然官方提供了示例，我们按照说明来操作一下，这是获取github某个用户repo的示例。</p>
<h5 id="api定义">API定义</h5>
<p>retrofit的使用首先要定义一个接口来说明需要请求的接口:</p>
<pre><code class="language-java">public interface GithubService {
    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
    
}
</code></pre>
<p>注意:retrofit中使用了大量的注解，在这个请求定义中可以看到。使用@get表示这个请求为get类型,使用path来与url中已经定义好的参数做映射。</p>
<h5 id="发出请求">发出请求</h5>
<pre><code class="language-kotlin"> private fun makeRetrofitCall() {
        val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            //相对官方示例，我们多了添加gson解析器这一步。一般如果不添加这里会抛出can not convert exception.
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val githubService = retrofit.create(GithubService::class.java)
        githubService.listRepos(&quot;alsowell&quot;).enqueue(object : retrofit2.Callback&lt;List&lt;Any&gt;&gt; {
            override fun onFailure(call: retrofit2.Call&lt;List&lt;Any&gt;&gt;, t: Throwable) {

            }
            override fun onResponse(
                call: retrofit2.Call&lt;List&lt;Any&gt;&gt;,
                response: retrofit2.Response&lt;List&lt;Any&gt;&gt;
            ) {
            Log.d(&quot;Retrofit&quot;,response.body().toString())
            }
        })
    }
</code></pre>
<p>到这里，使用retrofit进行的一个完整的网络请求就完成了。retrofit会使用我们设置的GsonConvertFactory来将response解析成用户希望的格式。使用的时候直接调用response.body()就可以拿到我们想要的数据。下面我一点一点的分析retrofit内部究竟做了什么。</p>
<h4 id="retrofitbuilder">Retrofit.builder()</h4>
<p>上面的网络请求中发现，首先要构造出来一个retrofit对象。retrofit跟okhttpclient一样也是使用建造者模式构建出来的，我们来看一下里面有哪些参数:</p>
<pre><code class="language-java">    private final Platform platform;
    private @Nullable okhttp3.Call.Factory callFactory;
    private @Nullable HttpUrl baseUrl;
    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();
    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();
    private @Nullable Executor callbackExecutor;
    private boolean validateEagerly;
</code></pre>
<h5 id="platform">Platform</h5>
<p>platform是retrofit判断当前运行平台的类。目前支持Android、java两个运行平台。在调用Retrofit.builder()方法时就通过调用Platform.get()方法来获取平台类型。同时也会进行一些对应平台的初始化工作。</p>
<h5 id="callfactory">callFactory</h5>
<p>字面意思就是请求工厂类。可以看到其类型是okhttp3定义的call对象。这里其实可以知道retrofit内部请求使用的仍然是okhttp，只不过是对其进行了一次封装，用户可以更方便的进行使用。关于callFactory也是支持用户进行设置进去的。</p>
<pre><code class="language-kotlin">  val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            .addConverterFactory(GsonConverterFactory.create())
            .callFactory(OkHttpClient.Builder().build())
            .build()
</code></pre>
<p>可以看到通过callFactory方法，就可以使用用户自己定义的<strong>OkHttpClient</strong>对象了。那如果用户没有设置呢？</p>
<pre><code class="language-kotlin"> public Retrofit build() {
    //省略代码
      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }
      //省略代码
    }
</code></pre>
<p>会发现，在调用build方法时,retrofit会对当前的callFactory进行空判断。如果当前为null，那么会直接new OkHttpClient()。</p>
<h5 id="httpurl">HttpUrl</h5>
<p>HttpUrl其实也是okHttp包中的类，通过源码可以看到我们设置baseUrl为https://api.github.com/时，内部也是通过HttpUrl.get()方法来进行一些url合法性的校验，以及解析设置后续网络请求会用到的一些参数。具体可在之前OkHttp系列文章中找到。</p>
<h5 id="converterfactories">converterFactories</h5>
<p>看见名字我们就知道其实是转换器的工厂。例如我们在前面进行请求时设置了一个GsonConvertFactory来将网络请求的数据解析成我们真正想要的返回。关于Converte和Factory我们将在下文进行详细的分析，这里先保留一些疑问。</p>
<h5 id="calladapterfactories">callAdapterFactories</h5>
<p>翻译过来就是请求适配器工厂,见名知其意即为对请求进行包装来适配不同框架的工厂集。一般我们在使用retrofit时都会结合RxJava来一起使用,那么就是通过callAdapter来进行使用的。同样我们也还是保持一些疑问留给下文详细探究。</p>
<h5 id="callbackexecutor">callbackExecutor</h5>
<p>回调执行器，是不是很好理解?就是我们请求完成之后对我们回调的数据进行线程切换的执行器。同样也可以通过在build过程中用户动态的设置进来。如果没有设置那么retrofit是怎么做的呢?</p>
<pre><code class="language-java">  Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }
</code></pre>
<p>上文我们有说到过platform其实就是运行平台的意思。defaultCallbackExecutor()其实是Platform中定义的方法,每个平台对应其有自己的实现。在Android平台下:</p>
<pre><code class="language-kotlin">    @Override public Executor defaultCallbackExecutor() {
      return new MainThreadExecutor();
    }
    //静态内部类
     static class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());

      @Override public void execute(Runnable r) {
        handler.post(r);
      }
    }
</code></pre>
<p>可以看到默认是在主线程回调返回的，拿到主线程的handler对象，拿到解析完成后的响应数据后通过mainHandler的post方法直接回调到主线程，让用户可以直接在主线程中去更新UI。</p>
<h5 id="validateeagerly">validateEagerly</h5>
<p>用来配置在使用retrofit.crate()时是否对接口中定义的所有方法进行解析。</p>
<p><br></br><br>
上文说到通过Retrofit.builder.xxx.xxx.build()方法最终是拿到一个Retrofit对象的。那我们来接着看一下</p>
<h4 id="retrofit">Retrofit</h4>
<p>首先看一下构造方法:</p>
<pre><code class="language-java"> Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,
      @Nullable Executor callbackExecutor, boolean validateEagerly) {
    this.callFactory = callFactory;
    this.baseUrl = baseUrl;
    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
    this.callbackExecutor = callbackExecutor;
    this.validateEagerly = validateEagerly;
  }
</code></pre>
<p>既然是通过builder.build方法来构建出来我们需要的retrofit对象，那就详细的来看一下build做了哪些操作:</p>
<pre><code class="language-java">   public Retrofit build() {
      if (baseUrl == null) {
        throw new IllegalStateException(&quot;Base URL required.&quot;);
      }

      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }

      Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }

      // Make a defensive copy of the adapters and add the default Call adapter.
      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);
      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));

      // Make a defensive copy of the converters.
      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(
          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

      // Add the built-in converter factory first. This prevents overriding its behavior but also
      // ensures correct behavior when using converters that consume all types.
      converterFactories.add(new BuiltInConverters());
      converterFactories.addAll(this.converterFactories);
      converterFactories.addAll(platform.defaultConverterFactories());

      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
    }
</code></pre>
<p>按照调用步骤分析如下:</p>
<ul>
<li>先判断baseUrl是否为null,为null直接抛出异常</li>
<li>判断是否有设置callFactory和callBackExecutor，无则使用默认的。具体前文有介绍</li>
<li>将平台默认的适配器添加到最后，来看一下Android平台默认的适配器<pre><code class="language-java">//这里传入的executor为上文中用户自定义或者android平台的默认MainExecutor
//关于DefaultCallAdapterFactory将在后续详细分析
List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(
  @Nullable Executor callbackExecutor) {
return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
}
</code></pre>
</li>
<li>定义一个大小为1+用户设置转换器集合size+系统默认转换器size的集合</li>
<li>将retrofit内置的转换器添加进去</li>
<li>将用户设置的转换器添加进去</li>
<li>添加平台默认的转换器
<ul>
<li>Android平台下仅仅在api&gt;24时候添加进来一个OptionalConverterFactory,其他时候为一个空数组</li>
</ul>
</li>
<li>最终通过调用Retrofit的构造方法来成功构建出Retrofit对象</li>
</ul>
<p>构造无非是把我们在builder中设置的参数传递进来并赋值给类中定义的变量。我们来看一下Retrofit类中定义的一些变量:</p>
<pre><code class="language-java">  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();
  final okhttp3.Call.Factory callFactory;
  final HttpUrl baseUrl;
  final List&lt;Converter.Factory&gt; converterFactories;
  final List&lt;CallAdapter.Factory&gt; callAdapterFactories;
  final @Nullable Executor callbackExecutor;
  final boolean validateEagerly;
</code></pre>
<p>除了serviceMethodCache，其他变量均已经在我们在build时设置过。</p>
<h5 id="servicemethodcache">serviceMethodCache</h5>
<p>可以看到serviceMethodCache是一个HahshMap集合,实际上是对我们在接口中定义的方法的缓存。是否还记得我们通过注解定义了请求方法类型、请求参数等。我们来看一下ServiceMethod这个类</p>
<pre><code class="language-java">abstract class ServiceMethod&lt;T&gt; {
  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {
    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);

    Type returnType = method.getGenericReturnType();
    if (Utils.hasUnresolvableType(returnType)) {
      throw methodError(method,
          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
    }
    if (returnType == void.class) {
      throw methodError(method, &quot;Service methods cannot return void.&quot;);
    }

    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
  }

  abstract @Nullable T invoke(Object[] args);
}

</code></pre>
<p>这里是定义的一个带有泛型的抽象类，通过parseAnnotations()来对我们在定义方法时候的注解进行解析。我们具体来看一下parseAnnotations()方法</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea72855f7c884f?w=2150&amp;h=1094&amp;f=jpeg&amp;s=410765" alt=""><br>
可以看到这里是根据HTTP协议来传入方法类型以及是否有body体，具体实现也是很简单。</p>
<h4 id="retrofitcreate">Retrofit.create()</h4>
<p>按照调用流程我们拿到retrofit对象之后会通过retrofit.create(service)方法来拿到一个Service。来看一下具体实现:</p>
<pre><code class="language-java"> public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();
          private final Object[] emptyArgs = new Object[0];

          @Override public @Nullable Object invoke(Object proxy, Method method,
              @Nullable Object[] args) throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
          }
        });
  }
</code></pre>
<p>简单翻译一下注释:是我们在service接口中定义的方法的具体实现。具体来看代码:</p>
<ul>
<li>通过validateEagerly变量来判断是否提前将接口类中的所有方法解析出来。具体解析分析见下文</li>
<li>验证接口类的合法性
<ul>
<li>必须是接口定义</li>
<li>接口类中不能有内部接口类</li>
</ul>
</li>
<li>返回动态代理的具体实现（关于动态代理，这里提供一篇优秀的文章:<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a>）
<ul>
<li>先来看一下Proxy.newProxyInstance这个方法传入的参数。
<ul>
<li>ClassLoader:对应我们传入的service的classLoader</li>
<li>Class&lt;?&gt;[]:需要被代理的接口类,这里传入我们定义的service</li>
<li>InvocationHandler:使用默认的InvocationHandler</li>
</ul>
</li>
<li>具体看一下InvocationHandler方法里面做了什么事情?
<ul>
<li>首先拿到当前运行的平台（这里特指android）</li>
<li>定义一个空的对象数组</li>
<li>看一下invoke方法里面的调用逻辑
<ul>
<li>如果代理的方法是从一个object中的那么直接走原来的方法</li>
<li>根据平台类型来判断执行分支(android version 24以后可能是发生了改动)Android platform这里是做了兼容是不会进来的</li>
<li>返回loadServiceMethod.invoke()方法的返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="loadservicemethod">loadServiceMethod</h5>
<p>经过上面的分析知道，retrofit.create()方法返回的是loadServiceMethod.invoke()的代理实现。那来看一下这个是做了什么事情。<br></p>
<ul>
<li>注:上文说到的提前解析其实也是调用的这个方法，在for循环中进行</li>
</ul>
<pre><code class="language-java">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
    if (result != null) return result;

    synchronized (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      if (result == null) {
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }
</code></pre>
<ul>
<li>首先从缓存中去取看是否已经存在,存在的话直接返回</li>
<li>在代码锁中再次尝试从缓存中取出，我的理解是为了防止请求进行时，之前提前解析时才完成，这样就避免重复的去解析接口中定义的方法造成资源浪费</li>
<li>通过ServiceMethod.parseAnnotations()方法将定义的请求解析出来并缓存(关于解析的具体逻辑，上文也说到过看似复杂其实就是按照特定的规则将定义的信息取出，感兴趣的同学可以具体看一下)。这里详细解析一下在解析之外做的事情，见下文。</li>
</ul>
<h5 id="httpservicemethod">HttpServiceMethod</h5>
<p>在loadServiceMethod方法中调用了ServiceMethod.parseAnnotations()来解析我们在接口方法中定义的一些参数,最终返回的是HttpServiceMethod.parseAnnotations（）的返回。</p>
<p>HttpServiceMethod其实继承于ServiceMethod,ServiceMethod定义了一个invoke的抽象方法。还记得在retrofit create中返回的是ServiceMethod.invoke()吗？</p>
<p>还是先看一下在HttpServiceMethod的parseAnnotations中做了什么事情</p>
<pre><code class="language-java"> static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
      Retrofit retrofit, Method method, RequestFactory requestFactory) {
    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
    boolean continuationWantsResponse = false;
    boolean continuationBodyNullable = false;

    Annotation[] annotations = method.getAnnotations();
    Type adapterType;
    if (isKotlinSuspendFunction) {
      Type[] parameterTypes = method.getGenericParameterTypes();
      Type responseType = Utils.getParameterLowerBound(0,
          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
      if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) {
        // Unwrap the actual body type from Response&lt;T&gt;.
        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
        continuationWantsResponse = true;
      } else {
        // TODO figure out if type is nullable or not
        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
        // Find the entry for method
        // Determine if return type is nullable or not
      }

      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
    } else {
      adapterType = method.getGenericReturnType();
    }
    //创建请求适配器
    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =
        createCallAdapter(retrofit, method, adapterType, annotations);
    Type responseType = callAdapter.responseType();
    if (responseType == okhttp3.Response.class) {
      throw methodError(method, &quot;'&quot;
          + getRawType(responseType).getName()
          + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;);
    }
    if (responseType == Response.class) {
      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);
    }
    // TODO support Unit for Kotlin?
    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) {
      throw methodError(method, &quot;HEAD method must use Void as response type.&quot;);
    }
    //创建响应体转换器 
    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =
        createResponseConverter(retrofit, method, responseType);

    okhttp3.Call.Factory callFactory = retrofit.callFactory;
    if (!isKotlinSuspendFunction) {
      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);
    } else if (continuationWantsResponse) {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);
    } else {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,
          continuationBodyNullable);
    }
  }
</code></pre>
<p>这里我们来分析几个主要的函数:</p>
<ul>
<li>createCallAdapter
<ul>
<li>创建请求适配器，这里只放一些关键代码。<pre><code class="language-java">//createCallAdapter
return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);

//retrofit.callAdapter
return nextCallAdapter(null, returnType, annotations);

//nextCallAdapter
int start = callAdapterFactories.indexOf(skipPast) + 1;
for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {
  CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
  if (adapter != null) {
    return adapter;
  }
}

</code></pre>
<ul>
<li>可以看到这里是从我们之前在创建retrofit时候定义的callAdapterFactories中取出一个CallAdapter(DefaultCallAdapterFactory)</li>
</ul>
</li>
</ul>
</li>
<li>createResponseConverter
<ul>
<li>创建响应转换器<pre><code class="language-java">//createResponseConverter
return retrofit.responseBodyConverter(responseType, annotations);
//retrofit.responseBodyConverter
return nextResponseBodyConverter(null, type, annotations);
//nextResponseBodyConverter
int start = converterFactories.indexOf(skipPast) + 1;
for (int i = start, count = converterFactories.size(); i &lt; count; i++) {
  Converter&lt;ResponseBody, ?&gt; converter =
      converterFactories.get(i).responseBodyConverter(type, annotations, this);
  if (converter != null) {
    //noinspection unchecked
    return (Converter&lt;ResponseBody, T&gt;) converter;
  }
}
</code></pre>
<ul>
<li>可以看到createResponseConverter与createCallAdapter类似，均是从之前定义的列表中返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<tr>
<td bgcolor="f7f6f3">
题外话：曾经遇到一道面试题:retrofit是什么时候将接口中定义的方法解析出来的？是一次性将所有方法解析出来还是使用到的时候在解析?<br>
分析到这里，答案其实很简单了。默认情况下，用户没有通过validateEagerly()方法设置提前解析的话，retrofit是地用到具体方法的时候才会将方法解析出来，这样就可能尽可能的降低内存消耗。如果设置为true的情况，那么就是直接在create创建retrofit对象的时候将接口类中定义的方法一次性全部解析出来。
</td>
</tr>
</table>
<h4 id="方法调用">方法调用</h4>
<p>我们分析了retrofit的create方法其实动态代理了我们在接口中定义的方法。那接着来看一下在调用方法的时候是干了什么</p>
<pre><code class="language-java">    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
</code></pre>
<pre><code class="language-kotlin"> val listRepos = githubService.listRepos(&quot;alsowell&quot;)
</code></pre>
<p>可以看到我们在接口中定义的方法的返回其实是一个call对象，还记得okhttp中的call吗？你是不是以为是一个东西？但是其实这个是retrofit内部自己定义的。</p>
<p>经过前文的分析我们知道当我们调用接口里面的方法时候，其实会调用invoke方法。并且这里实际调用的是HttpServiceMethod的invoke()方法。我们来看一下做了什么操作。</p>
<pre><code class="language-java">  @Override final @Nullable ReturnT invoke(Object[] args) {
    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);
    return adapt(call, args);
  }
</code></pre>
<p>这里的okhttpCall其实是retrofit对okhttp的封装，这里是进行了简单的赋值操作。<br>
最终返回的是adapt(call,args)。继续往下看，adapt其实是CallAdapter接口中定义的方法。还记得我们在build retrofit时默认的DefaultCallAdapterFactory吗？具体的实现是由它来做的。</p>
<pre><code class="language-java">   return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
      @Override public Type responseType() {
        return responseType;
      }

      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
        return executor == null
            ? call
            : new ExecutorCallbackCall&lt;&gt;(executor, call);
      }
    };
</code></pre>
<p>可以看到最终会返回ExecutorCallbackCall，他也是继承于Call</p>
<h5 id="executorcallbackcall">ExecutorCallbackCall</h5>
<pre><code class="language-java"> static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
    final Executor callbackExecutor;
    final Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
      this.callbackExecutor = callbackExecutor;
      this.delegate = delegate;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      checkNotNull(callback, &quot;callback == null&quot;);

      delegate.enqueue(new Callback&lt;T&gt;() {
        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              if (delegate.isCanceled()) {
                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));
              } else {
                callback.onResponse(ExecutorCallbackCall.this, response);
              }
            }
          });
        }

        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              callback.onFailure(ExecutorCallbackCall.this, t);
            }
          });
        }
      });
    }

    @Override public boolean isExecuted() {
      return delegate.isExecuted();
    }

    @Override public Response&lt;T&gt; execute() throws IOException {
      return delegate.execute();
    }

    @Override public void cancel() {
      delegate.cancel();
    }

    @Override public boolean isCanceled() {
      return delegate.isCanceled();
    }

    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.
    @Override public Call&lt;T&gt; clone() {
      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());
    }

    @Override public Request request() {
      return delegate.request();
    }
  }
</code></pre>
<p>上文介绍过retrofit的call对象其实是对okhttpcall的封装。基本上与ok的方法相同。通过create动态代理拿到接口的代理类后可以直接调其中定义的方法。那么在执行enqueue方法时的具体实现可以在上文中代码看到，retrofit是定义了</p>
<pre><code class="language-java"> final Call&lt;T&gt; delegate;
</code></pre>
<p>这么一个泛型对象来进行真正的执行。其实在上文也分析到了这里的delegate其实是retrofit内部封装的OkHttpCall类，这个也是我们在build retrofit时通过addConverterFactory设置进来或者默认的。</p>
<ul>
<li>所以可以说retrofit执行网络请求的底层依然是okhttp，此结论成立。</li>
</ul>
<p>执行完毕后会推过设置的callBackExecutor回调出去，默认是主线程。</p>
<h4 id="解析阶段">解析阶段</h4>
<p>上文既然说到我们是通过retrofit封装的OkhttpCall对象实际调用的还是okhttp来进行网络请求，之后拿到响应再回调到主线程。但是我们在ExecutorCallbackCall好像并没有看到解析response的过程，那用户是怎么拿到解析之后的返回呢？</p>
<p>既然这里没有，那我们肯定要追根溯源去实际返回响应的地方找一下:</p>
<pre><code class="language-java">   call.enqueue(new okhttp3.Callback() {
      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
        Response&lt;T&gt; response;
        try {
          response = parseResponse(rawResponse);
        } catch (Throwable e) {
          throwIfFatal(e);
          callFailure(e);
          return;
        }

        try {
          callback.onResponse(OkHttpCall.this, response);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }

      @Override public void onFailure(okhttp3.Call call, IOException e) {
        callFailure(e);
      }

      private void callFailure(Throwable e) {
        try {
          callback.onFailure(OkHttpCall.this, e);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }
    });
</code></pre>
<p>可以看到里面有一句关键的代码<strong>parseResponse(rawResponse);</strong>，继续往下看:</p>
<pre><code class="language-java">      T body = responseConverter.convert(catchingBody);
</code></pre>
<p>在这个方法里面找到这个关键的一句，经过我们之前设置的converter转换之后返回的是我们在方法里面定义的泛型。</p>
<h4 id="总结">总结</h4>
<p>上面分析了这么多，先来总结一下Retrofit的大概流程</p>
<ul>
<li>定义一个接口类，定义出我们需要请求的方法</li>
<li>通过builder模式构建出retrofit对象</li>
<li>调用create()方法通过动态代理的方式返回实际的代理对象</li>
<li>通过代理对象来调用接口中定义的方法</li>
<li>enqueue或者excute实际上是调用addCallAdapterFactory中设置的(默认是okhttp)</li>
<li>通过okhttp来进行实际的网络请求</li>
<li>通过设置的converter来对返回的response进行解析成用户定义的格式</li>
<li>通过callBackExecutor回调给调用方（默认是主线程）</li>
</ul>
<p>至此，我们对Retrofit源码的探究终于可以说是告一段落了，跟OkHttp一样，retrofit的源码同样有很多值得我们学习的地方，例如动态代理的实现。整篇文章下来可能有很多不严谨的地方，这里只是记录个人对于Retrofit的理解，希望大家多多指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee">Retrofit源码解析</a><br><br>
<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(七)CallServerInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor">
        </link>
        <updated>2019-11-26T02:53:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>终于！我们来到了ok内置五大拦截器最后一个拦截器的探究。关于这个拦截器我们直接来看一下源码的注释:</p>
<table><tr><td>
This is the last interceptor in the chain. It makes a network call to the server.
</td></tr></table>
<p>看到这里是不是有种拨开云雾见明月的感觉。话不多说我们继续先看下源码:</p>
<pre><code class="language-kotlin">
  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

    exchange.writeRequestHeaders(request)

    var responseHeadersStarted = false
    var responseBuilder: Response.Builder? = null
    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) {
      // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100
      // Continue&quot; response before transmitting the request body. If we don't get that, return
      // what we did get (such as a 4xx response) without ever transmitting the request body.
      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase = true)) {
        exchange.flushRequest()
        responseHeadersStarted = true
        exchange.responseHeadersStart()
        responseBuilder = exchange.readResponseHeaders(true)
      }
      if (responseBuilder == null) {
        if (requestBody.isDuplex()) {
          // Prepare a duplex body so that the application can send a request body later.
          exchange.flushRequest()
          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
          requestBody.writeTo(bufferedRequestBody)
        } else {
          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.
          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
          requestBody.writeTo(bufferedRequestBody)
          bufferedRequestBody.close()
        }
      } else {
        exchange.noRequestBody()
        if (!exchange.connection()!!.isMultiplexed) {
          // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 connection
          // from being reused. Otherwise we're still obligated to transmit the request body to
          // leave the connection in a consistent state.
          exchange.noNewExchangesOnConnection()
        }
      }
    } else {
      exchange.noRequestBody()
    }

    if (requestBody == null || !requestBody.isDuplex()) {
      exchange.finishRequest()
    }
    if (!responseHeadersStarted) {
      exchange.responseHeadersStart()
    }
    if (responseBuilder == null) {
      responseBuilder = exchange.readResponseHeaders(false)!!
    }
    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
    var code = response.code
    if (code == 100) {
      // server sent a 100-continue even though we did not request one.
      // try again to read the actual response
      response = exchange.readResponseHeaders(false)!!
          .request(request)
          .handshake(exchange.connection()!!.handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
      code = response.code
    }

    exchange.responseHeadersEnd(response)

    response = if (forWebSocket &amp;&amp; code == 101) {
      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
      response.newBuilder()
          .body(EMPTY_RESPONSE)
          .build()
    } else {
      response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
    }
    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase = true) ||
        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase = true)) {
      exchange.noNewExchangesOnConnection()
    }
    if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) {
      throw ProtocolException(
          &quot;HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}&quot;)
    }
    return response
  }
  
</code></pre>
<h4 id="流程分析">流程分析</h4>
<p>是不是感觉臭长臭长的，但是莫慌！我们来一点一点攻克它。<br>
我们先来看下面几行代码</p>
<pre><code class="language-kotlin">    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

</code></pre>
<p>这里几行基本上取出对应的参数，并且设置当前时间为请求发出时间。关键的是从realChain中取出Exchange对象，这个对象是后续操作的比较关键的，之前在connectInterceptor中构建出来并且传递到当前的。</p>
<p>接着网下看:通过 exchange.writeRequestHeaders(request)方法来开始写入请求头，接着根据请求方式和请求体是否为空来进入分支逻辑:</p>
<h4 id="请求体不为空主要针对post请求br">请求体不为空(主要针对POST请求)<br></h4>
<h5 id="100-continue">100-continue</h5>
<p>刚开始看到这里笔者也是有点懵逼的，这是什么鬼header。于是开始Google大法:</p>
<table>
<tr>
<td bgcolor="#f7f6f3">
http 100-continue用于客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。在现实应用中，通常在POST大数据时，才会使用100-continue协议。<br>
来源:https://zhuanlan.zhihu.com/p/30830041
</td>
</tr>
</table>
<p>接着就是读取响应头，同时通知eventListener响应头开始读取。我们看源码的调用链是调用ExchangeCodec的readResponseHeaders()方法来读取响应头，具体类似于BridgeInterceptor中的intercept方法。</p>
<p>紧接着根据responseBuilder是否为null来进入分支逻辑，这个responseBuilder是根据又是根据header中的Expect是否为<strong>100-continue</strong>来判断的。接下来就是比较简单了，根据request构建出来一个requesBody，并且把其写入到请求的body中。</p>
<h4 id="请求体为空">请求体为空</h4>
<p>请求体为null的情况下就比较简单了直接调用noRequestBody()方法。表示当前request阶段已经完成.</p>
<h4 id="response阶段">Response阶段</h4>
<p>我们知道请求响应的开始也是从读取header。在上面经过发起Request结束之后，ok就已经做好准备进行response的接收。同样事件的发生也是会回调eventListener对应的监听。</p>
<pre><code class="language-kotlin">    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
</code></pre>
<p>可以看到经过一系列操作，我们已经拿到了服务器的返回。最终就是通过:</p>
<pre><code class="language-kotlin"> response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
</code></pre>
<p>这个方法来将服务端解析为客户端真正可用的resonse。</p>
<h4 id="总结">总结</h4>
<p>CallServerInterceptor的流程解析基本上到这里就结束了。纵观ok内置几个拦截器的源码，其实都不是很复杂，内部是采用了优秀的设计模式将以此请求中的每个阶段都做了分层，然后采用递归调用的思想通过几个拦截器将一个请求由上而下、再由下而上的完成。其中的设计模式以及代码的分离都是非常值得我们来学习的。</p>
<p>基本上关于拦截器的分析到这里就告一段了。整个流程下来笔者对于ok内部的很多东西也是一笔带过，后续将会好机会再详细分析。通过对ok一次请求的整体流程的探究，深知<strong>纸上得来终觉浅，绝知此事要躬行</strong>，这句话也跟大家一起共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（六）ConnectInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor">
        </link>
        <updated>2019-11-25T07:28:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>不知不觉已经到了要分析ok内置拦截器第四个的文章了，本篇的主角就是ConnectInterceptor，看名字也就知道它是负责与服务器建立连接的拦截器也。</p>
<h4 id="源码分析">源码分析</h4>
<p>话不多说，上代码:</p>
<pre><code class="language-kotlin">   @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val request = realChain.request()
    val transmitter = realChain.transmitter()

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    val doExtensiveHealthChecks = request.method != &quot;GET&quot;
    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)

    return realChain.proceed(request, transmitter, exchange)
  }
</code></pre>
<p>可以看到这个拦截器里面的代码是异常的精简，纵观全部发现关键步骤是在于调用transmitter.newExchange()方法。前面的文章中简单分析过transmitter类还有印象吗？这里再简单回顾下</p>
<h5 id="transmitter">Transmitter</h5>
<p>Transmitter是应用层和网络层之间的桥梁，对外暴露了网络连接过程中的connection、request、response、streams。</p>
<p>我们接着看newExchange方法做了什么事情</p>
<pre><code class="language-kotlin">  /** Returns a new exchange to carry a new request and response. */
  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
    synchronized(connectionPool) {
      check(!noMoreExchanges) { &quot;released&quot; }
      check(exchange == null) {
        &quot;cannot make a new request because the previous response is still open: &quot; +
            &quot;please call response.close()&quot;
      }
    }

    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)

    synchronized(connectionPool) {
      this.exchange = result
      this.exchangeRequestDone = false
      this.exchangeResponseDone = false
      return result
    }
  }
</code></pre>
<p>首先是通过exchangeFinder调动find方法拿到codec，那这几个又是什么东西呢？</p>
<h5 id="exchangefinder">ExchangeFinder</h5>
<p>不知大家对介绍重试拦截器的过程是否还有印象？在重试拦截器中有通过transmitter调用prepareToConnect()。exchangeFinder对象同时也是那个时候初始化的，当时的介绍是为了后续的网络连接做准备。我们今天就来看看其在ConnectionInterceptor过程中是怎么做的网络连接。</p>
<p>还是简单翻译一下ExchangeFinder的类注释：</p>
<table><tr><td bgcolor=""#f7f6f3>
尝试找到请求队列中的已经存在的连接,使用下列策略：<br>
1.如果当前请求已经连接上，那么就直接使用。
2.如果连接池中有可以服用的连接，那么根据RealConnection.isEligible来判断是否使用。
3.如果当前没有存在的连接，那么就尝试从新建立一个新的连接。
</td></tr></table>
<p>可以看到ok在建立连接的时候是遵循尽量服用连接池的做法，因为这样可以大大降低在网络连接过程解析DNS耗时、以及握手耗时。<br></p>
<p>那么find()方法是做了什么事情呢？还是先看一下代码:</p>
<pre><code class="language-kotlin"> fun find(client: OkHttpClient,chain: Interceptor.Chain,doExtensiveHealthChecks: Boolean
  ): ExchangeCodec {
    //参数设置代码省略。。。。。。。
    try {
    //找到目前可用的连接
      val resultConnection = findHealthyConnection(
          connectTimeout = connectTimeout,
          readTimeout = readTimeout,
          writeTimeout = writeTimeout,
          pingIntervalMillis = pingIntervalMillis,
          connectionRetryEnabled = connectionRetryEnabled,
          doExtensiveHealthChecks = doExtensiveHealthChecks
      )
      return resultConnection.newCodec(client, chain)
    } catch (e: RouteException) {
      trackFailure()
      throw e
    } catch (e: IOException) {
      trackFailure()
      throw RouteException(e)
    }
  }
</code></pre>
<p>抛却一大推设置参数的代码可以发现主要是findHealthyConnection()来找到一个可用的connection。那它究竟是怎么找的呢？（为了分析请求流程这里可能会有大量代码）。进入到findHealthyConnection()方法中我们发现在while循环中，主要是通过findConnection()来寻找可用connection。并且方法注释如下:</p>
<pre><code class="language-kotlin">  /**
   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
   * until a healthy connection is found.
   */
</code></pre>
<h5 id="findconnection">findConnection()</h5>
<pre><code class="language-kotlin"> /**
   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
   * then the pool, finally building a new connection.
   */
</code></pre>
<p>这是每次请求过程中真正找到connection的方法，至于是使用已经存在的还是新建立的我们通过代码来分析:(方法代码有点长，为了流程连贯，将在代码中使用注释分析)</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    //使用代码块锁 保证线程同步 
    synchronized(connectionPool) {
    //前文分析过这里只会是用户主动取消，如果取消抛出异常
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)
      hasStreamFailure = false // This is a fresh attempt.

      releasedConnection = transmitter.connection
      //这里判断如果数据传输已经完成就返回需要关闭的sokcet，反之为null
      toClose = if (transmitter.connection != null &amp;&amp; transmitter.connection!!.noNewExchanges) {
        transmitter.releaseConnectionNoEvents()
      } else {
        null
      }
        //已经有一个分配好的连接 并且处于可用状态 
      if (transmitter.connection != null) {
        // We had an already-allocated connection and it's good.
        result = transmitter.connection
        releasedConnection = null
      }
    //按照之前的策略，如果当前没有已经连接好的连接，会尝试从连接池中找到一个可用的。
      if (result == null) {
        // Attempt to get a connection from the pool.
        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        } else if (retryCurrentRoute()) {
          selectedRoute = transmitter.connection!!.route()
        }
      }
    }
    //关闭之前socket 
    toClose?.closeQuietly()

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection!!)
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result!!
    }
    
    // If we need a route selection, make one. This is a blocking operation.
    var newRouteSelection = false
    if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection!!.hasNext())) {
      newRouteSelection = true
      routeSelection = routeSelector.next()
    }

    var routes: List&lt;Route&gt;? = null
    synchronized(connectionPool) {
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection!!.routes
        //再次尝试从连接池中找到可用连接
        if (connectionPool.transmitterAcquirePooledConnection(
                address, transmitter, routes, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        }
      } 
        
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }
        //再次尝试从连接池中找到可用连接失败，创建一个connection 
        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }
    //刚刚创建出来的connection 调用connect方法进行网络连接 
    // Do TCP + TLS handshakes. This is a blocking operation.
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    //将当前域名从失败的黑名单中移除掉
    connectionPool.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      //在连接过程中最后一次尝试从连接池中找到已经有的连接，防止同时有两个相对host的请求发出，这样就能复用已有的连接
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = transmitter.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
      //将这次连接放入连接池中，为了后续可能直接复用
        connectionPool.put(result!!)
        transmitter.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }

</code></pre>
<p>经过分析代码可以发现，ok在进行连接建立的时候不是直接去建立的connection，而是尽可能的寻找已经存在的连接去进行复用。如果实在没有可利用的再去创建一条新的连接并且将其放入连接池给后续请求去复用。</p>
<p>经过上面苦苦一番寻找，我们终于拿到了一条建立好的可使用的连接RealConnection。然后直接调用newCodec()方法返回一个ExchangeCodec对象。我们再来看一下是干嘛的:</p>
<pre><code class="language-kotlin"> @Throws(SocketException::class)
  internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec {
    val socket = this.socket!!
    val source = this.source!!
    val sink = this.sink!!
    val http2Connection = this.http2Connection

    return if (http2Connection != null) {
      Http2ExchangeCodec(client, this, chain, http2Connection)
    } else {
      socket.soTimeout = chain.readTimeoutMillis()
      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)
      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)
      Http1ExchangeCodec(client, this, source, sink)
    }
  }
</code></pre>
<p>可以看到关键方法就是根据当前请求协议是HTTP1还是HTTP2来返回一个codec，我们跟进到codec类去看一下注释，大概翻译如下:</p>
<table><tr><td bgcolor="#f7f6f3">
一个用来发送http/1.1消息的socket连接，并且严格遵守下列的生命周期:<br>
- 发送请求的headers[writeRequest]<br>
- 打开一个水槽（直译）去写入请求体<br>
- 开始写入请求体然后关闭这个水槽<br>
- 读取响应头
- 申请一部分资源开始读取响应体
- 读取完成响应体后关闭资源
</td></tr></table>
经过上面寻找可用连接的操作之后基本上到了newExchange的最后一步去构建出来一个Exchange并且返回。
<h5 id="exchange">Exchange</h5>
<p>类注释很简单:传输一个http的请求和响应，是真正上处理IO操作的。事件的管理是被ExchangeCodec管控。</p>
<h4 id="总结">总结</h4>
<p>到这里,关于ConnectInterceptor的源码探究基本上就告一段落了。我们大概来总结下:</p>
<ul>
<li>从chain对象中获取到Transmitter对象</li>
<li>调用transmitter的newExchange()方法</li>
<li>根据调度策略找到可用的连接并返回</li>
<li>调用proceed调用下一个拦截器</li>
</ul>
<p>上面基本上就是ConnectionInterceptor的调用流程，接下来我们会继续分析ok内置的最后一个拦截器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（五）CacheInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor">
        </link>
        <updated>2019-11-22T09:42:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了重试拦截器和BridgeInterceptor(用来处理header、设置gzip、user-agent等)。本篇文章将开始分析ok内置拦截器比较实用的缓存拦截器<strong>CacheInterceptor</strong>。</p>
<p>顾名思义，CacheInterceptor就是处理与缓存相关的。关于http中的缓存知识可以参考<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a>。这篇文章写得非常浅显易懂。</p>
<h4 id="源码探究">源码探究</h4>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val cacheCandidate = cache?.get(chain.request())

    val now = System.currentTimeMillis()

    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
    val networkRequest = strategy.networkRequest
    val cacheResponse = strategy.cacheResponse

    cache?.trackResponse(strategy)

    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
      // The cache candidate wasn't applicable. Close it.
      cacheCandidate.body?.closeQuietly()
    }

    // If we're forbidden from using the network and the cache is insufficient, fail.
    if (networkRequest == null &amp;&amp; cacheResponse == null) {
      return Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(HTTP_GATEWAY_TIMEOUT)
          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)
          .body(EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
    }

    // If we don't need the network, we're done.
    if (networkRequest == null) {
      return cacheResponse!!.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build()
    }

    var networkResponse: Response? = null
    try {
      networkResponse = chain.proceed(networkRequest)
    } finally {
      // If we're crashing on I/O or otherwise, don't leak the cache body.
      if (networkResponse == null &amp;&amp; cacheCandidate != null) {
        cacheCandidate.body?.closeQuietly()
      }
    }

    // If we have a cache response too, then we're doing a conditional get.
    if (cacheResponse != null) {
      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
        val response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers, networkResponse.headers))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()

        networkResponse.body!!.close()

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache!!.trackConditionalCacheHit()
        cache.update(cacheResponse, response)
        return response
      } else {
        cacheResponse.body?.closeQuietly()
      }
    }

    val response = networkResponse!!.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build()

    if (cache != null) {
      if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        val cacheRequest = cache.put(response)
        return cacheWritingResponse(cacheRequest, response)
      }
      
      if (HttpMethod.invalidatesCache(networkRequest.method)) {
        try {
          cache.remove(networkRequest)
        } catch (_: IOException) {
          // The cache cannot be written.
        }
      }
    }

    return response
  }

</code></pre>
<h5 id="request阶段">Request阶段</h5>
<p>可以看到，首先是通过请求的url去缓存中读取，当然取出的缓存对象可能为空。主要方法:</p>
<pre><code class="language-kotlin">   val cacheCandidate = cache?.get(chain.request())
</code></pre>
<p>那么Cache又是什么呢？还记得我们在分析OkHttpClient构造时候的cache参数吗？其实cache是ok内部实现的一个DiskLruCache。是不是很熟悉？也是三级缓存的原理。关于<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>,又是JakeWarton的一大杰作。多提一句，我们在构建client的时候可以通过builder模式设置我们想要缓存的文件夹以及最大缓存，下面放出代码。不过注意加好权限哦。</p>
<pre><code class="language-kotlin">     val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .cache(Cache(Environment.getDownloadCacheDirectory(),10000))
            .build()
</code></pre>
<p>接着是记录当前时间，他与从缓存取出的Response都是构建缓存策略的构造参数。说到缓存策略：</p>
<pre><code class="language-kotlin"> val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
</code></pre>
<p>其实结合http中的缓存原理（见上文连接）就可以很简单的理解了，无非是根据请求参数和本地的缓存是否需要使用本地或者说两者结合。</p>
<p>继续往下面看，根据networkRequest和cacheResponse 的值来判断后续流程。既然他们都是从CacheStrategy中拿到的，那我们先来了解下这两个家伙：</p>
<pre><code class="language-kotlin"> /** The request to send on the network, or null if this call doesn't use the network. */
 val networkRequest: Request?,
 /** The cached response to return or validate; or null if this call doesn't use a cache. */
 val cacheResponse: Response?
</code></pre>
<p>看了注释就非常好理解了，networkRequest在使用缓存的情况下为空，cahceRespoonse在没有使用缓存的情况下为空。<br>
那么两个都为空的情况下就直接返回一个空的响应体，并且设置状态吗为504。</p>
<p>使用缓存情况下，直接就返回缓存中存储的数据，这点在代码里可以体现：</p>
<pre><code class="language-kotlin">// If we don't need the network, we're done.
   if (networkRequest == null) {
     return cacheResponse!!.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .build()
   }
</code></pre>
<p>那么如果我们不适用缓存呢？机智的你肯定会想起来拦截器的机制，没错就是继续通过chain.proceed方法调用下一个拦截器。既然本篇是关于缓存的，我们就继续看一下在使用缓存情况下是怎么处理response的。</p>
<h5 id="response阶段">Response阶段</h5>
<p>如果你看了上面关于HTTP缓存分析的文章，你会知道在http协议中，如果数据没有发生改变那么响应码将会是304。同样ok既然作为一个网络库也是遵守同样的规则的。</p>
<p>在本地缓存不为空情况下，如果服务器返回304，那么ok将会更新header里面的一些参数，更新请求发起时间、响应接收时间等。在此之后返回networkResponse和cacheResponse结合之后的response。</p>
<p>如果用户设置了自定义的缓存目录以及大小并且当前请求是可以被缓存的，那么调用put方法将响应存储到本地磁盘中。但是如果请求的方法是 patch、put、delete、move等不支持缓存的方法，会将缓存从磁盘中清楚。</p>
<h4 id="总结">总结</h4>
<p>以上就是CacheInterceptor的全部分析啦。我们大概类总结一下流程：</p>
<ul>
<li>首先通过请求的url通过DiskLruCache拿到可能存在的响应体</li>
<li>通过请求时间和缓存中的响应体拿到缓存策略</li>
<li>通过策略判断本次请求是直接读取缓存还是请求网络获取</li>
<li>网络请求返回的数据更新到本地缓存中</li>
</ul>
<p>回头来看，其实缓存管理也是按照我们网络协议里面的规则，ok是基于这个规则对其进行了一定的封装。关键部分还是要充分的理解HTTP缓存机制，再次强烈推荐这篇<a href="https://www.cnblogs.com/chenqf/p/6386163.html">文章</a>。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://www.jianshu.com/p/963ad9ca214d">OKhttp源码学习（六）—— CacheInterceptor</a></p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（四）BridgeInterceptor]]></title>
        <id>https://alsowell.github.io//post/okhttp_two</id>
        <link href="https://alsowell.github.io//post/okhttp_two">
        </link>
        <updated>2019-11-22T02:17:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h4 id="前言">前言</h4>
<p>在上一篇文章中我们已经分析过了ok内置五个拦截器中的第一个RetryAndFollowUpInterceptor，本篇我们将继续按照顺序去探究一下BridgeInterceptor。</p>
<h4 id="介绍">介绍</h4>
<p>首先来看一下类注释：</p>
<table><tr><td bgcolor=#f7f6f3>
 Bridges from application code to network code. First it builds a network request from a user
 request. Then it proceeds to call the network. Finally it builds a user response from the network response.
<br></br>
释义：应用层和网络层之间的桥接，首先往用户发起的请求中添加一部分网络层需要的参数，接着调用网络，最后从响应体中解析出用户请求的结果
</td></tr></table>
接着我们直接上代码：
<pre><code class="language-kotlin">  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val userRequest = chain.request()
    val requestBuilder = userRequest.newBuilder()

    val body = userRequest.body
    if (body != null) {
      val contentType = body.contentType()
      if (contentType != null) {
        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())
      }
      val contentLength = body.contentLength()
      if (contentLength != -1L) {
        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())
        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)
      } else {
        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
        requestBuilder.removeHeader(&quot;Content-Length&quot;)
      }
    }
    if (userRequest.header(&quot;Host&quot;) == null) {
      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())
    }

    if (userRequest.header(&quot;Connection&quot;) == null) {
      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)
    }

    // If we add an &quot;Accept-Encoding: gzip&quot; header field we're responsible for also decompressing
    // the transfer stream.
    var transparentGzip = false
    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {
      transparentGzip = true
      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
    }

    val cookies = cookieJar.loadForRequest(userRequest.url)
    if (cookies.isNotEmpty()) {
      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))
    }

    if (userRequest.header(&quot;User-Agent&quot;) == null) {
      requestBuilder.header(&quot;User-Agent&quot;, userAgent)
    }

    val networkResponse = chain.proceed(requestBuilder.build())

    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
    
    val responseBuilder = networkResponse.newBuilder()
        .request(userRequest)
    if (transparentGzip &amp;&amp;
        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase = true) &amp;&amp;
        networkResponse.promisesBody()) {
      val responseBody = networkResponse.body
      if (responseBody != null) {
        val gzipSource = GzipSource(responseBody.source())
        val strippedHeaders = networkResponse.headers.newBuilder()
            .removeAll(&quot;Content-Encoding&quot;)
            .removeAll(&quot;Content-Length&quot;)
            .build()
        responseBuilder.headers(strippedHeaders)
        val contentType = networkResponse.header(&quot;Content-Type&quot;)
        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
      }
    }
    return responseBuilder.build()
  }
</code></pre>
<p>相对于上一篇的重试拦截器，bridge拦截器的代码相对来说是非常容易看懂的。我们将按照interceptor的调用来分为两个阶段分析：</p>
<h4 id="request阶段">Request阶段</h4>
<ul>
<li>
<p>取出body的contentType设置到header里面</p>
</li>
<li>
<p>获取请求体的长度放入header</p>
<ul>
<li>Transfer-Encoding 字面意思也很好理解，即为传输过程中的编码格式<br>
根据网上资料:首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP1.1的传输编码方式仅对分块传输编码有效。值为 chunked 表示请求体的内容大小是未知的。    因此Transfer-Encoding与Content-Length两个首部不能共存。</li>
</ul>
</li>
<li>
<p>将请求的host放入到header里面</p>
<ul>
<li>
<p>Host即对应请求中的域名 对此HttpUrl中有详细的注释解释</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left"><code>host()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>http://android.com/</code></td>
<td style="text-align:left"><code>&quot;android.com&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://127.0.0.1/</code></td>
<td style="text-align:left"><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://[::1]/</code></td>
<td style="text-align:left"><code>&quot;::1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://xn--n3h.net/</code></td>
<td style="text-align:left"><code>&quot;xn--n3h.net&quot;</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>其中toHostHeader()方法会取到对应的域名并且拼接上默认的端口 http默认端口80 、https默认端口443</p>
</li>
</ul>
</li>
<li>
<p>指定连接模式为 Keep-Alive 这样就能方便的复用连接池。</p>
</li>
<li>
<p>如果用户没有设置Accept-Encoding，那么会指定数据接收格式为gzip。顺带提一下：gzip格式压缩能大大减少网络流量的消耗。</p>
</li>
<li>
<p>header中放入cookie</p>
</li>
<li>
<p>请求头中放入 user-agent 如果用户没有设置，那么放入默认 agent:okhttp/x.x.x</p>
</li>
</ul>
<h4 id="response阶段">Response阶段</h4>
<ul>
<li>首先是根据url拿到返回的cookie。</li>
<li>如果Content-Encoding是gzip类型，并且content-length &gt;0 取出body进行处理</li>
<li>对请求响应体做一遍处理，因为响应体的body的传输格式是gzip类型，通过封装的方法类解析处理</li>
<li>解析成为用户真正可使用的body</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上就是整个BridgeInterceptor的全部流程了。大概可以分为三步</p>
<ul>
<li>对用户的请求做一遍处理，如果用户设置了参数使用用户配置，如果未设置那么就使用默认的。</li>
<li>通过chain调用下一个拦截器。</li>
<li>对接口的请求做一遍处理，比如gzip、cookie 最后解析成用户真正可使用的body。</li>
</ul>
<p>可以看到整个BridgeInterceptor的流程还是非常简单的，无非就是对网络传输协议中一些必须参数的封装，这样应用层在调用的时候就省去了这些步骤。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(三) RetryAndFollowUpInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor">
        </link>
        <updated>2019-11-21T12:17:21.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了整个okhttp的核心其实是getResponseWithInterceptor方法。内部是通过一系列的拦截器调用来完成整个网络请求。我们也知道了ok内部定义了五个拦截器。拦截器又是通过责任链模式来递归进行调用。本篇文章我们将按照加载顺序来分析第一个拦截器<strong>RetryAndFollowUpInterceptor</strong></p>
<p>####介绍</p>
<p>按照字面意思来理解就是一个管理重试和后续动作的拦截器，那么究竟是怎么做的呢？简单，上注释！</p>
<pre><code class="language-kotlin">//这个拦截器主要是用来处理失败和重定向的请求，如果请求被取消可能会抛出io异常 
/**
 * This interceptor recovers from failures and follows redirects as necessary. It may throw an
 * [IOException] if the call was canceled.
 */
</code></pre>
<p>看来前面的理解也没有问题，规范的命名确实能让人一看就知道什么意思。那直接进入正文。</p>
<h4 id="核心功能">核心功能</h4>
<ul>
<li>
<p>失败重试</p>
<ul>
<li>在遇到RouteException和IOException通过recover()方法判断当前请求是否可以重新尝试。</li>
</ul>
</li>
<li>
<p>继续发起请求</p>
<ul>
<li>
<p>通过followUpRequest()方法来判断当前是否可以继续发起请求，主要根据响应码来判断</p>
<table>
<thead>
<tr>
<th>应码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>07</td>
<td>代理鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>01</td>
<td>鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>07、308</td>
<td>重定向，method不为get 和head情况下 ，重新发起新的请求</td>
</tr>
<tr>
<td>00、301、302、303</td>
<td>重定向，重新发起新的请求</td>
</tr>
<tr>
<td>08</td>
<td>客户端请求超时，会继续发起新的请求</td>
</tr>
<tr>
<td>03</td>
<td>服务不可用，会继续发起新的请求</td>
</tr>
<tr>
<td>lse</td>
<td>直接发起新的请求</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：请求重试次数是受到MAX_FOLLOW_UPS 限制的，默认是20</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>经过前面文章的分析我们知道每一个拦截器都是在intercept里面操作的，那我们直接来分析一下：</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()
    //1
    val realChain = chain as RealInterceptorChain
    val transmitter = realChain.transmitter()
    var followUpCount = 0
    var priorResponse: Response? = null
    while (true) {
      //2
      transmitter.prepareToConnect(request)
      if (transmitter.isCanceled) {
        throw IOException(&quot;Canceled&quot;)
      }
      var response: Response
      var success = false
      try {
        //3
        response = realChain.proceed(request, transmitter, null)
        success = true
      } catch (e: RouteException) {
        // The attempt to connect via a route failed. The request will not have been sent.
        if (!recover(e.lastConnectException, transmitter, false, request)) {
          throw e.firstConnectException
        }
        continue
        //4
      } catch (e: IOException) {
        // An attempt to communicate with a server failed. The request may have been sent.
        val requestSendStarted = e !is ConnectionShutdownException
        if (!recover(e, transmitter, requestSendStarted, request)) throw e
        continue
      } finally {
        // The network call threw an exception. Release any resources.
        if (!success) {
          transmitter.exchangeDoneDueToException()
        }
      }
      // Attach the prior response if it exists. Such responses never have a body.
      if (priorResponse != null) {
        response = response.newBuilder()
            .priorResponse(priorResponse.newBuilder()
                .body(null)
                .build())
            .build()
      }
      val exchange = response.exchange
      val route = exchange?.connection()?.route()
      //5
      val followUp = followUpRequest(response, route)
      if (followUp == null) {
        if (exchange != null &amp;&amp; exchange.isDuplex) {
          transmitter.timeoutEarlyExit()
        }
        return response
      }
      val followUpBody = followUp.body
      //6
      if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {
        return response
      }
      response.body?.closeQuietly()
      if (transmitter.hasExchange()) {
        exchange?.detachWithViolence()
      }
      //7
      if (++followUpCount &gt; MAX_FOLLOW_UPS) {
        throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)
      }
      request = followUp
      priorResponse = response
    }
  }
</code></pre>
<h4 id="主要步骤">主要步骤</h4>
<ul>
<li>
<p>在上一篇文章中我们分析过，拦截器会通过构造RealInterceptorChain对象，并且把其作为参数通过调用当前interceptor的intercept方法来进行递归调用。并且也知道可以通过chain来获取到request、connection等对象。同样在重试拦截器中也是一样。第一步首先是拿到request 、realChain、transmitter对象。</p>
</li>
<li>
<p>进入到while循环中，首先调用transmitter的prepareToConnect方法。我们跟进去看一下：</p>
<pre><code class="language-kotlin">fun prepareToConnect(request: Request) {
    if (this.request != null) {
      if (this.request!!.url.canReuseConnectionFor(request.url) &amp;&amp; exchangeFinder!!.hasRouteToTry()) {
        return // Already ready.
      }
      check(exchange == null)
      if (exchangeFinder != null) {
        maybeReleaseConnection(null, true)
        exchangeFinder = null
      }
    }
    this.request = request
    this.exchangeFinder = ExchangeFinder(
        this, connectionPool, createAddress(request.url), call, eventListener)
  }
</code></pre>
<ul>
<li>不是第一次进入这个方法的时候
<ul>
<li>首先会判断是否可以服用连接池并且仍然处于重试过程中。</li>
<li>如果exchangeFinder不为空情况下 尝试关闭连接。并且回调eventListener connectionReleased方法，接着根据请求是否失败回调callFailed或者callEnd</li>
</ul>
</li>
<li>首次进入情况下
<ul>
<li>构建出exchangeFinder对象，为后续的网络连接做准备</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断请求是否被取消，如果取消抛出异常。</p>
<ul>
<li>
<pre><code class="language-kotlin">  fun cancel() {
    val exchangeToCancel: Exchange?
    val connectionToCancel: RealConnection?
    synchronized(connectionPool) {
      canceled = true
      exchangeToCancel = exchange
      connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
    }
    exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
  }
</code></pre>
</li>
</ul>
<p>通过调用链我们可以发现，这个方法只会在应用层通过Call对象的cancel方法调用到。</p>
</li>
<li>
<p>调用realChain的proceed方法</p>
<ul>
<li>
<p>还记得我们在上一篇文章中分析过这个方法其实是递归调用后续的拦截器并且将下一级的结果返回到当前处理。</p>
</li>
<li>
<p>通过try-catch 捕获在网络请求过程中可能出现的异常，如果未发生异常success为true，反之为false。</p>
<ul>
<li>
<p>RouteException</p>
<ul>
<li>异常发生在请求还没发出之前，追溯源码会发现其实是发生在connect过程中。</li>
</ul>
</li>
<li>
<p>IOException</p>
<ul>
<li>异常发生请求可能已经发出，并且在读取服务端的响应过程中出错。</li>
</ul>
</li>
<li>
<p>通过recover方法判断是否是值得重试的异常，判断依据如下：</p>
<pre><code class="language-kotlin"> private fun recover(
    e: IOException,
    transmitter: Transmitter,
    requestSendStarted: Boolean,
    userRequest: Request
  ): Boolean {
    // The application layer has forbidden retries.
    if (!client.retryOnConnectionFailure) return false
    // We can't send the request body again.
    if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false
    // This exception is fatal.
    if (!isRecoverable(e, requestSendStarted)) return false
    // No more routes to attempt.
    if (!transmitter.canRetry()) return false
    // For failure recovery, use the same route selector with a new connection.
    return true
  }
</code></pre>
<ul>
<li>
<p>应用层设置失败是否重试</p>
<figure data-type="image" tabindex="1"><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/WechatIMG133355.tiff" alt=""></figure>
</li>
<li>
<p>是否有相同的请求正在执行</p>
</li>
<li>
<p>是否是可恢复的异常</p>
</li>
<li>
<pre><code class="language-kotlin">private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean {
    if (e is ProtocolException) {
      return false
    }
    if (e is InterruptedIOException) {
      return e is SocketTimeoutException &amp;&amp; !requestSendStarted
    }
    if (e is SSLHandshakeException) {
      if (e.cause is CertificateException) {
        return false
      }
    }
    if (e is SSLPeerUnverifiedException) {
      return false
    }
    return true
  }
</code></pre>
<ul>
<li>
<p>ProtocolException 协议异常</p>
<p><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/1574337835415.jpg" alt="">主要发生在 RealConnection 中创建 HTTPS 通过 HTTP 代理进行连接重试超过 21 次。</p>
</li>
</ul>
</li>
<li>
<p>InterruptedIOException</p>
<ul>
<li>io终端异常，但是如果当前是一个连接超时异常，会进入到后续的判断，即根据响应码判断是否可重试。</li>
</ul>
</li>
<li>
<p>SSLHandshakeException</p>
<ul>
<li>https握手失败异常，不可重试。</li>
</ul>
</li>
<li>
<p>SSLPeerUnverifiedException</p>
<ul>
<li>网站的证书是不可信任的异常，不可重试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>是否已经失败过并且具有可以重试的route</p>
</li>
<li>
<p>如果请求未成功那么释放在上一次请求过程中的所有资源</p>
</li>
<li>
<p>从response中获取到 exchange、route对象。</p>
</li>
<li>
<p>调用followUpRequest方法 根据上次请求的返回码来确定是否需要重新尝试，关于响应码的分析在文章开头已经介绍过。</p>
</li>
<li>
<p>自增记录重试次数并且判断是否超过默认值</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>经过上面的分析我们可以知道：重试拦截器其实内部的逻辑还是有点小复杂的，首先定义了每个请求的最大默认尝试次数。然后在请求没有获取到响应时通过异常类型来判断是否可以继续重试。在获取到响应体阶段则是通过状态吗来判断。这里是不是更好理解：okhttp每个拦截器都是分为了Request阶段和Response阶段。到这里，我们对RetryAndFollowUpInterceptor的分析就告一段落了，下一章将会分析BridgeInterceptor。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5aa23fa46fb9a028cb2d3a96">源码分析三：OkHttp—RetryAndFollowUpInterceptor</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(二)getResponseWithInterceptorChain]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain">
        </link>
        <updated>2019-11-21T03:18:33.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>上一篇文章中我们简单的总结了ok发起请求并接收响应的整个流程，我们发现关键步骤是getResponseWithInterceptorChain这个方法。那这里面又做了什么事情呢？还是首先来看一下代码：</p>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  fun getResponseWithInterceptorChain(): Response {
    // Build a full stack of interceptors.
    val interceptors = mutableListOf&lt;Interceptor&gt;()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)

    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)

    var calledNoMoreExchanges = false
    try {
      val response = chain.proceed(originalRequest)
      if (transmitter.isCanceled) {
        response.closeQuietly()
        throw IOException(&quot;Canceled&quot;)
      }
      return response
    } catch (e: IOException) {
      calledNoMoreExchanges = true
      throw transmitter.noMoreExchanges(e) as Throwable
    } finally {
      if (!calledNoMoreExchanges) {
        transmitter.noMoreExchanges(null)
      }
    }
  }
</code></pre>
<p>可以说这个方法是整个okhttp的核心，通过这么几行代码就实现了整个请求的过程。这里不得不提到ok的拦截器机制。大多数人说到okhttp优秀的地方基本上都会脱口而出通过设置拦截器可以很方便的实现网络请求的打印、添加一些公共参数等等。而拦截器真正的运行其实就是在这个方法中。</p>
<ul>
<li>首先在interceptors中添加用户自定义的拦截器</li>
<li>然后按顺序添加各种系统内置的拦截器</li>
<li>通过RealInterceptorChain方法获取一个chain对象</li>
<li>通过chain.proceed获取response</li>
</ul>
<h4 id="拦截器">拦截器</h4>
<p>说了这么久的拦截器，肯定会好奇它究竟是个什么妖魔鬼怪：</p>
<pre><code class="language-kotlin">/**
 * Observes, modifies, and potentially short-circuits requests going out and the corresponding
 * responses coming back in. Typically interceptors add, remove, or transform headers on the request
 * or response.
 */
interface Interceptor {
  @Throws(IOException::class)
  fun intercept(chain: Chain): Response

  companion object {
    inline operator fun invoke(crossinline block: (chain: Chain) -&gt; Response): Interceptor =
        object : Interceptor {
          override fun intercept(chain: Chain) = block(chain)
        }
  }
  interface Chain {
    fun request(): Request

    @Throws(IOException::class)
    fun proceed(request: Request): Response
    fun connection(): Connection?
    fun call(): Call
    fun connectTimeoutMillis(): Int
    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
    fun readTimeoutMillis(): Int
    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
    fun writeTimeoutMillis(): Int
    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
  }
}

</code></pre>
<p>Interceptor实际上是一个接口，里面定义了一个intercept方法和chain的接口类。</p>
<h5 id="intercept">intercept</h5>
<p>关于intercept方法是不是很熟悉？我们在自定义拦截器的时候往往都是在这里面做一些瞎操作。</p>
<pre><code class="language-kotlin">   override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val realInterceptorChain = chain as RealInterceptorChain
        val transmitter = realInterceptorChain.transmitter()
        val response = realInterceptorChain.proceed(request, transmitter, null)
        return response

    }
</code></pre>
<ul>
<li>这里首先是通过chain.request获取请求的request对象</li>
<li>通过chain.proceed 递归调用下一个拦截器的intercept方法</li>
<li>最终返回chain.proceed的response到上一级拦截器</li>
</ul>
<h5 id="分层">分层</h5>
<p>这里其实是将每个拦截器分为了两个阶段：</p>
<ul>
<li>Request阶段：执行该拦截器在请求前做的事，例如：bridgeInterceptor添加一些请求参数</li>
<li>Response阶段：执行拦截器在获取响应之后做的事，例如：打印出请求体的返回</li>
</ul>
<p>拦截器的设计其实是采用了递归调用的思想，仔细想想其实是非常巧妙的，这样可以保证不论是系统内置还是用户自定义的拦截器都可以得到最终执行。如果在某个拦截器中出现了错误，还可以把错误抛给上一层来处理。</p>
<h5 id="内置拦截器">内置拦截器</h5>
<p>通过剖析源码我们会发现,ok内部其实是帮我们内置了好几种拦截器，每次请求都会添加进去，我们按照添加顺序整理如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截器</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RetryAndFollowUpInterceptor</td>
<td style="text-align:center">负责实现重定向功能</td>
</tr>
<tr>
<td style="text-align:center">BridgeInterceptor</td>
<td style="text-align:center">将用户构造的请求转换为向服务器发送的请求，将服务器返回的响应转换为对用户友好的响应</td>
</tr>
<tr>
<td style="text-align:center">CacheInterceptor</td>
<td style="text-align:center">读取缓存、更新缓存</td>
</tr>
<tr>
<td style="text-align:center">ConnectInterceptor</td>
<td style="text-align:center">建立与服务器的连接</td>
</tr>
<tr>
<td style="text-align:center">CallServerInterceptor</td>
<td style="text-align:center">从服务器读取响应</td>
</tr>
</tbody>
</table>
<p>可以看出，整个网络请求的过程是通过各个拦截器相互配合来实现，假如我们在网络请求过程中设置允许缓存，那么在请求网络之前会预先获取缓存，然后再去跟服务器建立连接。通过拦截器的机制，我们可以很方便的控制整个网络请求的过程以及添加我们自己的拓展。</p>
<p>整个网络请求过程中，用户其实是可以添加两种不同类型的拦截器的。</p>
<ul>
<li>通过 addInterceptor()在网络请求前后添加拦截器</li>
<li>通过networkInterceptors()在获取响应前后添加拦截器</li>
</ul>
<p>这一点在getResponseWithInterceptorChain（）方法中添加拦截器的顺序是可以分析出来的。</p>
<h5 id="整体流程">整体流程</h5>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/21/16e8bf6522fc07a5?w=1064&amp;h=1004&amp;f=jpeg&amp;s=89681" alt=""><br>
图片来源:https://blog.n0texpecterr0r.cn/?p=717</p>
<h4 id="realinterceptorchain">RealInterceptorChain</h4>
<p>经过上面的分析我们知道okhttp的实际请求和响应过程是通过一个个拦截器的递归调用来实现的。主要方法就是</p>
<p>realInterceptorChain.proceed。我们先来看一下RealInterceptorChain的构造方法</p>
<pre><code class="language-kotlin">class RealInterceptorChain(
  private val interceptors: List&lt;Interceptor&gt;,
  private val transmitter: Transmitter,
  private val exchange: Exchange?,
  private val index: Int,
  private val request: Request,
  private val call: Call,
  private val connectTimeout: Int,
  private val readTimeout: Int,
  private val writeTimeout: Int
) 
</code></pre>
<p>这里其实是将上一个拦截器的一些参数传递进来并且赋值的简单实现。包括所有的拦截器、以及我们在第一篇文章提到的transmitter等。整个类中最关键的还是proceed方法</p>
<pre><code class="language-kotlin">  @Throws(IOException::class)
  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
    if (index &gt;= interceptors.size) throw AssertionError()
    calls++
    // If we already have a stream, confirm that the incoming request will use it.
    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
      &quot;network interceptor ${interceptors[index - 1]} must retain the same host and port&quot;
    }
    // If we already have a stream, confirm that this is the only call to chain.proceed().
    check(this.exchange == null || calls &lt;= 1) {
      &quot;network interceptor ${interceptors[index - 1]} must call proceed() exactly once&quot;
    }
    // Call the next interceptor in the chain.
    val next = RealInterceptorChain(interceptors, transmitter, exchange,
        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
    val interceptor = interceptors[index]
    @Suppress(&quot;USELESS_ELVIS&quot;)
    val response = interceptor.intercept(next) ?: throw NullPointerException(
        &quot;interceptor $interceptor returned null&quot;)
    // Confirm that the next interceptor made its required call to chain.proceed().
    check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) {
      &quot;network interceptor $interceptor must call proceed() exactly once&quot;
    }
    check(response.body != null) { &quot;interceptor $interceptor returned a response with no body&quot; }
    return response
  }
</code></pre>
<p>可以看到这个方法中除了大量的判读逻辑，比较关键的就是通过index+1取到下一个RealInterceptorChain对象 。</p>
<p>然后获取当前的拦截器并且调用其intercept方法 ，方法参数中传入了下一个拦截器的对应的chain。就是这样通过递归调用的设计，实现了由上而下，再由下而上实现了递与归的过程。从而非常漂亮的实现了http请求的全链路。</p>
<p>看到这里有没有觉得这种设计模式很熟悉，没错就是责任链模式。这种设计模式在一个流程会有多种操作的业务场景下会非常实用。</p>
<h4 id="总结">总结</h4>
<p>本篇文章我们主要是分析了整个网络请求过程中非常重要的getResponseWithInterceptorChain()方法，内部通过责任链的模式递归调用用户自定义拦截器和内置拦截器来完成整个网络请求。通过对整个方法的分析，我们会更清晰的知道ok内部是怎么实现通过设置拦截器来完成我们想要的功能的。同时也是我们学习责任链模式非常好的实践。后续文章将逐个分析ok内置拦截器的具体作用。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://blog.n0texpecterr0r.cn/?p=717">OkHttp 源码剖析系列（一）——请求的发起及拦截器机制概述</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(一)流程概述]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-yi-liu-cheng-gai-shu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-yi-liu-cheng-gai-shu">
        </link>
        <updated>2019-11-21T01:40:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="写在前面">写在前面</h4>
<p>本人从事Android开发工作几年，也算是见证了Android的技术变革。拿网络库来讲从最开始使用的xUtils到 <a href="https://github.com/google/volley">volley</a>然后到现在主流的<a href="https://github.com/square/okhttp">okhttp</a>。更不要说热更新、插件化、以及路由开发模式的大行其道。有感于工作中大多时候是仅限于使用,于是打算写一系列关于Android开发中使用到的框架解析，也算是对自己理解的一个记录。</p>
<h4 id="正文">正文</h4>
<p>网上看到一个观点：当我们想深入了解一个框架的时候，第一步是要会用，然后按照框架的流程图一步一步的去慢慢的探索分析。对于这个观点笔者是非常赞同的，优秀的框架都是有清晰的架构、核心思想也都采用了优秀的设计模式。下面我们从okhttp开始分析</p>
<ul>
<li>本系列文章基于okhttp4.2.2 (官方已使用kotlin进行重写)</li>
</ul>
<h3 id="发起一次简单的请求">发起一次简单的请求</h3>
<p>任何框架的学习第一步都是从会用开始，下面我们开始使用OKHTTP构建一个简单的访问百度的请求。</p>
<pre><code class="language-kotlin">   private fun makeCall() {
        val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .build()
        val request = Request.Builder()
            .url(&quot;http://www.baidu.com&quot;)
            .get()
            .build()
        okHttpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
            }

            override fun onResponse(call: Call, response: Response) {
            }
        })

    }
</code></pre>
<p>可以看到我们首先构造一个okhttpClient出来并设置一些超时时间、通过request设置请求的域名和请求方法。最后通过enqueue异步、或者excute同步的方式去进行请求。请求结果会通过接口回调的方式返回。</p>
<h4 id="okhttpclient">OkHttpClient</h4>
<p>字面意思非常好理解，okhttp的客户端。首先来看一下client的类注释。大概意思如下:</p>
<table><tr><td >
使用的时候最好构建一个单例的client去复用到所有的网络请求，因为每个client都会持有它自己的连接池和线程池。复用连接池可以减少延迟并且可以减少内存的消耗，同时通过newBuilder()方法构造出来的client可以很方便的共享一些配置如：connectTimeOut等
<br></br>
Tips:看到上面的注释，网络优化角度为什么要复用连接池也就可以很明白的理解了。
<td><tr></table>
<p>okhttpclient是通过建造者模式构造出来，上面的示例我们发现真正在使用的时候需要我们设置的项并不多，但其实client在构造的时候是有很多参数可以设置。</p>
<pre><code class="language-kotlin">    //异步请求什么时候执行的策略管理器
    internal var dispatcher: Dispatcher = Dispatcher()
    //管理http请求的连接来降低网络延迟的类
    internal var connectionPool: ConnectionPool = ConnectionPool()
    //一个网络请求拦截器
    internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //网络部分拦截器
    internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //整个网络流程的监听器、我们可以通过设置整个监听来感知网络请求的质量、响应体大小以及持续时长等等。
    internal var eventListenerFactory: EventListener.Factory =      EventListener.NONE.asFactory()
    //连接失败时候是否重试
    internal var retryOnConnectionFailure = true
    //暂时没看懂是干嘛的，默认值是不添加，日常开发中也不会用到
    internal var authenticator: Authenticator = Authenticator.NONE
    //是否可以重定向
    internal var followRedirects = true
    //ssl是否可以重定向
    internal var followSslRedirects = true
    //这个字面意思理解就可以了 一般在请求中需要加入用户的token的时候会用到 默认是没有cookie
    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
    //网络请求的缓存策略
    internal var cache: Cache? = null
    //dns 一个网络请求过程中 会首先把域名解析成ip 这样客户端才知道往什么地址发起请求。
    internal var dns: Dns = Dns.SYSTEM
    //设置代理 
    internal var proxy: Proxy? = null
    //代理选择器 
    internal var proxySelector: ProxySelector? = null
    //跟上面一样  属于代理ip的一个属性
    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
    //socket 工厂 
    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
    //https 的socket 
    internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
    //证书信任管理器，一般为了防止https 握手失败我们会设置信任所有的证书
    internal var x509TrustManagerOrNull: X509TrustManager? = null
    //连接说明 指定socket连接时的一些配置 如：https还是http或者TLS的版本、密码来保证安全的连接
    internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS
    //连接时选择的协议 HTTP_1_0、HTTP_1_1、HTTP_2等
    internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS
    //域名验证的具体接口实现。如果客户端跟服务端的hostName不一致的时候选择是否接受的策略
    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
    //按照我的理解是用于信任加入中间代理 如charles这种的代理
    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
    //用于计算高效的证书链
    internal var certificateChainCleaner: CertificateChainCleaner? = null
    //调用超时时间
    internal var callTimeout = 0
    //连接超时时间 10_000 挺有意思的 是kotlin里面特有的写法
    internal var connectTimeout = 10_000
    //读数据超时时间
    internal var readTimeout = 10_000
    //写入流数超时时间
    internal var writeTimeout = 10_000
    //ping的间隔
    internal var pingInterval = 0
</code></pre>
<p>从上面可以看出其实okhttp内部帮我们封装了很多可以修改的配置，参数一般有默认值，通过建造者模式我们可以选择性的设置我们想要的配置。okhttp也是我们学习这种设计模式的一个比较好的实践。</p>
<p>构建client之后，我们会通过newCall方法传入一个Request 构造出一个Call.</p>
<pre><code class="language-kotlin"> override fun newCall(request: Request): Call {
    return RealCall.newRealCall(this, request, forWebSocket = false)
  }
</code></pre>
<h4 id="request">Request</h4>
<p>request字面意思就是请求的意思，那么一个请求会包含哪些信息呢？我们进去源码会发现其同样也是通过builder模式构建的。</p>
<pre><code class="language-kotlin">    internal var url: HttpUrl? = null
    internal var method: String
    internal var headers: Headers.Builder
    internal var body: RequestBody? = null
</code></pre>
<p>可以发现相对于client，request只有简单的几个参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:center">代表此次请求的链接</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:center">代表当前请求的方法。如post、get、delete等</td>
</tr>
<tr>
<td style="text-align:left">headers</td>
<td style="text-align:center">一次请求中的头文件</td>
</tr>
<tr>
<td style="text-align:left">body</td>
<td style="text-align:center">请求体</td>
</tr>
</tbody>
</table>
<h4 id="call">Call</h4>
<p>我们通过client.newCall()方法构造出来了一个call对象 。实际上是调用了RealCall.newRealCall(this, request, forWebSocket = false).第三个参数是代表不支持webSocket，因为本身是http请求。这点在构建request时HttpUrl类也会有相同的判断，直接把webSocket转换为http请求。具体的使用socket的场景在后续会进行分析。</p>
<p>我们继续往下面看 newCall()方法到底做了什么事情:</p>
<pre><code class="language-kotlin">  fun newRealCall(
      client: OkHttpClient,
      originalRequest: Request,
      forWebSocket: Boolean
    ): RealCall {
      // Safely publish the Call instance to the EventListener.
      return RealCall(client, originalRequest, forWebSocket).apply {
        transmitter = Transmitter(client, this)
      }
    }
</code></pre>
<p>通过RealCall的构造方法实例出来一个realCall对象，字面意思可以知道后续的请求实际上是调用的realCall的对象。同时初始化了一个Transmitter。</p>
<h4 id="transmitter">Transmitter</h4>
<table><tr><td bgcolor=#f7f6f3>
应用层和网络层之间的桥梁，对外暴露了像connections/requests/responses/streams 所以我们可以方便的拿到这些对象做操作。再结合拦截器的作用也就很好理解了
</td></tr></table>
<h4 id="请求流程">请求流程</h4>
<p>我们知道okhttp是支持同步excute和异步enqueue的，那么内部究竟是怎么处理的呢？Android在某个版本之后已经不允许直接在主线程中进行网络请求了，所以我们这里直接分析异步请求的过程. 我们之前通过client.newCall已经构造出来Call对象。直接使用call.enqueue()就可以发起请求。Call定义的enqueue方法只是一个接口，具体实现是realCall中</p>
<pre><code class="language-kotlin">  override fun enqueue(responseCallback: Callback) {
    synchronized(this) {
      //首先会进行防止重复请求的判断
      check(!executed) { &quot;Already Executed&quot; }
      executed = true
    }
   //追溯进去会发现这步是回调eventListener的callStart方法，前文在介绍okhttpclient的构造方法时有提到过
    transmitter.callStart()
    //这里是请求真正发起的地方 
    client.dispatcher.enqueue(AsyncCall(responseCallback))
  }
</code></pre>
<h5 id="dispatcher">Dispatcher</h5>
<p>我们发现真正发起请求的地方是调用client里面的dispathcer对象执行enqueue方法，那dispatcher是什么鬼东东呢？我们继续来看注释：</p>
<pre><code class="language-kotlin">Policy on when async requests are executed.
用于管理异步请求什么时候执行的策略管理器
Each dispatcher uses an [ExecutorService] to run calls internally. If you supply your own
executor, it should be able to run [the configured maximum][maxRequests] number of calls concurrently.
每个dispatcher本质上是使用ExecutorService来进行请求的调用。
根据上面的注释我们还知道每个dispatcher其实是定义了一个最大请求并发数，默认是64
</code></pre>
<p>继续回到我们的主题:</p>
<pre><code class="language-kotlin">internal fun enqueue(call: AsyncCall) {
    synchronized(this) {
      readyAsyncCalls.add(call)
			
      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
      // the same host.
      if (!call.get().forWebSocket) {
        val existingCall = findExistingCallWithHost(call.host())
        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
      }
    }
    promoteAndExecute()
  }
</code></pre>
<p>首先是使用了同步锁来保证线程同步,然后把当前请求对象添加到了一个ArrayDeque双端队列里。</p>
<pre><code class="language-kotlin">  /** Ready async calls in the order they'll be run. */
  private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()

  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
  private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()

  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
  private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;()
</code></pre>
<p>我们可以看到ok其实是定义了三个双端队列：</p>
<ul>
<li>异步请求等待队列</li>
<li>异步请求执行队列</li>
<li>同步请求执行队列</li>
</ul>
<p>首先执行的异步请求必须不是webSocket的类型才继续往下走，下一步是寻找是否存在相同host的请求。这里是通过原子类型来保证相同host的请求可以准确记录下来。接着调用promoteAndExecute()来进行请求；</p>
<h5 id="promoteandexecute">promoteAndExecute</h5>
<pre><code class="language-kotlin">private fun promoteAndExecute(): Boolean {
  	//这里的写法很有意思，通过kotlin的assert来进行判断 不满足条件抛出一个异常，后续的开发其实可以借鉴。
    assert(!Thread.holdsLock(this))
  //构建一个空的AsyncCall list,AsyncCall 其实是自定义的runnable
    val executableCalls = mutableListOf&lt;AsyncCall&gt;()
    val isRunning: Boolean
    synchronized(this) {
      val i = readyAsyncCalls.iterator()
      while (i.hasNext()) {
        val asyncCall = i.next()

        if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity.
        if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // Host max capacity.

        i.remove()
        asyncCall.callsPerHost().incrementAndGet()
        executableCalls.add(asyncCall)
        runningAsyncCalls.add(asyncCall)
      }
      isRunning = runningCallsCount() &gt; 0
    }

    for (i in 0 until executableCalls.size) {
      val asyncCall = executableCalls[i]
      asyncCall.executeOn(executorService)
    }

    return isRunning
  }
</code></pre>
<p>大概总结一下这个方法做了什么事情:</p>
<ul>
<li>
<p>从上文说的异步请求准备队列中通过迭代的方式取出请求任务</p>
</li>
<li>
<p>判断并发请求是否超过最大数量</p>
</li>
<li>
<p>往计数器中增加一次计数</p>
</li>
<li>
<p>将call对象添加到executableCalls 以及 异步请求执行队列中</p>
</li>
<li>
<p>循环从executableCalls 取出asyncCall对象调用executeOn()方法</p>
</li>
</ul>
<h5 id="executeon">executeOn</h5>
<pre><code class="language-kotlin">   fun executeOn(executorService: ExecutorService) {
      assert(!Thread.holdsLock(client.dispatcher))
      var success = false
      try {
        executorService.execute(this)
        success = true
      } catch (e: RejectedExecutionException) {
        val ioException = InterruptedIOException(&quot;executor rejected&quot;)
        ioException.initCause(e)
        transmitter.noMoreExchanges(ioException)
        responseCallback.onFailure(this@RealCall, ioException)
      } finally {
        if (!success) {
          client.dispatcher.finished(this) // This call is no longer running!
        }
      }
    }
</code></pre>
<p>分析到这里已经很明确了，executeOn方法是通过executorService的execute()方法来执行一次异步请求。如果请求中抛出异常那么会调用dispatcher的finish方法来结束本次请求。</p>
<p>既然是通过异步执行，我们再来看一下run方法</p>
<pre><code class="language-kotlin">   override fun run() {
      threadName(&quot;OkHttp ${redactedUrl()}&quot;) {
        var signalledCallback = false
        transmitter.timeoutEnter()
        try {
          val response = getResponseWithInterceptorChain()
          signalledCallback = true
          responseCallback.onResponse(this@RealCall, response)
        } catch (e: IOException) {
          if (signalledCallback) {
            // Do not signal the callback twice!
            Platform.get().log(INFO, &quot;Callback failure for ${toLoggableString()}&quot;, e)
          } else {
            responseCallback.onFailure(this@RealCall, e)
          }
        } finally {
          client.dispatcher.finished(this)
        }
      }
    }
</code></pre>
<p>代码也同样很精简：</p>
<ul>
<li>
<p>通过getResponseWithInterceptorChain()方法来获取请求的响应体（关于这个方法将在后续文章详细分析）</p>
</li>
<li>
<p>通过接口回调将本次请求结果一层层回调给调用类</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上基本上是客户端构建请求、发起请求、以及请求的整体流程。我们可以大概整理一下整个流程做了哪些关键的步骤：</p>
<ul>
<li>
<p>客户端通过builder模式构建一个okHttpClient对象</p>
</li>
<li>
<p>客户端通过builder模式构建一个Request对象</p>
</li>
<li>
<p>通过okHttpClient.newCall(request:Request)方法来创建一个Call对象</p>
</li>
<li>
<p>通过call.enqueue(callBack:CallBack)来发起一次异步请求</p>
</li>
<li>
<p>请求时候是通过ExecutorService调用execute()方法来执行</p>
</li>
<li>
<p>最终拿到响应体回调给客户端</p>
</li>
</ul>
<p>当然真正请求的内部流程其实是要复杂的多，上面只是粗略的整理了一下，但是熟悉整个流程对于后面我们进入到okhttp核心代码分析的时候会更加有助于我们理解。以上就是okhttp源码分析的第一篇文章，后面会对每一步进行更详细的分析。</p>
]]></content>
    </entry>
</feed>