<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-11-05T06:56:31.874Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[Android开发板上TeamViewer的自动绑定]]></title>
        <id>https://alsowell.github.io//post/android-kai-fa-ban-shang-teamviewer-de-zi-dong-bang-ding</id>
        <link href="https://alsowell.github.io//post/android-kai-fa-ban-shang-teamviewer-de-zi-dong-bang-ding">
        </link>
        <updated>2019-11-05T01:44:52.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572920857956.png" alt=""></figure>
<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572920857956.png" alt=""></figure>
<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
<!-- more -->
<p>  正常面对这种需求当然首先去找官方文档，但是翻遍Teamviewer提供的api接口也没有找到相关的实现;没办法只好拨打官方提供的技术支持电话进行咨询，经过了无数次的等待终于接通，但是技术人员的回复是不提供这个功能。</p>
<p>  在官方支持无果的情况下，笔者只好寻找其他的解决思路，通常面对这种问题第一个解决思路是通过抓包去分析绑定流程的数据传输进行解决。拿到所属账户的用户id以及设置的唯一标识：AndroidID去进行模拟绑定。</p>
<p>调起应用：</p>
<figure data-type="image" tabindex="2"><img src="https://alsowell.github.io//post-images/1572922168223.jpg" alt=""></figure>
<p>点击分配：</p>
<figure data-type="image" tabindex="3"><img src="https://alsowell.github.io//post-images/1572922822275.jpg" alt=""></figure>
<p>分配成功:</p>
<figure data-type="image" tabindex="4"><img src="https://alsowell.github.io//post-images/1572922885806.jpg" alt=""></figure>
<p>  注：笔者公司绑定TeamViewer的方式为通过打开teamviewer分配的固定的url链接通过浏览器调起Teamviewer应用进行绑定。</p>
<p>  通过抓包可以发现绑定时候去先获取当前机器所属的账户组，然后点击分配按钮时通过获取当前机器的信息去服务器进行当前账户的分配。分配成功后会返回当前机器的远程id和连接时候的密码。<br>
分析到这里好像已经解决了我们的需求。但是理想很丰满，现实很骨感。一顿骚操作以后发现模拟数据去请求后台也并不能在后台显示这台绑定的设备，这种方法宣告失败。</p>
<p>  我们再回头分析一下,Teamviewer内部的绑定并不是透明的，我们仅仅通过抓包的数据去进行hook好像并不代表它内部的所有流程。可能在进行网络请求后还进行了其他的操作，但是我们并不能知道。分析到这里下一步好像应该去做反编译去获取到它内部的流程操作。但是笔者再一顿骚操作后发现其内部进行了混淆，并且之前对反编译也没有什么研究，那么这种解决思路暂时先放一放。</p>
<p>  我们再分析一下正常绑定的流程，手动打开一个链接-&gt;通过浏览器调起应用-&gt;点击应用内的分配按钮-&gt;分配成功。整个过程关键的一步是手动点击按钮去实现。机智的你可能已经知道我们下一步的思路是通过模拟点击去进行自动绑定的实现。</p>
<p>  但是模拟点击的实现有个问题，我们不可能每次开机以后都去进行一次模拟点击的操作，在已经绑定的情况下再去做重复的点击无疑是多此一举。那么就需要去分析是否已经绑定过，正常的思路有两个：</p>
<ul>
<li>通过api去获取当前机器是否已经绑定</li>
<li>本地是否有数据记录是否绑定</li>
</ul>
<p>  毫无疑问去分析本地数据会更快一点，再结合之前说到的情况：机器恢复出厂设置的情况下已经绑定的远程会失效。那么我们可以分析得知本地肯定会存储一些必要的数据。那我们直接去data/data 里面去找一下。找了半天，终于在/data/data/com.teamviewer.host.market/files/global.conf路径下面发现了点东西。</p>
<figure data-type="image" tabindex="5"><img src="https://alsowell.github.io//post-images/1572931170363.jpg" alt=""></figure>
<!-- more -->
<p>  可以发现OwningManagerAccountName和OwningManagerCompanyName表示当前所属账户信息的。在没有绑定的情况下这两个字段是不存在的。那么问题就解决了。在每次开机时通过判断这两个字段是否去需要绑定。<br>
  是否绑定的问题已经解决了，那么接下来就到了重点。上面的流程分析提到：显示弹窗-&gt;点击弹窗——&gt;绑定完成。首先是判断是否已经进入到绑定的承载界面:</p>
<pre><code class="language-kotlin">    private fun getTopService(): Boolean {
        val exec = Shell(true).exec(&quot;dumpsys activity | grep  mFocusedActivity&quot;)
        return exec.message.contains(&quot;com.teamviewer.host.ui.HostActivity&quot;)
    }
</code></pre>
<h3 id="判断弹窗">判断弹窗</h3>
<p>  通过获取位于栈顶的进程来判断是否浏览器成功调起应用，然后是判断弹窗是否显示以及按钮的位置，方法比较多：1.我们知道Android的窗口都是通过WinddowManager来管理的，WindowManager是一种方式；<br>
2.另外一种方法是通过uiautomatorviewer来获取。这里着重讲一下uiautomatorviewer的方式。平常在开发过程中我们经常会使用Android sdk tools下面的uiautomatorviewer来获取当前屏幕正在显示的View层级关系以及所属位置。<br>
<img src="https://alsowell.github.io//post-images/1572934681994.jpg" alt=""><br>
<img src="https://alsowell.github.io//post-images/1572934977185.jpg" alt=""></p>
<p>  同样的我们可以直接在Android 的shell环境下直接执行</p>
<pre><code class="language-kotlin"> Shell(true).exec(&quot;uiautomator dump&quot;)
</code></pre>
<p>  执行这个命令，会直接在sdcard下生成一个window_dump.xml文件。我们通过解析xml分析出来当前是否处于弹窗状态以及需要模拟点击的按钮位置。</p>
<h3 id="模拟点击">模拟点击</h3>
<p>  说到模拟点击，你脑子里第一个想到的是什么？大多数情况下可能想到的都是AccessibilityService。AccessibilityService根据官方的介绍，是指开发者通过增加类似contentDescription的属性，从而在不修改代码的情况下，让残障人士能够获得使用体验的优化，大家可以打开AccessibilityService来试一下，点击区域，可以有语音或者触摸的提示，帮助残障人士使用App（这段介绍是我抄的）。但是AccessibilityService使用的前提是需要用户手动授权，Android默认是关闭的，对于笔者的业务场景是无法满足需求的。</p>
<p>  那可以考虑另外一种思路，直接输入input事件。我们在平常开发中经常会用到adb shell input tap xx xx 来表示一个点击事件。xx xx 代表Android坐标系下的坐标。同样的还有swipe代表滑动。插一句题外话 adb shell 工具使用的好对于平常的开发是大有裨益的。</p>
<pre><code class="language-kotlin">Shell(true).exec(&quot;input tap xxx xxx&quot;)
</code></pre>
<p>  到此，我们已经解决了模拟点击的步骤。点击完成再去本地文件中看一下发现所属的账户信息已经写入成功了。同时在后台也发现了这台设备已经在线，可以愉快的连接上去搞事情啦。</p>
<h3 id="总结">总结</h3>
<p>  以上就是笔者面对这个需求从懵逼到最后实现的过程整个需求的实现过程。事后看来有很多没有按照Android开发规范来进行操作，如获取弹窗是直接dump出xml来进行解析而不是通过WindowManager来进行操作。但是想分享的是整个需求的实现思路。希望能对你有一点点帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android H5容器&WebView的一些优化]]></title>
        <id>https://alsowell.github.io//post/android-webview</id>
        <link href="https://alsowell.github.io//post/android-webview">
        </link>
        <updated>2019-11-04T11:45:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-h5容器">Android H5容器</h1>
<p>     WebView是android上面加载h5界面的基础组件。4.4之前使用webkit作为内核,之后采用Chromium内核。高版本的内核在性能以及流畅性方面均会有较大提升。</p>
<p>    android上查看当前WebView内核版本的两种方式：</p>
<ul>
<li>chrome浏览器输入  chrome://inspect</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572868102476.png" alt=""></figure>
<ul>
<li>adb shell am start -a android.intent.action.VIEW -d  https://liulanmi.com/labs/core.html<br>
<img src="https://alsowell.github.io//post-images/1572868135876.png" alt=""></li>
</ul>
<h3 id="性能优化">性能优化</h3>
<p>    一个正常的natvie使用WebView加载网页的流程如下:<br>
<img src="https://alsowell.github.io//post-images/1572868151124.png" alt=""></p>
<p>    接下来将围绕整个WebView加载流程来进行android端的一些优化。</p>
<h4 id="webview单独进程进行加载">webview单独进程进行加载</h4>
<p>     WebView采用单独进程进行,App中大量Web页面的使用容易导致App内存占用巨大，存在内存泄露，崩溃率高等问题，WebView独立进程的使用是解决Android WebView相关问题的一个合理的方案。</p>
<p>    下图为加载WebView前后内存占用对比（仅打开百度首页）,可以观察,对大内存应用来讲WebView在不断打开网页过程中产生的内存极有可能造成OOM.</p>
<ul>
<li>未加载webview<br>
<img src="https://alsowell.github.io//post-images/1572868163142.png" alt=""></li>
<li>webview打开百度<br>
<img src="https://alsowell.github.io//post-images/1572868178190.png" alt=""></li>
</ul>
<p>     主流的方案都是直接采用新开activity单独进程进行WebView加载方案来进行优化。但是针对于单Activity+多fragment架构中,此方案就不能采用在Activity中开启多进程的方式来进行优化。</p>
<p>    开启多进程的方式有两种：</p>
<ul>
<li>通过在manifest中声明的方式开启。</li>
<li>通过Jni fork的方式产生,此方式难度较大。</li>
</ul>
<p>    考虑到Android四大组件中均可以通过声明的方式进行多进程的创建,可采用在service中动态创建WebView 然后动态添加到WindowManager中（此步需要有悬浮窗权限）。</p>
<h4 id="预加载优化">预加载优化</h4>
<p>    关于WebView加载耗时,分别测试直接加载webview预先加载webview时间对比。</p>
<ul>
<li>直接加载webview
<ul>
<li>通过动态添加view形式模拟webview启动耗时</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">			val startTime = System.currentTimeMillis()
            val webView = WebView(this)
            cl.addView(webView)
            val layoutParams = webView.layoutParams
            layoutParams.width=ViewGroup.LayoutParams.MATCH_PARENT
            layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT
            webView.layoutParams=layoutParams
            webView.loadUrl(&quot;http://www.baidu.com&quot;)
            webView.webViewClient = object : WebViewClient() {
                override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                    super.onPageStarted(view, url, favicon)
                    val loadTime = System.currentTimeMillis() - startTime
                    Log.d(TAG,&quot;time:$loadTime&quot;)
                }
            }

06-27 16:58:22.353 30779-30779/? D/WebViewLoad: time:488

</code></pre>
<ul>
<li>预加载WebView性能
<ul>
<li>通过预先在service中预先加载一个WebView</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">

val startTime = System.currentTimeMillis()
Log.d(TAG,&quot;preLoad start:$startTime&quot;)
val intent = Intent(this, WebViewService::class.java)
intent.action = &quot;load&quot;
startService(intent)

// service代码

if (intent?.action == &quot;load&quot;) {
 webview.webViewClient= object : WebViewClient() {
 override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
 super.onPageStarted(view, url, favicon)
 Log.d(&quot;WebViewLoad&quot;, &quot;当前时间：${System.currentTimeMillis()}&quot;)
             }
       }
webview.loadUrl(&quot;http://www.baidu.com&quot;)
}

06-27 17:22:11.606 19569-19569/net.example.webview D/WebViewLoad: preLoad start:1561627331606
06-27 17:22:11.642 19569-19569/net.example.webview D/WebViewLoad: 当前时间：1561627331642
result:36
</code></pre>
<p>    可以看到WebView的动态加载创建会耗费大量时间,因此在Android端可以全局创建一个WebView避免重复的资源开销,但随之而来伴随着可能造成的内存泄露需要在开发时注意。</p>
<h4 id="缓存优化">缓存优化</h4>
<p>    打开H5网页的过程中往往伴随着大量的js请求以及图片等占用网络的请求,并且每个请求都是串行进行的,这样的实现不仅耗费流量并且在网络情况不佳的情况下对用户带来的观感就是极其影响体验。<br>
    Android WebView本身已经支持5种缓存策略。</p>
<ul>
<li>浏览器 缓存机制</li>
<li>Application Cache 缓存机制</li>
<li>Dom Storage 缓存机制</li>
<li>Web SQL Database 缓存机制</li>
<li>Indexed Database 缓存机制</li>
</ul>
<p>    对于Android开发来说设置缓存最常用的方式是<br>
获取WebView的setting设置缓存模式</p>
<pre><code class="language-kotlin">	WebSettings.LOAD_DEFAULT
	WebSettings.LOAD_NO_CACHE
	WebSettings.LOAD_CACHE_ELSE_NETWORK
	WebSettings.LOAD_CACHE_ONLY
    WebSettings.LOAD_NO_CACHE
   
</code></pre>
<p>缓存模式具体分析<a href="https://www.jianshu.com/p/5e7075f4875f">参考</a></p>
<p>    Android端如何实现一套更自己可控制的缓存方案,H5页面中每个网络请求的均会回调</p>
<pre><code class="language-kotlin">override fun shouldInterceptRequest(view: WebView?, request: WebResourceRequest?): WebResourceResponse?
</code></pre>
<ul>
<li>优化方案
<ul>
<li>通过重写shouldInterceptRequest方法对特定资源进行本地文件缓存复用</li>
<li>实现方案
<ul>
<li>针对特定类型后缀文件HTML、Javascript、CSS、png等网络请求进行拦截使用nativie本身okhttp等网络框架库,同时针对下载文件进行本地缓存策略管理 如：LruDiskCache</li>
<li>h5端逻辑代码 js、cs变更如果未变更链接 此时代码仍然不是最新,此方案需要跟前端约定好版本概念。</li>
<li>shouldInterceptRequest是WebView维护线程进行异步请求，所以可以放心耗时操作</li>
</ul>
</li>
<li>具体优化实现<a href="https://github.com/yale8848/CacheWebView">可参考CacheWebView</a></li>
</ul>
</li>
</ul>
<h4 id="jsbridge">JsBridge</h4>
<ul>
<li>
<p>Android和Js通过WebView.addJavascriptInterface()进行映射</p>
<ul>
<li>
<p>Android端 需要在设置WebSetting是允许调用js方法,然后通过动态注册的方式把natvie提供的方法注册进bridge中</p>
<ul>
<li>settings.javaScriptEnabled=true</li>
<li>webView.addJavascriptInterface()</li>
</ul>
<pre><code class="language-kotlin">
web_view.addJavascriptInterface(JsInterface(), &quot;client&quot;)

inner class JsInterface {
@JavascriptInterface
fun backToMall() {
    runOnUiThread {
        Toast.makeText(this@MainActivity,&quot;back&quot;,Toast.LENGTH_SHORT).show()
    }
    Log.d(&quot;bigScreen&quot;, &quot;返回拍照&quot;)
    val open = LauncherHelper.instance.open(&quot;net.changjinglu.mall&quot;, &quot;net.changjinglu.mall.HomeActivity&quot;)
    if (open == 0) {
        Log.d(&quot;bigScreen&quot;, &quot;跳转成功&quot;)
        destroyWebView()
    } else {
        Log.d(&quot;bigScreen&quot;, &quot;跳转失败 返回:$open&quot;)
    }
}
@JavascriptInterface
fun loadComplete() {
    Log.d(&quot;bigScreen&quot;, &quot;页面加载完成&quot;)
    hasLoadSuccess.set(true)
}
</code></pre>
</li>
</ul>
<p>}</p>
<pre><code>  ```
</code></pre>
<ul>
<li>
<p>JS端调用</p>
<pre><code class="language-javascript">window.client.loadComplete()

</code></pre>
</li>
<li>
<p>Android调用Js方法写法：</p>
<pre><code class="language-kotlin">	//通知h5端网络状态变化
   web_view?.loadUrl(&quot;javascript:isOnLine(true)&quot;)
   
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url</p>
<ul>
<li>其中代表<a href="https://github.com/lzyzsd/JsBridge">JsBridge</a></li>
</ul>
</li>
<li>
<p>WebChromeClient 的onJsPrompt()、onJsAlert()、onJsConfirm() 与第二种方法类似</p>
</li>
</ul>
<h4 id="离线包">离线包</h4>
<p>    离线包的概念即客户端与H5端和服务端共同约定好的一套协议。h5开发完后打包为静态资源通过服务端的配置接口通知到客户端。客户端通过提前拉取的方式进行资源的下载,在客户端真正打开的时候通过shouldInterceptRequest()方法来直接读取本地资源,基本能够达到秒开的优化。</p>
<p>    此外,在离线包的基础上还可以根据H5每次发布版本的差异进行H5离线包中css、js等资源的差分化,由客户端本地进行增量更新,这样每次下载的文件将会消耗较少的流量。</p>
<p>    而且，在某个高版本H5离线包发现问题时可以通过事前定义好的jsbridge强制降级到客户端的某个低版本。</p>
<ul>
<li>方案难点
<ul>
<li>需要多端协同、共同遵守协议。</li>
<li>差分包需要H5端有版本管理平台</li>
<li>需要考虑h5端版本发布通知到客户端的到达率问题</li>
</ul>
</li>
</ul>
<h4 id="安全性优化">安全性优化</h4>
<ul>
<li>
<p>http 与https混合</p>
<ul>
<li>android5.0后如果网页请求中同时包含http与https可能会出现无法加载的情况
<ul>
<li>解决方案:websetting 设置mixcontent</li>
</ul>
<pre><code class="language-kotlin">settings.mixedContentMode=WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
</code></pre>
</li>
</ul>
</li>
<li>
<p>网页劫持</p>
<ul>
<li>网页劫持一般出现原因为h5界面出现广告等不相干元素</li>
<li>出现原因一般为DNS污染(解析到错误域名)或者因为http劫持</li>
<li>解决办法：
<ul>
<li>全局替换为更安全的HTTPS</li>
<li>上面有说道Android所有请求都会走到shouldInterceptRequest方法,可以通过使用阿里云的httpDns服务首先对host进行一次域名解析然后将host替换为IP进行请求 此种情况可避免Dns被污染或者http劫持问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
    ......
      URL url = new URL(request.getUrl().toString());
      conn = (HttpURLConnection) url.openConnection();
      // 接口获取IP
      String ip = httpdns.getIpByHostAsync(url.getHost());
      if (ip != null) {
        // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
        Log.d(TAG, &quot;Get IP: &quot; + ip + &quot; for host: &quot; + url.getHost() + &quot; from HTTPDNS successfully!&quot;);
        String newUrl = path.replaceFirst(url.getHost(), ip);
        conn = (HttpURLConnection) new URL(newUrl).openConnection();
        // 添加原有头部信息
        if (headers != null) {
          for (Map.Entry&lt;String, String&gt; field : headers.entrySet()) {
            conn.setRequestProperty(field.getKey(), field.getValue());
          }
        }
        // 设置HTTP请求头Host域
        conn.setRequestProperty(&quot;Host&quot;, url.getHost());
      } 
}

</code></pre>
<pre><code>	 更详细解决办法[参考](https://help.aliyun.com/document_detail/60181.html)
</code></pre>
]]></content>
    </entry>
</feed>