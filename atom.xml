<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-11-19T02:17:30.745Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[再学Android:okhttp3.X(一)Request&OkHttpClient]]></title>
        <id>https://alsowell.github.io//post/okhttp_one</id>
        <link href="https://alsowell.github.io//post/okhttp_one">
        </link>
        <updated>2019-11-16T03:30:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>  本人从事Android开发工作几年，也算是见证了Android的技术变革。拿网络库来讲从最开始使用的xUtils到 <a href="https://github.com/google/volley">volley</a>然后到现在主流的<a href="https://github.com/square/okhttp">okhttp</a>。更不要说热更新、插件化、以及路由开发模式的大行其道。<br>
有感于工作中大多时候是仅限于使用,于是打算写一系列关于Android开发中使用到的框架解析，也算是对自己理解的一个记录。</p>
<h3 id="正文">正文</h3>
<p>  网上看到一个观点：当我们想深入了解一个框架的时候，第一步是要会用，然后按照框架的流程图一步一步的去慢慢的探索分析。对于这个观点笔者是非常赞同的，优秀的框架都是有清晰的架构、核心思想也都采用了优秀的设计模式。下面我们从okhttp开始分析</p>
<h4 id="step1">Step1:</h4>
<p>  鉴于网上已经有很多详尽的流程图，这里直接借鉴一张<br>
<img src="https://alsowell.github.io//post-images/1573878925540.png" alt=""></p>
<center> 图片来源:https://www.cnblogs.com/huangjialin/p/9469373.html </center>
&emsp;&emsp;一般我们使用okhttp都是从构建一个client开始。注：本人分析所用源码是官方使用Kotlin重写版本。
<pre><code class="language-kotlin">        val okHttpClient = OkHttpClient.Builder()
                .connectTimeout(10, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .readTimeout(10, TimeUnit.SECONDS)
                .build()
        val request = Request.Builder().url(&quot;http://www.baidu.com&quot;)
                .get()
                .build()
        okHttpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
            }

            override fun onResponse(call: Call, response: Response) {
            }
        })
</code></pre>
<p>  上面就是我们一般使用okhttp进行网络请求的简单写法。当然okhttp优秀的地方不是说能够帮我们封装好网络请求的内部逻辑，使我们能focus在业务上面。</p>
<h3 id="step2request">Step2:Request</h3>
<p>  我们从Request开始分析,当我们发起一次请求的时候客户端是怎么正确找到对应的服务器的呢？首先肯定是有一个host、然后对应的还有我们当前业务模块所属的下级域名。例如func/config这样的。当然实际上网络请求还有很多关于应用层、传输层的本文不做过多分析。</p>
<pre><code class="language-kotlin">    val request = Request.Builder()
            .url(&quot;http://www.baidu.com/xxx/xxx&quot;)
            .addHeader(&quot;xxxx&quot;,&quot;xxx&quot;)
            .get()
            .build()
</code></pre>
<p>  上面是比较简单的构造一个Request请求时的写法，Requst是通过建造者模式声明，根据具体业务场景添加我们需要的一些参数。url参数不用多说为我们业务接口需要访问的接口，追溯进去源码会发现：</p>
<table><tr ><td bgcolor=#f7f6f3 >
 第一步:首先把web socket的请求替换为http的请求
 Silently replace web socket URLs with HTTP URLs.
 第二步:通过调用HttpUrl类去进行Url自动替换掉换行等或者进行合法性的一些验证,如果一个请求的url没有以http开头会抛出Expected URL scheme 'http' or 'https' but was xxx的异常。同时通过HttpUrl内部的parse方法会解析出当前请求的一些参数并且记录下来
</td></tr></table>
<p>  addHeader其实就是把跟服务器约定好的一些参数填入进入，构造Request的时候也会声明会是一个什么请求。对应的还会有post、put、delete等方法。以上就是构造一个Request的方式。其实也是非常的简单。</p>
<h3 id="step3okhttpclient">Step3:OkHttpClient</h3>
<p>  说完了Request，我们再来分析一下OkHttpClient：字面意思非常好理解，okhttp的客户端。首先来看一下client的类注释。大概意思如下:</p>
<table><tr><td bgcolor=#f7f6f3>
&emsp;&emsp;使用的时候最好构建一个单例的client去复用到所有的网络请求，因为每个client都会持有它自己的连接池和线程池。复用线程池可以减少延迟并且可以减少内存的消耗，同时通过newBuilder()方法构造出来的client可以很方便的共享一些配置如：connectTimeOut等
<br></br>
Tips:看到上面的注释，网络优化角度为什么要复用连接池也就可以很明白的理解了。
<td><tr></table>
&emsp;&emsp;上面的示例我们发现真正在使用的时候需要我们设置的项并不多，但其实client在构造的时候是有很多参数可以设置。
<pre><code class="language-kotlin">    //异步请求什么时候执行的策略管理器
    internal var dispatcher: Dispatcher = Dispatcher()
    //管理http请求的连接来降低网络延迟的类
    internal var connectionPool: ConnectionPool = ConnectionPool()
    //一个网络请求拦截器
    internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //网络部分拦截器
    internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //整个网络流程的监听器、我们可以通过设置整个监听来感知网络请求的质量、响应体大小以及持续时长等等。
    internal var eventListenerFactory: EventListener.Factory =      EventListener.NONE.asFactory()
    //连接失败时候是否重试
    internal var retryOnConnectionFailure = true
    //暂时没看懂是干嘛的，默认值是不添加，日常开发中也不会用到
    internal var authenticator: Authenticator = Authenticator.NONE
    //是否可以重定向
    internal var followRedirects = true
    //ssl是否可以重定向
    internal var followSslRedirects = true
    //这个字面意思理解就可以了 一般在请求中需要加入用户的token的时候会用到 默认是没有cookie
    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
    //网络请求的缓存策略
    internal var cache: Cache? = null
    //dns 一个网络请求过程中 会首先把域名解析成ip 这样客户端才知道往什么地址发起请求。
    internal var dns: Dns = Dns.SYSTEM
    //设置代理 
    internal var proxy: Proxy? = null
    //代理选择器 
    internal var proxySelector: ProxySelector? = null
    //跟上面一样  属于代理ip的一个属性
    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
    //socket 工厂 
    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
    //https 的socket 
    internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
    //证书信任管理器，一般为了防止https 握手失败我们会设置信任所有的证书
    internal var x509TrustManagerOrNull: X509TrustManager? = null
    //连接说明 指定socket连接时的一些配置 如：https还是http或者TLS的版本、密码来保证安全的连接
    internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS
    //连接时选择的协议 HTTP_1_0、HTTP_1_1、HTTP_2等
    internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS
    //域名验证的具体接口实现。如果客户端跟服务端的hostName不一致的时候选择是否接受的策略
    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
    //按照我的理解是用于信任加入中间代理 如charles这种的代理
    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
    //用于计算高效的证书链
    internal var certificateChainCleaner: CertificateChainCleaner? = null
    //调用超时时间
    internal var callTimeout = 0
    //连接超时时间 10_000 挺有意思的 是kotlin里面特有的写法
    internal var connectTimeout = 10_000
    //读数据超时时间
    internal var readTimeout = 10_000
    //写入流数超时时间
    internal var writeTimeout = 10_000
    //ping的间隔
    internal var pingInterval = 0
</code></pre>
<p>  从上面可以看出其实okhttp内部帮我们封装了很多可以修改的配置，参数一般有默认值，通过建造者模式我们可以选择性的设置我们想要的配置。okhttp也是我们学习这种设计模式的一个比较好的实践。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发板上TeamViewer的自动绑定]]></title>
        <id>https://alsowell.github.io//post/teamviewer-auto-bind</id>
        <link href="https://alsowell.github.io//post/teamviewer-auto-bind">
        </link>
        <updated>2019-11-05T01:44:52.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
<!-- more -->
<p>  正常面对这种需求当然首先去找官方文档，但是翻遍Teamviewer提供的api接口也没有找到相关的实现;没办法只好拨打官方提供的技术支持电话进行咨询，经过了无数次的等待终于接通，但是技术人员的回复是不提供这个功能。</p>
<p>  在官方支持无果的情况下，笔者只好寻找其他的解决思路，通常面对这种问题第一个解决思路是通过抓包去分析绑定流程的数据传输进行解决。拿到所属账户的用户id以及设置的唯一标识：AndroidID去进行模拟绑定。</p>
<p>调起应用：</p>
<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572922168223.jpg" alt=""></figure>
<p>点击分配：</p>
<figure data-type="image" tabindex="2"><img src="https://alsowell.github.io//post-images/1572922822275.jpg" alt=""></figure>
<p>分配成功:</p>
<figure data-type="image" tabindex="3"><img src="https://alsowell.github.io//post-images/1572922885806.jpg" alt=""></figure>
<p>  注：笔者公司绑定TeamViewer的方式为通过打开teamviewer分配的固定的url链接通过浏览器调起Teamviewer应用进行绑定。</p>
<p>  通过抓包可以发现绑定时候去先获取当前机器所属的账户组，然后点击分配按钮时通过获取当前机器的信息去服务器进行当前账户的分配。分配成功后会返回当前机器的远程id和连接时候的密码。<br>
分析到这里好像已经解决了我们的需求。但是理想很丰满，现实很骨感。一顿骚操作以后发现模拟数据去请求后台也并不能在后台显示这台绑定的设备，这种方法宣告失败。</p>
<p>  我们再回头分析一下,Teamviewer内部的绑定并不是透明的，我们仅仅通过抓包的数据去进行hook好像并不代表它内部的所有流程。可能在进行网络请求后还进行了其他的操作，但是我们并不能知道。分析到这里下一步好像应该去做反编译去获取到它内部的流程操作。但是笔者再一顿骚操作后发现其内部进行了混淆，并且之前对反编译也没有什么研究，那么这种解决思路暂时先放一放。</p>
<p>  我们再分析一下正常绑定的流程，手动打开一个链接-&gt;通过浏览器调起应用-&gt;点击应用内的分配按钮-&gt;分配成功。整个过程关键的一步是手动点击按钮去实现。机智的你可能已经知道我们下一步的思路是通过模拟点击去进行自动绑定的实现。</p>
<p>  但是模拟点击的实现有个问题，我们不可能每次开机以后都去进行一次模拟点击的操作，在已经绑定的情况下再去做重复的点击无疑是多此一举。那么就需要去分析是否已经绑定过，正常的思路有两个：</p>
<ul>
<li>通过api去获取当前机器是否已经绑定</li>
<li>本地是否有数据记录是否绑定</li>
</ul>
<p>  毫无疑问去分析本地数据会更快一点，再结合之前说到的情况：机器恢复出厂设置的情况下已经绑定的远程会失效。那么我们可以分析得知本地肯定会存储一些必要的数据。那我们直接去data/data 里面去找一下。找了半天，终于在/data/data/com.teamviewer.host.market/files/global.conf路径下面发现了点东西。</p>
<figure data-type="image" tabindex="4"><img src="https://alsowell.github.io//post-images/1572931170363.jpg" alt=""></figure>
<!-- more -->
<p>  可以发现OwningManagerAccountName和OwningManagerCompanyName表示当前所属账户信息的。在没有绑定的情况下这两个字段是不存在的。那么问题就解决了。在每次开机时通过判断这两个字段是否去需要绑定。<br>
  是否绑定的问题已经解决了，那么接下来就到了重点。上面的流程分析提到：显示弹窗-&gt;点击弹窗——&gt;绑定完成。首先是判断是否已经进入到绑定的承载界面:</p>
<pre><code class="language-kotlin">    private fun getTopService(): Boolean {
        val exec = Shell(true).exec(&quot;dumpsys activity | grep  mFocusedActivity&quot;)
        return exec.message.contains(&quot;com.teamviewer.host.ui.HostActivity&quot;)
    }
</code></pre>
<h3 id="判断弹窗">判断弹窗</h3>
<p>  通过获取位于栈顶的进程来判断是否浏览器成功调起应用，然后是判断弹窗是否显示以及按钮的位置，方法比较多：1.我们知道Android的窗口都是通过WinddowManager来管理的，WindowManager是一种方式；<br>
2.另外一种方法是通过uiautomatorviewer来获取。这里着重讲一下uiautomatorviewer的方式。平常在开发过程中我们经常会使用Android sdk tools下面的uiautomatorviewer来获取当前屏幕正在显示的View层级关系以及所属位置。<br>
<img src="https://alsowell.github.io//post-images/1572934681994.jpg" alt=""><br>
<img src="https://alsowell.github.io//post-images/1572934977185.jpg" alt=""></p>
<p>  同样的我们可以直接在Android 的shell环境下直接执行</p>
<pre><code class="language-kotlin"> Shell(true).exec(&quot;uiautomator dump&quot;)
</code></pre>
<p>  执行这个命令，会直接在sdcard下生成一个window_dump.xml文件。我们通过解析xml分析出来当前是否处于弹窗状态以及需要模拟点击的按钮位置。</p>
<h3 id="模拟点击">模拟点击</h3>
<p>  说到模拟点击，你脑子里第一个想到的是什么？大多数情况下可能想到的都是AccessibilityService。AccessibilityService根据官方的介绍，是指开发者通过增加类似contentDescription的属性，从而在不修改代码的情况下，让残障人士能够获得使用体验的优化，大家可以打开AccessibilityService来试一下，点击区域，可以有语音或者触摸的提示，帮助残障人士使用App（这段介绍是我抄的）。但是AccessibilityService使用的前提是需要用户手动授权，Android默认是关闭的，对于笔者的业务场景是无法满足需求的。</p>
<p>  那可以考虑另外一种思路，直接输入input事件。我们在平常开发中经常会用到adb shell input tap xx xx 来表示一个点击事件。xx xx 代表Android坐标系下的坐标。同样的还有swipe代表滑动。插一句题外话 adb shell 工具使用的好对于平常的开发是大有裨益的。</p>
<pre><code class="language-kotlin">Shell(true).exec(&quot;input tap xxx xxx&quot;)
</code></pre>
<p>  到此，我们已经解决了模拟点击的步骤。点击完成再去本地文件中看一下发现所属的账户信息已经写入成功了。同时在后台也发现了这台设备已经在线，可以愉快的连接上去搞事情啦。</p>
<h3 id="结语">结语</h3>
<p>  以上就是笔者面对这个需求从懵逼到最后实现整个需求的过程。事后看来有很多没有按照Android开发规范来进行操作，如获取弹窗是直接dump出xml来进行解析而不是通过WindowManager来进行操作。但是想分享的是整个需求的实现思路。希望能对你有一点点帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android WebView的一些优化]]></title>
        <id>https://alsowell.github.io//post/android-webview</id>
        <link href="https://alsowell.github.io//post/android-webview">
        </link>
        <updated>2019-11-04T11:45:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-h5容器">Android H5容器</h1>
<p>  WebView是android上面加载h5界面的基础组件。4.4之前使用webkit作为内核,之后采用Chromium内核。高版本的内核在性能以及流畅性方面均会有较大提升。</p>
<p>  android上查看当前WebView内核版本的两种方式：</p>
<ul>
<li>chrome浏览器输入  chrome://inspect</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572868102476.png" alt=""></figure>
<ul>
<li>adb shell am start -a android.intent.action.VIEW -d  https://liulanmi.com/labs/core.html<br>
<img src="https://alsowell.github.io//post-images/1572868135876.png" alt=""></li>
</ul>
<h3 id="性能优化">性能优化</h3>
<p>  一个正常的natvie使用WebView加载网页的流程如下:<br>
<img src="https://alsowell.github.io//post-images/1572868151124.png" alt=""></p>
<p>  接下来将围绕整个WebView加载流程来进行android端的一些优化。</p>
<h4 id="webview单独进程进行加载">webview单独进程进行加载</h4>
<p>   WebView采用单独进程进行,App中大量Web页面的使用容易导致App内存占用巨大，存在内存泄露，崩溃率高等问题，WebView独立进程的使用是解决Android WebView相关问题的一个合理的方案。</p>
<p>  下图为加载WebView前后内存占用对比（仅打开百度首页）,可以观察,对大内存应用来讲WebView在不断打开网页过程中产生的内存极有可能造成OOM.</p>
<ul>
<li>未加载webview<br>
<img src="https://alsowell.github.io//post-images/1572868163142.png" alt=""></li>
<li>webview打开百度<br>
<img src="https://alsowell.github.io//post-images/1572868178190.png" alt=""></li>
</ul>
<p>   主流的方案都是直接采用新开activity单独进程进行WebView加载方案来进行优化。但是针对于单Activity+多fragment架构中,此方案就不能采用在Activity中开启多进程的方式来进行优化。</p>
<p>  开启多进程的方式有两种：</p>
<ul>
<li>通过在manifest中声明的方式开启。</li>
<li>通过Jni fork的方式产生,此方式难度较大。</li>
</ul>
<p>  考虑到Android四大组件中均可以通过声明的方式进行多进程的创建,可采用在service中动态创建WebView 然后动态添加到WindowManager中（此步需要有悬浮窗权限）。</p>
<h4 id="预加载优化">预加载优化</h4>
<p>  关于WebView加载耗时,分别测试直接加载webview预先加载webview时间对比。</p>
<ul>
<li>直接加载webview
<ul>
<li>通过动态添加view形式模拟webview启动耗时</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">			val startTime = System.currentTimeMillis()
            val webView = WebView(this)
            cl.addView(webView)
            val layoutParams = webView.layoutParams
            layoutParams.width=ViewGroup.LayoutParams.MATCH_PARENT
            layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT
            webView.layoutParams=layoutParams
            webView.loadUrl(&quot;http://www.baidu.com&quot;)
            webView.webViewClient = object : WebViewClient() {
                override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                    super.onPageStarted(view, url, favicon)
                    val loadTime = System.currentTimeMillis() - startTime
                    Log.d(TAG,&quot;time:$loadTime&quot;)
                }
            }

06-27 16:58:22.353 30779-30779/? D/WebViewLoad: time:488

</code></pre>
<ul>
<li>预加载WebView性能
<ul>
<li>通过预先在service中预先加载一个WebView</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">

val startTime = System.currentTimeMillis()
Log.d(TAG,&quot;preLoad start:$startTime&quot;)
val intent = Intent(this, WebViewService::class.java)
intent.action = &quot;load&quot;
startService(intent)

// service代码

if (intent?.action == &quot;load&quot;) {
 webview.webViewClient= object : WebViewClient() {
 override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
 super.onPageStarted(view, url, favicon)
 Log.d(&quot;WebViewLoad&quot;, &quot;当前时间：${System.currentTimeMillis()}&quot;)
             }
       }
webview.loadUrl(&quot;http://www.baidu.com&quot;)
}

06-27 17:22:11.606 19569-19569/net.example.webview D/WebViewLoad: preLoad start:1561627331606
06-27 17:22:11.642 19569-19569/net.example.webview D/WebViewLoad: 当前时间：1561627331642
result:36
</code></pre>
<p>  可以看到WebView的动态加载创建会耗费大量时间,因此在Android端可以全局创建一个WebView避免重复的资源开销,但随之而来伴随着可能造成的内存泄露需要在开发时注意。</p>
<h4 id="缓存优化">缓存优化</h4>
<p>  打开H5网页的过程中往往伴随着大量的js请求以及图片等占用网络的请求,并且每个请求都是串行进行的,这样的实现不仅耗费流量并且在网络情况不佳的情况下对用户带来的观感就是极其影响体验。<br>
  Android WebView本身已经支持5种缓存策略。</p>
<ul>
<li>浏览器 缓存机制</li>
<li>Application Cache 缓存机制</li>
<li>Dom Storage 缓存机制</li>
<li>Web SQL Database 缓存机制</li>
<li>Indexed Database 缓存机制</li>
</ul>
<p>  对于Android开发来说设置缓存最常用的方式是<br>
获取WebView的setting设置缓存模式</p>
<pre><code class="language-kotlin">	WebSettings.LOAD_DEFAULT
	WebSettings.LOAD_NO_CACHE
	WebSettings.LOAD_CACHE_ELSE_NETWORK
	WebSettings.LOAD_CACHE_ONLY
    WebSettings.LOAD_NO_CACHE
   
</code></pre>
<p>缓存模式具体分析<a href="https://www.jianshu.com/p/5e7075f4875f">参考</a></p>
<p>  Android端如何实现一套更自己可控制的缓存方案,H5页面中每个网络请求的均会回调</p>
<pre><code class="language-kotlin">override fun shouldInterceptRequest(view: WebView?, request: WebResourceRequest?): WebResourceResponse?
</code></pre>
<ul>
<li>优化方案
<ul>
<li>通过重写shouldInterceptRequest方法对特定资源进行本地文件缓存复用</li>
<li>实现方案
<ul>
<li>针对特定类型后缀文件HTML、Javascript、CSS、png等网络请求进行拦截使用nativie本身okhttp等网络框架库,同时针对下载文件进行本地缓存策略管理 如：LruDiskCache</li>
<li>h5端逻辑代码 js、cs变更如果未变更链接 此时代码仍然不是最新,此方案需要跟前端约定好版本概念。</li>
<li>shouldInterceptRequest是WebView维护线程进行异步请求，所以可以放心耗时操作</li>
</ul>
</li>
<li>具体优化实现<a href="https://github.com/yale8848/CacheWebView">可参考CacheWebView</a></li>
</ul>
</li>
</ul>
<h4 id="jsbridge">JsBridge</h4>
<ul>
<li>
<p>Android和Js通过WebView.addJavascriptInterface()进行映射</p>
<ul>
<li>
<p>Android端 需要在设置WebSetting是允许调用js方法,然后通过动态注册的方式把natvie提供的方法注册进bridge中</p>
<ul>
<li>settings.javaScriptEnabled=true</li>
<li>webView.addJavascriptInterface()</li>
</ul>
<pre><code class="language-kotlin">
web_view.addJavascriptInterface(JsInterface(), &quot;client&quot;)

inner class JsInterface {
@JavascriptInterface
fun backToMall() {
    runOnUiThread {
        Toast.makeText(this@MainActivity,&quot;back&quot;,Toast.LENGTH_SHORT).show()
    }
    Log.d(&quot;bigScreen&quot;, &quot;返回拍照&quot;)
    val open = LauncherHelper.instance.open(&quot;net.changjinglu.mall&quot;, &quot;net.changjinglu.mall.HomeActivity&quot;)
    if (open == 0) {
        Log.d(&quot;bigScreen&quot;, &quot;跳转成功&quot;)
        destroyWebView()
    } else {
        Log.d(&quot;bigScreen&quot;, &quot;跳转失败 返回:$open&quot;)
    }
}
@JavascriptInterface
fun loadComplete() {
    Log.d(&quot;bigScreen&quot;, &quot;页面加载完成&quot;)
    hasLoadSuccess.set(true)
}
</code></pre>
</li>
</ul>
<p>}</p>
<pre><code>  ```
</code></pre>
<ul>
<li>
<p>JS端调用</p>
<pre><code class="language-javascript">window.client.loadComplete()

</code></pre>
</li>
<li>
<p>Android调用Js方法写法：</p>
<pre><code class="language-kotlin">	//通知h5端网络状态变化
   web_view?.loadUrl(&quot;javascript:isOnLine(true)&quot;)
   
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url</p>
<ul>
<li>其中代表<a href="https://github.com/lzyzsd/JsBridge">JsBridge</a></li>
</ul>
</li>
<li>
<p>WebChromeClient 的onJsPrompt()、onJsAlert()、onJsConfirm() 与第二种方法类似</p>
</li>
</ul>
<h4 id="离线包">离线包</h4>
<p>  离线包的概念即客户端与H5端和服务端共同约定好的一套协议。h5开发完后打包为静态资源通过服务端的配置接口通知到客户端。客户端通过提前拉取的方式进行资源的下载,在客户端真正打开的时候通过shouldInterceptRequest()方法来直接读取本地资源,基本能够达到秒开的优化。</p>
<p>  此外,在离线包的基础上还可以根据H5每次发布版本的差异进行H5离线包中css、js等资源的差分化,由客户端本地进行增量更新,这样每次下载的文件将会消耗较少的流量。</p>
<p>  而且，在某个高版本H5离线包发现问题时可以通过事前定义好的jsbridge强制降级到客户端的某个低版本。</p>
<ul>
<li>方案难点
<ul>
<li>需要多端协同、共同遵守协议。</li>
<li>差分包需要H5端有版本管理平台</li>
<li>需要考虑h5端版本发布通知到客户端的到达率问题</li>
</ul>
</li>
</ul>
<h4 id="安全性优化">安全性优化</h4>
<ul>
<li>
<p>http 与https混合</p>
<ul>
<li>android5.0后如果网页请求中同时包含http与https可能会出现无法加载的情况
<ul>
<li>解决方案:websetting 设置mixcontent</li>
</ul>
<pre><code class="language-kotlin">settings.mixedContentMode=WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
</code></pre>
</li>
</ul>
</li>
<li>
<p>网页劫持</p>
<ul>
<li>网页劫持一般出现原因为h5界面出现广告等不相干元素</li>
<li>出现原因一般为DNS污染(解析到错误域名)或者因为http劫持</li>
<li>解决办法：
<ul>
<li>全局替换为更安全的HTTPS</li>
<li>上面有说道Android所有请求都会走到shouldInterceptRequest方法,可以通过使用阿里云的httpDns服务首先对host进行一次域名解析然后将host替换为IP进行请求 此种情况可避免Dns被污染或者http劫持问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
    ......
      URL url = new URL(request.getUrl().toString());
      conn = (HttpURLConnection) url.openConnection();
      // 接口获取IP
      String ip = httpdns.getIpByHostAsync(url.getHost());
      if (ip != null) {
        // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
        Log.d(TAG, &quot;Get IP: &quot; + ip + &quot; for host: &quot; + url.getHost() + &quot; from HTTPDNS successfully!&quot;);
        String newUrl = path.replaceFirst(url.getHost(), ip);
        conn = (HttpURLConnection) new URL(newUrl).openConnection();
        // 添加原有头部信息
        if (headers != null) {
          for (Map.Entry&lt;String, String&gt; field : headers.entrySet()) {
            conn.setRequestProperty(field.getKey(), field.getValue());
          }
        }
        // 设置HTTP请求头Host域
        conn.setRequestProperty(&quot;Host&quot;, url.getHost());
      } 
}

</code></pre>
<p>  更详细解决办法<a href="https://help.aliyun.com/document_detail/60181.html">参考</a></p>
]]></content>
    </entry>
</feed>