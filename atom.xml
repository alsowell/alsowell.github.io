<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-11-25T07:53:48.064Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（六）ConnectInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor">
        </link>
        <updated>2019-11-25T07:28:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>不知不觉已经到了要分析ok内置拦截器第四个的文章了，本篇的主角就是ConnectInterceptor，看名字也就知道它是负责与服务器建立连接的拦截器也。</p>
<h4 id="源码分析">源码分析</h4>
<p>话不多说，上代码:</p>
<pre><code class="language-kotlin">   @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val request = realChain.request()
    val transmitter = realChain.transmitter()

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    val doExtensiveHealthChecks = request.method != &quot;GET&quot;
    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)

    return realChain.proceed(request, transmitter, exchange)
  }
</code></pre>
<p>可以看到这个拦截器里面的代码是异常的精简，纵观全部发现关键步骤是在于调用transmitter.newExchange()方法。前面的文章中简单分析过transmitter类还有印象吗？这里再简单回顾下</p>
<h5 id="transmitter">Transmitter</h5>
<p>Transmitter是应用层和网络层之间的桥梁，对外暴露了网络连接过程中的connection、request、response、streams。</p>
<p>我们接着看newExchange方法做了什么事情</p>
<pre><code class="language-kotlin">  /** Returns a new exchange to carry a new request and response. */
  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
    synchronized(connectionPool) {
      check(!noMoreExchanges) { &quot;released&quot; }
      check(exchange == null) {
        &quot;cannot make a new request because the previous response is still open: &quot; +
            &quot;please call response.close()&quot;
      }
    }

    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)

    synchronized(connectionPool) {
      this.exchange = result
      this.exchangeRequestDone = false
      this.exchangeResponseDone = false
      return result
    }
  }
</code></pre>
<p>首先是通过exchangeFinder调动find方法拿到codec，那这几个又是什么东西呢？</p>
<h5 id="exchangefinder">ExchangeFinder</h5>
<p>不知大家对介绍重试拦截器的过程是否还有印象？在重试拦截器中有通过transmitter调用prepareToConnect()。exchangeFinder对象同时也是那个时候初始化的，当时的介绍是为了后续的网络连接做准备。我们今天就来看看其在ConnectionInterceptor过程中是怎么做的网络连接。</p>
<p>还是简单翻译一下ExchangeFinder的类注释：</p>
<table><tr><td bgcolor=""#f7f6f3>
尝试找到请求队列中的已经存在的连接,使用下列策略：<br>
1.如果当前请求已经连接上，那么就直接使用。
2.如果连接池中有可以服用的连接，那么根据RealConnection.isEligible来判断是否使用。
3.如果当前没有存在的连接，那么就尝试从新建立一个新的连接。
</td></tr></table>
<p>可以看到ok在建立连接的时候是遵循尽量服用连接池的做法，因为这样可以大大降低在网络连接过程解析DNS耗时、以及握手耗时。<br></p>
<p>那么find()方法是做了什么事情呢？还是先看一下代码:</p>
<pre><code class="language-kotlin"> fun find(client: OkHttpClient,chain: Interceptor.Chain,doExtensiveHealthChecks: Boolean
  ): ExchangeCodec {
    //参数设置代码省略。。。。。。。
    try {
    //找到目前可用的连接
      val resultConnection = findHealthyConnection(
          connectTimeout = connectTimeout,
          readTimeout = readTimeout,
          writeTimeout = writeTimeout,
          pingIntervalMillis = pingIntervalMillis,
          connectionRetryEnabled = connectionRetryEnabled,
          doExtensiveHealthChecks = doExtensiveHealthChecks
      )
      return resultConnection.newCodec(client, chain)
    } catch (e: RouteException) {
      trackFailure()
      throw e
    } catch (e: IOException) {
      trackFailure()
      throw RouteException(e)
    }
  }
</code></pre>
<p>抛却一大推设置参数的代码可以发现主要是findHealthyConnection()来找到一个可用的connection。那它究竟是怎么找的呢？（为了分析请求流程这里可能会有大量代码）。进入到findHealthyConnection()方法中我们发现在while循环中，主要是通过findConnection()来寻找可用connection。并且方法注释如下:</p>
<pre><code class="language-kotlin">  /**
   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
   * until a healthy connection is found.
   */
</code></pre>
<h5 id="findconnection">findConnection()</h5>
<pre><code class="language-kotlin"> /**
   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
   * then the pool, finally building a new connection.
   */
</code></pre>
<p>这是每次请求过程中真正找到connection的方法，至于是使用已经存在的还是新建立的我们通过代码来分析:(方法代码有点长，为了流程连贯，将在代码中使用注释分析)</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    //使用代码块锁 保证线程同步 
    synchronized(connectionPool) {
    //前文分析过这里只会是用户主动取消，如果取消抛出异常
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)
      hasStreamFailure = false // This is a fresh attempt.

      releasedConnection = transmitter.connection
      //这里判断如果数据传输已经完成就返回需要关闭的sokcet，反之为null
      toClose = if (transmitter.connection != null &amp;&amp; transmitter.connection!!.noNewExchanges) {
        transmitter.releaseConnectionNoEvents()
      } else {
        null
      }
        //已经有一个分配好的连接 并且处于可用状态 
      if (transmitter.connection != null) {
        // We had an already-allocated connection and it's good.
        result = transmitter.connection
        releasedConnection = null
      }
    //按照之前的策略，如果当前没有已经连接好的连接，会尝试从连接池中找到一个可用的。
      if (result == null) {
        // Attempt to get a connection from the pool.
        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        } else if (retryCurrentRoute()) {
          selectedRoute = transmitter.connection!!.route()
        }
      }
    }
    //关闭之前socket 
    toClose?.closeQuietly()

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection!!)
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result!!
    }
    
    // If we need a route selection, make one. This is a blocking operation.
    var newRouteSelection = false
    if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection!!.hasNext())) {
      newRouteSelection = true
      routeSelection = routeSelector.next()
    }

    var routes: List&lt;Route&gt;? = null
    synchronized(connectionPool) {
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection!!.routes
        //再次尝试从连接池中找到可用连接
        if (connectionPool.transmitterAcquirePooledConnection(
                address, transmitter, routes, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        }
      } 
        
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }
        //再次尝试从连接池中找到可用连接失败，创建一个connection 
        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }
    //刚刚创建出来的connection 调用connect方法进行网络连接 
    // Do TCP + TLS handshakes. This is a blocking operation.
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    //将当前域名从失败的黑名单中移除掉
    connectionPool.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      //在连接过程中最后一次尝试从连接池中找到已经有的连接，防止同时有两个相对host的请求发出，这样就能复用已有的连接
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = transmitter.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
      //将这次连接放入连接池中，为了后续可能直接复用
        connectionPool.put(result!!)
        transmitter.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }

</code></pre>
<p>经过分析代码可以发现，ok在进行连接建立的时候不是直接去建立的connection，而是尽可能的寻找已经存在的连接去进行复用。如果实在没有可利用的再去创建一条新的连接并且将其放入连接池给后续请求去复用。</p>
<p>经过上面苦苦一番寻找，我们终于拿到了一条建立好的可使用的连接RealConnection。然后直接调用newCodec()方法返回一个ExchangeCodec对象。我们再来看一下是干嘛的:</p>
<pre><code class="language-kotlin"> @Throws(SocketException::class)
  internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec {
    val socket = this.socket!!
    val source = this.source!!
    val sink = this.sink!!
    val http2Connection = this.http2Connection

    return if (http2Connection != null) {
      Http2ExchangeCodec(client, this, chain, http2Connection)
    } else {
      socket.soTimeout = chain.readTimeoutMillis()
      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)
      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)
      Http1ExchangeCodec(client, this, source, sink)
    }
  }
</code></pre>
<p>可以看到关键方法就是根据当前请求协议是HTTP1还是HTTP2来返回一个codec，我们跟进到codec类去看一下注释，大概翻译如下:</p>
<table><tr><td bgcolor="#f7f6f3">
一个用来发送http/1.1消息的socket连接，并且严格遵守下列的生命周期:<br>
- 发送请求的headers[writeRequest]<br>
- 打开一个水槽（直译）去写入请求体<br>
- 开始写入请求体然后关闭这个水槽<br>
- 读取响应头
- 申请一部分资源开始读取响应体
- 读取完成响应体后关闭资源
</td></tr></table>
经过上面寻找可用连接的操作之后基本上到了newExchange的最后一步去构建出来一个Exchange并且返回。
<h5 id="exchange">Exchange</h5>
<p>类注释很简单:传输一个http的请求和响应，是真正上处理IO操作的。事件的管理是被ExchangeCodec管控。</p>
<h4 id="总结">总结</h4>
<p>到这里,关于ConnectInterceptor的源码探究基本上就告一段落了。我们大概来总结下:</p>
<ul>
<li>从chain对象中获取到Transmitter对象</li>
<li>调用transmitter的newExchange()方法</li>
<li>根据调度策略找到可用的连接并返回</li>
<li>调用proceed调用下一个拦截器</li>
</ul>
<p>上面基本上就是ConnectionInterceptor的调用流程，接下来我们会继续分析ok内置的最后一个拦截器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（五）CacheInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor">
        </link>
        <updated>2019-11-22T09:42:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了重试拦截器和BridgeInterceptor(用来处理header、设置gzip、user-agent等)。本篇文章将开始分析ok内置拦截器比较实用的缓存拦截器<strong>CacheInterceptor</strong>。</p>
<p>顾名思义，CacheInterceptor就是处理与缓存相关的。关于http中的缓存知识可以参考<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a>。这篇文章写得非常浅显易懂。</p>
<h4 id="源码探究">源码探究</h4>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val cacheCandidate = cache?.get(chain.request())

    val now = System.currentTimeMillis()

    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
    val networkRequest = strategy.networkRequest
    val cacheResponse = strategy.cacheResponse

    cache?.trackResponse(strategy)

    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
      // The cache candidate wasn't applicable. Close it.
      cacheCandidate.body?.closeQuietly()
    }

    // If we're forbidden from using the network and the cache is insufficient, fail.
    if (networkRequest == null &amp;&amp; cacheResponse == null) {
      return Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(HTTP_GATEWAY_TIMEOUT)
          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)
          .body(EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
    }

    // If we don't need the network, we're done.
    if (networkRequest == null) {
      return cacheResponse!!.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build()
    }

    var networkResponse: Response? = null
    try {
      networkResponse = chain.proceed(networkRequest)
    } finally {
      // If we're crashing on I/O or otherwise, don't leak the cache body.
      if (networkResponse == null &amp;&amp; cacheCandidate != null) {
        cacheCandidate.body?.closeQuietly()
      }
    }

    // If we have a cache response too, then we're doing a conditional get.
    if (cacheResponse != null) {
      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
        val response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers, networkResponse.headers))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()

        networkResponse.body!!.close()

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache!!.trackConditionalCacheHit()
        cache.update(cacheResponse, response)
        return response
      } else {
        cacheResponse.body?.closeQuietly()
      }
    }

    val response = networkResponse!!.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build()

    if (cache != null) {
      if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        val cacheRequest = cache.put(response)
        return cacheWritingResponse(cacheRequest, response)
      }
      
      if (HttpMethod.invalidatesCache(networkRequest.method)) {
        try {
          cache.remove(networkRequest)
        } catch (_: IOException) {
          // The cache cannot be written.
        }
      }
    }

    return response
  }

</code></pre>
<h5 id="request阶段">Request阶段</h5>
<p>可以看到，首先是通过请求的url去缓存中读取，当然取出的缓存对象可能为空。主要方法:</p>
<pre><code class="language-kotlin">   val cacheCandidate = cache?.get(chain.request())
</code></pre>
<p>那么Cache又是什么呢？还记得我们在分析OkHttpClient构造时候的cache参数吗？其实cache是ok内部实现的一个DiskLruCache。是不是很熟悉？也是三级缓存的原理。关于<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>,又是JakeWarton的一大杰作。多提一句，我们在构建client的时候可以通过builder模式设置我们想要缓存的文件夹以及最大缓存，下面放出代码。不过注意加好权限哦。</p>
<pre><code class="language-kotlin">     val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .cache(Cache(Environment.getDownloadCacheDirectory(),10000))
            .build()
</code></pre>
<p>接着是记录当前时间，他与从缓存取出的Response都是构建缓存策略的构造参数。说到缓存策略：</p>
<pre><code class="language-kotlin"> val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
</code></pre>
<p>其实结合http中的缓存原理（见上文连接）就可以很简单的理解了，无非是根据请求参数和本地的缓存是否需要使用本地或者说两者结合。</p>
<p>继续往下面看，根据networkRequest和cacheResponse 的值来判断后续流程。既然他们都是从CacheStrategy中拿到的，那我们先来了解下这两个家伙：</p>
<pre><code class="language-kotlin"> /** The request to send on the network, or null if this call doesn't use the network. */
 val networkRequest: Request?,
 /** The cached response to return or validate; or null if this call doesn't use a cache. */
 val cacheResponse: Response?
</code></pre>
<p>看了注释就非常好理解了，networkRequest在使用缓存的情况下为空，cahceRespoonse在没有使用缓存的情况下为空。<br>
那么两个都为空的情况下就直接返回一个空的响应体，并且设置状态吗为504。</p>
<p>使用缓存情况下，直接就返回缓存中存储的数据，这点在代码里可以体现：</p>
<pre><code class="language-kotlin">// If we don't need the network, we're done.
   if (networkRequest == null) {
     return cacheResponse!!.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .build()
   }
</code></pre>
<p>那么如果我们不适用缓存呢？机智的你肯定会想起来拦截器的机制，没错就是继续通过chain.proceed方法调用下一个拦截器。既然本篇是关于缓存的，我们就继续看一下在使用缓存情况下是怎么处理response的。</p>
<h5 id="response阶段">Response阶段</h5>
<p>如果你看了上面关于HTTP缓存分析的文章，你会知道在http协议中，如果数据没有发生改变那么响应码将会是304。同样ok既然作为一个网络库也是遵守同样的规则的。</p>
<p>在本地缓存不为空情况下，如果服务器返回304，那么ok将会更新header里面的一些参数，更新请求发起时间、响应接收时间等。在此之后返回networkResponse和cacheResponse结合之后的response。</p>
<p>如果用户设置了自定义的缓存目录以及大小并且当前请求是可以被缓存的，那么调用put方法将响应存储到本地磁盘中。但是如果请求的方法是 patch、put、delete、move等不支持缓存的方法，会将缓存从磁盘中清楚。</p>
<h4 id="总结">总结</h4>
<p>以上就是CacheInterceptor的全部分析啦。我们大概类总结一下流程：</p>
<ul>
<li>首先通过请求的url通过DiskLruCache拿到可能存在的响应体</li>
<li>通过请求时间和缓存中的响应体拿到缓存策略</li>
<li>通过策略判断本次请求是直接读取缓存还是请求网络获取</li>
<li>网络请求返回的数据更新到本地缓存中</li>
</ul>
<p>回头来看，其实缓存管理也是按照我们网络协议里面的规则，ok是基于这个规则对其进行了一定的封装。关键部分还是要充分的理解HTTP缓存机制，再次强烈推荐这篇<a href="https://www.cnblogs.com/chenqf/p/6386163.html">文章</a>。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://www.jianshu.com/p/963ad9ca214d">OKhttp源码学习（六）—— CacheInterceptor</a></p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（四）BridgeInterceptor]]></title>
        <id>https://alsowell.github.io//post/okhttp_two</id>
        <link href="https://alsowell.github.io//post/okhttp_two">
        </link>
        <updated>2019-11-22T02:17:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h4 id="前言">前言</h4>
<p>在上一篇文章中我们已经分析过了ok内置五个拦截器中的第一个RetryAndFollowUpInterceptor，本篇我们将继续按照顺序去探究一下BridgeInterceptor。</p>
<h4 id="介绍">介绍</h4>
<p>首先来看一下类注释：</p>
<table><tr><td bgcolor=#f7f6f3>
 Bridges from application code to network code. First it builds a network request from a user
 request. Then it proceeds to call the network. Finally it builds a user response from the network response.
<br></br>
释义：应用层和网络层之间的桥接，首先往用户发起的请求中添加一部分网络层需要的参数，接着调用网络，最后从响应体中解析出用户请求的结果
</td></tr></table>
接着我们直接上代码：
<pre><code class="language-kotlin">  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val userRequest = chain.request()
    val requestBuilder = userRequest.newBuilder()

    val body = userRequest.body
    if (body != null) {
      val contentType = body.contentType()
      if (contentType != null) {
        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())
      }
      val contentLength = body.contentLength()
      if (contentLength != -1L) {
        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())
        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)
      } else {
        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
        requestBuilder.removeHeader(&quot;Content-Length&quot;)
      }
    }
    if (userRequest.header(&quot;Host&quot;) == null) {
      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())
    }

    if (userRequest.header(&quot;Connection&quot;) == null) {
      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)
    }

    // If we add an &quot;Accept-Encoding: gzip&quot; header field we're responsible for also decompressing
    // the transfer stream.
    var transparentGzip = false
    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {
      transparentGzip = true
      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
    }

    val cookies = cookieJar.loadForRequest(userRequest.url)
    if (cookies.isNotEmpty()) {
      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))
    }

    if (userRequest.header(&quot;User-Agent&quot;) == null) {
      requestBuilder.header(&quot;User-Agent&quot;, userAgent)
    }

    val networkResponse = chain.proceed(requestBuilder.build())

    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
    
    val responseBuilder = networkResponse.newBuilder()
        .request(userRequest)
    if (transparentGzip &amp;&amp;
        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase = true) &amp;&amp;
        networkResponse.promisesBody()) {
      val responseBody = networkResponse.body
      if (responseBody != null) {
        val gzipSource = GzipSource(responseBody.source())
        val strippedHeaders = networkResponse.headers.newBuilder()
            .removeAll(&quot;Content-Encoding&quot;)
            .removeAll(&quot;Content-Length&quot;)
            .build()
        responseBuilder.headers(strippedHeaders)
        val contentType = networkResponse.header(&quot;Content-Type&quot;)
        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
      }
    }
    return responseBuilder.build()
  }
</code></pre>
<p>相对于上一篇的重试拦截器，bridge拦截器的代码相对来说是非常容易看懂的。我们将按照interceptor的调用来分为两个阶段分析：</p>
<h4 id="request阶段">Request阶段</h4>
<ul>
<li>
<p>取出body的contentType设置到header里面</p>
</li>
<li>
<p>获取请求体的长度放入header</p>
<ul>
<li>Transfer-Encoding 字面意思也很好理解，即为传输过程中的编码格式<br>
根据网上资料:首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP1.1的传输编码方式仅对分块传输编码有效。值为 chunked 表示请求体的内容大小是未知的。    因此Transfer-Encoding与Content-Length两个首部不能共存。</li>
</ul>
</li>
<li>
<p>将请求的host放入到header里面</p>
<ul>
<li>
<p>Host即对应请求中的域名 对此HttpUrl中有详细的注释解释</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left"><code>host()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>http://android.com/</code></td>
<td style="text-align:left"><code>&quot;android.com&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://127.0.0.1/</code></td>
<td style="text-align:left"><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://[::1]/</code></td>
<td style="text-align:left"><code>&quot;::1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://xn--n3h.net/</code></td>
<td style="text-align:left"><code>&quot;xn--n3h.net&quot;</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>其中toHostHeader()方法会取到对应的域名并且拼接上默认的端口 http默认端口80 、https默认端口443</p>
</li>
</ul>
</li>
<li>
<p>指定连接模式为 Keep-Alive 这样就能方便的复用连接池。</p>
</li>
<li>
<p>如果用户没有设置Accept-Encoding，那么会指定数据接收格式为gzip。顺带提一下：gzip格式压缩能大大减少网络流量的消耗。</p>
</li>
<li>
<p>header中放入cookie</p>
</li>
<li>
<p>请求头中放入 user-agent 如果用户没有设置，那么放入默认 agent:okhttp/x.x.x</p>
</li>
</ul>
<h4 id="response阶段">Response阶段</h4>
<ul>
<li>首先是根据url拿到返回的cookie。</li>
<li>如果Content-Encoding是gzip类型，并且content-length &gt;0 取出body进行处理</li>
<li>对请求响应体做一遍处理，因为响应体的body的传输格式是gzip类型，通过封装的方法类解析处理</li>
<li>解析成为用户真正可使用的body</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上就是整个BridgeInterceptor的全部流程了。大概可以分为三步</p>
<ul>
<li>对用户的请求做一遍处理，如果用户设置了参数使用用户配置，如果未设置那么就使用默认的。</li>
<li>通过chain调用下一个拦截器。</li>
<li>对接口的请求做一遍处理，比如gzip、cookie 最后解析成用户真正可使用的body。</li>
</ul>
<p>可以看到整个BridgeInterceptor的流程还是非常简单的，无非就是对网络传输协议中一些必须参数的封装，这样应用层在调用的时候就省去了这些步骤。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(三) RetryAndFollowUpInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-san-retryandfollowupinterceptor">
        </link>
        <updated>2019-11-21T12:17:21.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了整个okhttp的核心其实是getResponseWithInterceptor方法。内部是通过一系列的拦截器调用来完成整个网络请求。我们也知道了ok内部定义了五个拦截器。拦截器又是通过责任链模式来递归进行调用。本篇文章我们将按照加载顺序来分析第一个拦截器<strong>RetryAndFollowUpInterceptor</strong></p>
<p>####介绍</p>
<p>按照字面意思来理解就是一个管理重试和后续动作的拦截器，那么究竟是怎么做的呢？简单，上注释！</p>
<pre><code class="language-kotlin">//这个拦截器主要是用来处理失败和重定向的请求，如果请求被取消可能会抛出io异常 
/**
 * This interceptor recovers from failures and follows redirects as necessary. It may throw an
 * [IOException] if the call was canceled.
 */
</code></pre>
<p>看来前面的理解也没有问题，规范的命名确实能让人一看就知道什么意思。那直接进入正文。</p>
<h4 id="核心功能">核心功能</h4>
<ul>
<li>
<p>失败重试</p>
<ul>
<li>在遇到RouteException和IOException通过recover()方法判断当前请求是否可以重新尝试。</li>
</ul>
</li>
<li>
<p>继续发起请求</p>
<ul>
<li>
<p>通过followUpRequest()方法来判断当前是否可以继续发起请求，主要根据响应码来判断</p>
<table>
<thead>
<tr>
<th>应码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>07</td>
<td>代理鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>01</td>
<td>鉴权失败、调用 Authenticator 进行授权后继续发起新的请求</td>
</tr>
<tr>
<td>07、308</td>
<td>重定向，method不为get 和head情况下 ，重新发起新的请求</td>
</tr>
<tr>
<td>00、301、302、303</td>
<td>重定向，重新发起新的请求</td>
</tr>
<tr>
<td>08</td>
<td>客户端请求超时，会继续发起新的请求</td>
</tr>
<tr>
<td>03</td>
<td>服务不可用，会继续发起新的请求</td>
</tr>
<tr>
<td>lse</td>
<td>直接发起新的请求</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：请求重试次数是受到MAX_FOLLOW_UPS 限制的，默认是20</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>经过前面文章的分析我们知道每一个拦截器都是在intercept里面操作的，那我们直接来分析一下：</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()
    //1
    val realChain = chain as RealInterceptorChain
    val transmitter = realChain.transmitter()
    var followUpCount = 0
    var priorResponse: Response? = null
    while (true) {
      //2
      transmitter.prepareToConnect(request)
      if (transmitter.isCanceled) {
        throw IOException(&quot;Canceled&quot;)
      }
      var response: Response
      var success = false
      try {
        //3
        response = realChain.proceed(request, transmitter, null)
        success = true
      } catch (e: RouteException) {
        // The attempt to connect via a route failed. The request will not have been sent.
        if (!recover(e.lastConnectException, transmitter, false, request)) {
          throw e.firstConnectException
        }
        continue
        //4
      } catch (e: IOException) {
        // An attempt to communicate with a server failed. The request may have been sent.
        val requestSendStarted = e !is ConnectionShutdownException
        if (!recover(e, transmitter, requestSendStarted, request)) throw e
        continue
      } finally {
        // The network call threw an exception. Release any resources.
        if (!success) {
          transmitter.exchangeDoneDueToException()
        }
      }
      // Attach the prior response if it exists. Such responses never have a body.
      if (priorResponse != null) {
        response = response.newBuilder()
            .priorResponse(priorResponse.newBuilder()
                .body(null)
                .build())
            .build()
      }
      val exchange = response.exchange
      val route = exchange?.connection()?.route()
      //5
      val followUp = followUpRequest(response, route)
      if (followUp == null) {
        if (exchange != null &amp;&amp; exchange.isDuplex) {
          transmitter.timeoutEarlyExit()
        }
        return response
      }
      val followUpBody = followUp.body
      //6
      if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {
        return response
      }
      response.body?.closeQuietly()
      if (transmitter.hasExchange()) {
        exchange?.detachWithViolence()
      }
      //7
      if (++followUpCount &gt; MAX_FOLLOW_UPS) {
        throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)
      }
      request = followUp
      priorResponse = response
    }
  }
</code></pre>
<h4 id="主要步骤">主要步骤</h4>
<ul>
<li>
<p>在上一篇文章中我们分析过，拦截器会通过构造RealInterceptorChain对象，并且把其作为参数通过调用当前interceptor的intercept方法来进行递归调用。并且也知道可以通过chain来获取到request、connection等对象。同样在重试拦截器中也是一样。第一步首先是拿到request 、realChain、transmitter对象。</p>
</li>
<li>
<p>进入到while循环中，首先调用transmitter的prepareToConnect方法。我们跟进去看一下：</p>
<pre><code class="language-kotlin">fun prepareToConnect(request: Request) {
    if (this.request != null) {
      if (this.request!!.url.canReuseConnectionFor(request.url) &amp;&amp; exchangeFinder!!.hasRouteToTry()) {
        return // Already ready.
      }
      check(exchange == null)
      if (exchangeFinder != null) {
        maybeReleaseConnection(null, true)
        exchangeFinder = null
      }
    }
    this.request = request
    this.exchangeFinder = ExchangeFinder(
        this, connectionPool, createAddress(request.url), call, eventListener)
  }
</code></pre>
<ul>
<li>不是第一次进入这个方法的时候
<ul>
<li>首先会判断是否可以服用连接池并且仍然处于重试过程中。</li>
<li>如果exchangeFinder不为空情况下 尝试关闭连接。并且回调eventListener connectionReleased方法，接着根据请求是否失败回调callFailed或者callEnd</li>
</ul>
</li>
<li>首次进入情况下
<ul>
<li>构建出exchangeFinder对象，为后续的网络连接做准备</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断请求是否被取消，如果取消抛出异常。</p>
<ul>
<li>
<pre><code class="language-kotlin">  fun cancel() {
    val exchangeToCancel: Exchange?
    val connectionToCancel: RealConnection?
    synchronized(connectionPool) {
      canceled = true
      exchangeToCancel = exchange
      connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
    }
    exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
  }
</code></pre>
</li>
</ul>
<p>通过调用链我们可以发现，这个方法只会在应用层通过Call对象的cancel方法调用到。</p>
</li>
<li>
<p>调用realChain的proceed方法</p>
<ul>
<li>
<p>还记得我们在上一篇文章中分析过这个方法其实是递归调用后续的拦截器并且将下一级的结果返回到当前处理。</p>
</li>
<li>
<p>通过try-catch 捕获在网络请求过程中可能出现的异常，如果未发生异常success为true，反之为false。</p>
<ul>
<li>
<p>RouteException</p>
<ul>
<li>异常发生在请求还没发出之前，追溯源码会发现其实是发生在connect过程中。</li>
</ul>
</li>
<li>
<p>IOException</p>
<ul>
<li>异常发生请求可能已经发出，并且在读取服务端的响应过程中出错。</li>
</ul>
</li>
<li>
<p>通过recover方法判断是否是值得重试的异常，判断依据如下：</p>
<pre><code class="language-kotlin"> private fun recover(
    e: IOException,
    transmitter: Transmitter,
    requestSendStarted: Boolean,
    userRequest: Request
  ): Boolean {
    // The application layer has forbidden retries.
    if (!client.retryOnConnectionFailure) return false
    // We can't send the request body again.
    if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false
    // This exception is fatal.
    if (!isRecoverable(e, requestSendStarted)) return false
    // No more routes to attempt.
    if (!transmitter.canRetry()) return false
    // For failure recovery, use the same route selector with a new connection.
    return true
  }
</code></pre>
<ul>
<li>
<p>应用层设置失败是否重试</p>
<figure data-type="image" tabindex="1"><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/WechatIMG133355.tiff" alt=""></figure>
</li>
<li>
<p>是否有相同的请求正在执行</p>
</li>
<li>
<p>是否是可恢复的异常</p>
</li>
<li>
<pre><code class="language-kotlin">private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean {
    if (e is ProtocolException) {
      return false
    }
    if (e is InterruptedIOException) {
      return e is SocketTimeoutException &amp;&amp; !requestSendStarted
    }
    if (e is SSLHandshakeException) {
      if (e.cause is CertificateException) {
        return false
      }
    }
    if (e is SSLPeerUnverifiedException) {
      return false
    }
    return true
  }
</code></pre>
<ul>
<li>
<p>ProtocolException 协议异常</p>
<p><img src="/Users/mc/Desktop/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/1574337835415.jpg" alt="">主要发生在 RealConnection 中创建 HTTPS 通过 HTTP 代理进行连接重试超过 21 次。</p>
</li>
</ul>
</li>
<li>
<p>InterruptedIOException</p>
<ul>
<li>io终端异常，但是如果当前是一个连接超时异常，会进入到后续的判断，即根据响应码判断是否可重试。</li>
</ul>
</li>
<li>
<p>SSLHandshakeException</p>
<ul>
<li>https握手失败异常，不可重试。</li>
</ul>
</li>
<li>
<p>SSLPeerUnverifiedException</p>
<ul>
<li>网站的证书是不可信任的异常，不可重试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>是否已经失败过并且具有可以重试的route</p>
</li>
<li>
<p>如果请求未成功那么释放在上一次请求过程中的所有资源</p>
</li>
<li>
<p>从response中获取到 exchange、route对象。</p>
</li>
<li>
<p>调用followUpRequest方法 根据上次请求的返回码来确定是否需要重新尝试，关于响应码的分析在文章开头已经介绍过。</p>
</li>
<li>
<p>自增记录重试次数并且判断是否超过默认值</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>经过上面的分析我们可以知道：重试拦截器其实内部的逻辑还是有点小复杂的，首先定义了每个请求的最大默认尝试次数。然后在请求没有获取到响应时通过异常类型来判断是否可以继续重试。在获取到响应体阶段则是通过状态吗来判断。这里是不是更好理解：okhttp每个拦截器都是分为了Request阶段和Response阶段。到这里，我们对RetryAndFollowUpInterceptor的分析就告一段落了，下一章将会分析BridgeInterceptor。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5aa23fa46fb9a028cb2d3a96">源码分析三：OkHttp—RetryAndFollowUpInterceptor</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(二)getResponseWithInterceptorChain]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-er-getresponsewithinterceptorchain">
        </link>
        <updated>2019-11-21T03:18:33.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>上一篇文章中我们简单的总结了ok发起请求并接收响应的整个流程，我们发现关键步骤是getResponseWithInterceptorChain这个方法。那这里面又做了什么事情呢？还是首先来看一下代码：</p>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  fun getResponseWithInterceptorChain(): Response {
    // Build a full stack of interceptors.
    val interceptors = mutableListOf&lt;Interceptor&gt;()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)

    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)

    var calledNoMoreExchanges = false
    try {
      val response = chain.proceed(originalRequest)
      if (transmitter.isCanceled) {
        response.closeQuietly()
        throw IOException(&quot;Canceled&quot;)
      }
      return response
    } catch (e: IOException) {
      calledNoMoreExchanges = true
      throw transmitter.noMoreExchanges(e) as Throwable
    } finally {
      if (!calledNoMoreExchanges) {
        transmitter.noMoreExchanges(null)
      }
    }
  }
</code></pre>
<p>可以说这个方法是整个okhttp的核心，通过这么几行代码就实现了整个请求的过程。这里不得不提到ok的拦截器机制。大多数人说到okhttp优秀的地方基本上都会脱口而出通过设置拦截器可以很方便的实现网络请求的打印、添加一些公共参数等等。而拦截器真正的运行其实就是在这个方法中。</p>
<ul>
<li>首先在interceptors中添加用户自定义的拦截器</li>
<li>然后按顺序添加各种系统内置的拦截器</li>
<li>通过RealInterceptorChain方法获取一个chain对象</li>
<li>通过chain.proceed获取response</li>
</ul>
<h4 id="拦截器">拦截器</h4>
<p>说了这么久的拦截器，肯定会好奇它究竟是个什么妖魔鬼怪：</p>
<pre><code class="language-kotlin">/**
 * Observes, modifies, and potentially short-circuits requests going out and the corresponding
 * responses coming back in. Typically interceptors add, remove, or transform headers on the request
 * or response.
 */
interface Interceptor {
  @Throws(IOException::class)
  fun intercept(chain: Chain): Response

  companion object {
    inline operator fun invoke(crossinline block: (chain: Chain) -&gt; Response): Interceptor =
        object : Interceptor {
          override fun intercept(chain: Chain) = block(chain)
        }
  }
  interface Chain {
    fun request(): Request

    @Throws(IOException::class)
    fun proceed(request: Request): Response
    fun connection(): Connection?
    fun call(): Call
    fun connectTimeoutMillis(): Int
    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
    fun readTimeoutMillis(): Int
    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
    fun writeTimeoutMillis(): Int
    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
  }
}

</code></pre>
<p>Interceptor实际上是一个接口，里面定义了一个intercept方法和chain的接口类。</p>
<h5 id="intercept">intercept</h5>
<p>关于intercept方法是不是很熟悉？我们在自定义拦截器的时候往往都是在这里面做一些瞎操作。</p>
<pre><code class="language-kotlin">   override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val realInterceptorChain = chain as RealInterceptorChain
        val transmitter = realInterceptorChain.transmitter()
        val response = realInterceptorChain.proceed(request, transmitter, null)
        return response

    }
</code></pre>
<ul>
<li>这里首先是通过chain.request获取请求的request对象</li>
<li>通过chain.proceed 递归调用下一个拦截器的intercept方法</li>
<li>最终返回chain.proceed的response到上一级拦截器</li>
</ul>
<h5 id="分层">分层</h5>
<p>这里其实是将每个拦截器分为了两个阶段：</p>
<ul>
<li>Request阶段：执行该拦截器在请求前做的事，例如：bridgeInterceptor添加一些请求参数</li>
<li>Response阶段：执行拦截器在获取响应之后做的事，例如：打印出请求体的返回</li>
</ul>
<p>拦截器的设计其实是采用了递归调用的思想，仔细想想其实是非常巧妙的，这样可以保证不论是系统内置还是用户自定义的拦截器都可以得到最终执行。如果在某个拦截器中出现了错误，还可以把错误抛给上一层来处理。</p>
<h5 id="内置拦截器">内置拦截器</h5>
<p>通过剖析源码我们会发现,ok内部其实是帮我们内置了好几种拦截器，每次请求都会添加进去，我们按照添加顺序整理如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截器</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RetryAndFollowUpInterceptor</td>
<td style="text-align:center">负责实现重定向功能</td>
</tr>
<tr>
<td style="text-align:center">BridgeInterceptor</td>
<td style="text-align:center">将用户构造的请求转换为向服务器发送的请求，将服务器返回的响应转换为对用户友好的响应</td>
</tr>
<tr>
<td style="text-align:center">CacheInterceptor</td>
<td style="text-align:center">读取缓存、更新缓存</td>
</tr>
<tr>
<td style="text-align:center">ConnectInterceptor</td>
<td style="text-align:center">建立与服务器的连接</td>
</tr>
<tr>
<td style="text-align:center">CallServerInterceptor</td>
<td style="text-align:center">从服务器读取响应</td>
</tr>
</tbody>
</table>
<p>可以看出，整个网络请求的过程是通过各个拦截器相互配合来实现，假如我们在网络请求过程中设置允许缓存，那么在请求网络之前会预先获取缓存，然后再去跟服务器建立连接。通过拦截器的机制，我们可以很方便的控制整个网络请求的过程以及添加我们自己的拓展。</p>
<p>整个网络请求过程中，用户其实是可以添加两种不同类型的拦截器的。</p>
<ul>
<li>通过 addInterceptor()在网络请求前后添加拦截器</li>
<li>通过networkInterceptors()在获取响应前后添加拦截器</li>
</ul>
<p>这一点在getResponseWithInterceptorChain（）方法中添加拦截器的顺序是可以分析出来的。</p>
<h5 id="整体流程">整体流程</h5>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/21/16e8bf6522fc07a5?w=1064&amp;h=1004&amp;f=jpeg&amp;s=89681" alt=""><br>
图片来源:https://blog.n0texpecterr0r.cn/?p=717</p>
<h4 id="realinterceptorchain">RealInterceptorChain</h4>
<p>经过上面的分析我们知道okhttp的实际请求和响应过程是通过一个个拦截器的递归调用来实现的。主要方法就是</p>
<p>realInterceptorChain.proceed。我们先来看一下RealInterceptorChain的构造方法</p>
<pre><code class="language-kotlin">class RealInterceptorChain(
  private val interceptors: List&lt;Interceptor&gt;,
  private val transmitter: Transmitter,
  private val exchange: Exchange?,
  private val index: Int,
  private val request: Request,
  private val call: Call,
  private val connectTimeout: Int,
  private val readTimeout: Int,
  private val writeTimeout: Int
) 
</code></pre>
<p>这里其实是将上一个拦截器的一些参数传递进来并且赋值的简单实现。包括所有的拦截器、以及我们在第一篇文章提到的transmitter等。整个类中最关键的还是proceed方法</p>
<pre><code class="language-kotlin">  @Throws(IOException::class)
  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
    if (index &gt;= interceptors.size) throw AssertionError()
    calls++
    // If we already have a stream, confirm that the incoming request will use it.
    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
      &quot;network interceptor ${interceptors[index - 1]} must retain the same host and port&quot;
    }
    // If we already have a stream, confirm that this is the only call to chain.proceed().
    check(this.exchange == null || calls &lt;= 1) {
      &quot;network interceptor ${interceptors[index - 1]} must call proceed() exactly once&quot;
    }
    // Call the next interceptor in the chain.
    val next = RealInterceptorChain(interceptors, transmitter, exchange,
        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
    val interceptor = interceptors[index]
    @Suppress(&quot;USELESS_ELVIS&quot;)
    val response = interceptor.intercept(next) ?: throw NullPointerException(
        &quot;interceptor $interceptor returned null&quot;)
    // Confirm that the next interceptor made its required call to chain.proceed().
    check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) {
      &quot;network interceptor $interceptor must call proceed() exactly once&quot;
    }
    check(response.body != null) { &quot;interceptor $interceptor returned a response with no body&quot; }
    return response
  }
</code></pre>
<p>可以看到这个方法中除了大量的判读逻辑，比较关键的就是通过index+1取到下一个RealInterceptorChain对象 。</p>
<p>然后获取当前的拦截器并且调用其intercept方法 ，方法参数中传入了下一个拦截器的对应的chain。就是这样通过递归调用的设计，实现了由上而下，再由下而上实现了递与归的过程。从而非常漂亮的实现了http请求的全链路。</p>
<p>看到这里有没有觉得这种设计模式很熟悉，没错就是责任链模式。这种设计模式在一个流程会有多种操作的业务场景下会非常实用。</p>
<h4 id="总结">总结</h4>
<p>本篇文章我们主要是分析了整个网络请求过程中非常重要的getResponseWithInterceptorChain()方法，内部通过责任链的模式递归调用用户自定义拦截器和内置拦截器来完成整个网络请求。通过对整个方法的分析，我们会更清晰的知道ok内部是怎么实现通过设置拦截器来完成我们想要的功能的。同时也是我们学习责任链模式非常好的实践。后续文章将逐个分析ok内置拦截器的具体作用。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://blog.n0texpecterr0r.cn/?p=717">OkHttp 源码剖析系列（一）——请求的发起及拦截器机制概述</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(一)流程概述]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-yi-liu-cheng-gai-shu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-yi-liu-cheng-gai-shu">
        </link>
        <updated>2019-11-21T01:40:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="写在前面">写在前面</h4>
<p>本人从事Android开发工作几年，也算是见证了Android的技术变革。拿网络库来讲从最开始使用的xUtils到 <a href="https://github.com/google/volley">volley</a>然后到现在主流的<a href="https://github.com/square/okhttp">okhttp</a>。更不要说热更新、插件化、以及路由开发模式的大行其道。有感于工作中大多时候是仅限于使用,于是打算写一系列关于Android开发中使用到的框架解析，也算是对自己理解的一个记录。</p>
<h4 id="正文">正文</h4>
<p>网上看到一个观点：当我们想深入了解一个框架的时候，第一步是要会用，然后按照框架的流程图一步一步的去慢慢的探索分析。对于这个观点笔者是非常赞同的，优秀的框架都是有清晰的架构、核心思想也都采用了优秀的设计模式。下面我们从okhttp开始分析</p>
<ul>
<li>本系列文章基于okhttp4.2.2 (官方已使用kotlin进行重写)</li>
</ul>
<h3 id="发起一次简单的请求">发起一次简单的请求</h3>
<p>任何框架的学习第一步都是从会用开始，下面我们开始使用OKHTTP构建一个简单的访问百度的请求。</p>
<pre><code class="language-kotlin">   private fun makeCall() {
        val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .build()
        val request = Request.Builder()
            .url(&quot;http://www.baidu.com&quot;)
            .get()
            .build()
        okHttpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
            }

            override fun onResponse(call: Call, response: Response) {
            }
        })

    }
</code></pre>
<p>可以看到我们首先构造一个okhttpClient出来并设置一些超时时间、通过request设置请求的域名和请求方法。最后通过enqueue异步、或者excute同步的方式去进行请求。请求结果会通过接口回调的方式返回。</p>
<h4 id="okhttpclient">OkHttpClient</h4>
<p>字面意思非常好理解，okhttp的客户端。首先来看一下client的类注释。大概意思如下:</p>
<table><tr><td >
使用的时候最好构建一个单例的client去复用到所有的网络请求，因为每个client都会持有它自己的连接池和线程池。复用连接池可以减少延迟并且可以减少内存的消耗，同时通过newBuilder()方法构造出来的client可以很方便的共享一些配置如：connectTimeOut等
<br></br>
Tips:看到上面的注释，网络优化角度为什么要复用连接池也就可以很明白的理解了。
<td><tr></table>
<p>okhttpclient是通过建造者模式构造出来，上面的示例我们发现真正在使用的时候需要我们设置的项并不多，但其实client在构造的时候是有很多参数可以设置。</p>
<pre><code class="language-kotlin">    //异步请求什么时候执行的策略管理器
    internal var dispatcher: Dispatcher = Dispatcher()
    //管理http请求的连接来降低网络延迟的类
    internal var connectionPool: ConnectionPool = ConnectionPool()
    //一个网络请求拦截器
    internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //网络部分拦截器
    internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()
    //整个网络流程的监听器、我们可以通过设置整个监听来感知网络请求的质量、响应体大小以及持续时长等等。
    internal var eventListenerFactory: EventListener.Factory =      EventListener.NONE.asFactory()
    //连接失败时候是否重试
    internal var retryOnConnectionFailure = true
    //暂时没看懂是干嘛的，默认值是不添加，日常开发中也不会用到
    internal var authenticator: Authenticator = Authenticator.NONE
    //是否可以重定向
    internal var followRedirects = true
    //ssl是否可以重定向
    internal var followSslRedirects = true
    //这个字面意思理解就可以了 一般在请求中需要加入用户的token的时候会用到 默认是没有cookie
    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
    //网络请求的缓存策略
    internal var cache: Cache? = null
    //dns 一个网络请求过程中 会首先把域名解析成ip 这样客户端才知道往什么地址发起请求。
    internal var dns: Dns = Dns.SYSTEM
    //设置代理 
    internal var proxy: Proxy? = null
    //代理选择器 
    internal var proxySelector: ProxySelector? = null
    //跟上面一样  属于代理ip的一个属性
    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
    //socket 工厂 
    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
    //https 的socket 
    internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
    //证书信任管理器，一般为了防止https 握手失败我们会设置信任所有的证书
    internal var x509TrustManagerOrNull: X509TrustManager? = null
    //连接说明 指定socket连接时的一些配置 如：https还是http或者TLS的版本、密码来保证安全的连接
    internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS
    //连接时选择的协议 HTTP_1_0、HTTP_1_1、HTTP_2等
    internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS
    //域名验证的具体接口实现。如果客户端跟服务端的hostName不一致的时候选择是否接受的策略
    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
    //按照我的理解是用于信任加入中间代理 如charles这种的代理
    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
    //用于计算高效的证书链
    internal var certificateChainCleaner: CertificateChainCleaner? = null
    //调用超时时间
    internal var callTimeout = 0
    //连接超时时间 10_000 挺有意思的 是kotlin里面特有的写法
    internal var connectTimeout = 10_000
    //读数据超时时间
    internal var readTimeout = 10_000
    //写入流数超时时间
    internal var writeTimeout = 10_000
    //ping的间隔
    internal var pingInterval = 0
</code></pre>
<p>从上面可以看出其实okhttp内部帮我们封装了很多可以修改的配置，参数一般有默认值，通过建造者模式我们可以选择性的设置我们想要的配置。okhttp也是我们学习这种设计模式的一个比较好的实践。</p>
<p>构建client之后，我们会通过newCall方法传入一个Request 构造出一个Call.</p>
<pre><code class="language-kotlin"> override fun newCall(request: Request): Call {
    return RealCall.newRealCall(this, request, forWebSocket = false)
  }
</code></pre>
<h4 id="request">Request</h4>
<p>request字面意思就是请求的意思，那么一个请求会包含哪些信息呢？我们进去源码会发现其同样也是通过builder模式构建的。</p>
<pre><code class="language-kotlin">    internal var url: HttpUrl? = null
    internal var method: String
    internal var headers: Headers.Builder
    internal var body: RequestBody? = null
</code></pre>
<p>可以发现相对于client，request只有简单的几个参数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:center">代表此次请求的链接</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:center">代表当前请求的方法。如post、get、delete等</td>
</tr>
<tr>
<td style="text-align:left">headers</td>
<td style="text-align:center">一次请求中的头文件</td>
</tr>
<tr>
<td style="text-align:left">body</td>
<td style="text-align:center">请求体</td>
</tr>
</tbody>
</table>
<h4 id="call">Call</h4>
<p>我们通过client.newCall()方法构造出来了一个call对象 。实际上是调用了RealCall.newRealCall(this, request, forWebSocket = false).第三个参数是代表不支持webSocket，因为本身是http请求。这点在构建request时HttpUrl类也会有相同的判断，直接把webSocket转换为http请求。具体的使用socket的场景在后续会进行分析。</p>
<p>我们继续往下面看 newCall()方法到底做了什么事情:</p>
<pre><code class="language-kotlin">  fun newRealCall(
      client: OkHttpClient,
      originalRequest: Request,
      forWebSocket: Boolean
    ): RealCall {
      // Safely publish the Call instance to the EventListener.
      return RealCall(client, originalRequest, forWebSocket).apply {
        transmitter = Transmitter(client, this)
      }
    }
</code></pre>
<p>通过RealCall的构造方法实例出来一个realCall对象，字面意思可以知道后续的请求实际上是调用的realCall的对象。同时初始化了一个Transmitter。</p>
<h4 id="transmitter">Transmitter</h4>
<table><tr><td bgcolor=#f7f6f3>
应用层和网络层之间的桥梁，对外暴露了像connections/requests/responses/streams 所以我们可以方便的拿到这些对象做操作。再结合拦截器的作用也就很好理解了
</td></tr></table>
<h4 id="请求流程">请求流程</h4>
<p>我们知道okhttp是支持同步excute和异步enqueue的，那么内部究竟是怎么处理的呢？Android在某个版本之后已经不允许直接在主线程中进行网络请求了，所以我们这里直接分析异步请求的过程. 我们之前通过client.newCall已经构造出来Call对象。直接使用call.enqueue()就可以发起请求。Call定义的enqueue方法只是一个接口，具体实现是realCall中</p>
<pre><code class="language-kotlin">  override fun enqueue(responseCallback: Callback) {
    synchronized(this) {
      //首先会进行防止重复请求的判断
      check(!executed) { &quot;Already Executed&quot; }
      executed = true
    }
   //追溯进去会发现这步是回调eventListener的callStart方法，前文在介绍okhttpclient的构造方法时有提到过
    transmitter.callStart()
    //这里是请求真正发起的地方 
    client.dispatcher.enqueue(AsyncCall(responseCallback))
  }
</code></pre>
<h5 id="dispatcher">Dispatcher</h5>
<p>我们发现真正发起请求的地方是调用client里面的dispathcer对象执行enqueue方法，那dispatcher是什么鬼东东呢？我们继续来看注释：</p>
<pre><code class="language-kotlin">Policy on when async requests are executed.
用于管理异步请求什么时候执行的策略管理器
Each dispatcher uses an [ExecutorService] to run calls internally. If you supply your own
executor, it should be able to run [the configured maximum][maxRequests] number of calls concurrently.
每个dispatcher本质上是使用ExecutorService来进行请求的调用。
根据上面的注释我们还知道每个dispatcher其实是定义了一个最大请求并发数，默认是64
</code></pre>
<p>继续回到我们的主题:</p>
<pre><code class="language-kotlin">internal fun enqueue(call: AsyncCall) {
    synchronized(this) {
      readyAsyncCalls.add(call)
			
      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
      // the same host.
      if (!call.get().forWebSocket) {
        val existingCall = findExistingCallWithHost(call.host())
        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
      }
    }
    promoteAndExecute()
  }
</code></pre>
<p>首先是使用了同步锁来保证线程同步,然后把当前请求对象添加到了一个ArrayDeque双端队列里。</p>
<pre><code class="language-kotlin">  /** Ready async calls in the order they'll be run. */
  private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()

  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
  private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()

  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
  private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;()
</code></pre>
<p>我们可以看到ok其实是定义了三个双端队列：</p>
<ul>
<li>异步请求等待队列</li>
<li>异步请求执行队列</li>
<li>同步请求执行队列</li>
</ul>
<p>首先执行的异步请求必须不是webSocket的类型才继续往下走，下一步是寻找是否存在相同host的请求。这里是通过原子类型来保证相同host的请求可以准确记录下来。接着调用promoteAndExecute()来进行请求；</p>
<h5 id="promoteandexecute">promoteAndExecute</h5>
<pre><code class="language-kotlin">private fun promoteAndExecute(): Boolean {
  	//这里的写法很有意思，通过kotlin的assert来进行判断 不满足条件抛出一个异常，后续的开发其实可以借鉴。
    assert(!Thread.holdsLock(this))
  //构建一个空的AsyncCall list,AsyncCall 其实是自定义的runnable
    val executableCalls = mutableListOf&lt;AsyncCall&gt;()
    val isRunning: Boolean
    synchronized(this) {
      val i = readyAsyncCalls.iterator()
      while (i.hasNext()) {
        val asyncCall = i.next()

        if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity.
        if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // Host max capacity.

        i.remove()
        asyncCall.callsPerHost().incrementAndGet()
        executableCalls.add(asyncCall)
        runningAsyncCalls.add(asyncCall)
      }
      isRunning = runningCallsCount() &gt; 0
    }

    for (i in 0 until executableCalls.size) {
      val asyncCall = executableCalls[i]
      asyncCall.executeOn(executorService)
    }

    return isRunning
  }
</code></pre>
<p>大概总结一下这个方法做了什么事情:</p>
<ul>
<li>
<p>从上文说的异步请求准备队列中通过迭代的方式取出请求任务</p>
</li>
<li>
<p>判断并发请求是否超过最大数量</p>
</li>
<li>
<p>往计数器中增加一次计数</p>
</li>
<li>
<p>将call对象添加到executableCalls 以及 异步请求执行队列中</p>
</li>
<li>
<p>循环从executableCalls 取出asyncCall对象调用executeOn()方法</p>
</li>
</ul>
<h5 id="executeon">executeOn</h5>
<pre><code class="language-kotlin">   fun executeOn(executorService: ExecutorService) {
      assert(!Thread.holdsLock(client.dispatcher))
      var success = false
      try {
        executorService.execute(this)
        success = true
      } catch (e: RejectedExecutionException) {
        val ioException = InterruptedIOException(&quot;executor rejected&quot;)
        ioException.initCause(e)
        transmitter.noMoreExchanges(ioException)
        responseCallback.onFailure(this@RealCall, ioException)
      } finally {
        if (!success) {
          client.dispatcher.finished(this) // This call is no longer running!
        }
      }
    }
</code></pre>
<p>分析到这里已经很明确了，executeOn方法是通过executorService的execute()方法来执行一次异步请求。如果请求中抛出异常那么会调用dispatcher的finish方法来结束本次请求。</p>
<p>既然是通过异步执行，我们再来看一下run方法</p>
<pre><code class="language-kotlin">   override fun run() {
      threadName(&quot;OkHttp ${redactedUrl()}&quot;) {
        var signalledCallback = false
        transmitter.timeoutEnter()
        try {
          val response = getResponseWithInterceptorChain()
          signalledCallback = true
          responseCallback.onResponse(this@RealCall, response)
        } catch (e: IOException) {
          if (signalledCallback) {
            // Do not signal the callback twice!
            Platform.get().log(INFO, &quot;Callback failure for ${toLoggableString()}&quot;, e)
          } else {
            responseCallback.onFailure(this@RealCall, e)
          }
        } finally {
          client.dispatcher.finished(this)
        }
      }
    }
</code></pre>
<p>代码也同样很精简：</p>
<ul>
<li>
<p>通过getResponseWithInterceptorChain()方法来获取请求的响应体（关于这个方法将在后续文章详细分析）</p>
</li>
<li>
<p>通过接口回调将本次请求结果一层层回调给调用类</p>
</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上基本上是客户端构建请求、发起请求、以及请求的整体流程。我们可以大概整理一下整个流程做了哪些关键的步骤：</p>
<ul>
<li>
<p>客户端通过builder模式构建一个okHttpClient对象</p>
</li>
<li>
<p>客户端通过builder模式构建一个Request对象</p>
</li>
<li>
<p>通过okHttpClient.newCall(request:Request)方法来创建一个Call对象</p>
</li>
<li>
<p>通过call.enqueue(callBack:CallBack)来发起一次异步请求</p>
</li>
<li>
<p>请求时候是通过ExecutorService调用execute()方法来执行</p>
</li>
<li>
<p>最终拿到响应体回调给客户端</p>
</li>
</ul>
<p>当然真正请求的内部流程其实是要复杂的多，上面只是粗略的整理了一下，但是熟悉整个流程对于后面我们进入到okhttp核心代码分析的时候会更加有助于我们理解。以上就是okhttp源码分析的第一篇文章，后面会对每一步进行更详细的分析。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发板上TeamViewer的自动绑定]]></title>
        <id>https://alsowell.github.io//post/teamviewer-auto-bind</id>
        <link href="https://alsowell.github.io//post/teamviewer-auto-bind">
        </link>
        <updated>2019-11-05T01:44:52.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>  笔者目前从事的项目是线下无人值守的智能终端设备的开发，因此远程功能对异常调试以及异常恢复至关重要。固件经过修改出厂时就已经把teamviewer打入其中，且开发者可以获得root权限。正常流程出厂前会有人员将当前机器的远程绑定到公司账户下。但是如果固件经过恢复出厂设置的操作的话，那么远程就需要重新绑定，所以远程的自动绑定就特别重要。</p>
<!-- more -->
<p>  正常面对这种需求当然首先去找官方文档，但是翻遍Teamviewer提供的api接口也没有找到相关的实现;没办法只好拨打官方提供的技术支持电话进行咨询，经过了无数次的等待终于接通，但是技术人员的回复是不提供这个功能。</p>
<p>  在官方支持无果的情况下，笔者只好寻找其他的解决思路，通常面对这种问题第一个解决思路是通过抓包去分析绑定流程的数据传输进行解决。拿到所属账户的用户id以及设置的唯一标识：AndroidID去进行模拟绑定。</p>
<p>调起应用：</p>
<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572922168223.jpg" alt=""></figure>
<p>点击分配：</p>
<figure data-type="image" tabindex="2"><img src="https://alsowell.github.io//post-images/1572922822275.jpg" alt=""></figure>
<p>分配成功:</p>
<figure data-type="image" tabindex="3"><img src="https://alsowell.github.io//post-images/1572922885806.jpg" alt=""></figure>
<p>  注：笔者公司绑定TeamViewer的方式为通过打开teamviewer分配的固定的url链接通过浏览器调起Teamviewer应用进行绑定。</p>
<p>  通过抓包可以发现绑定时候去先获取当前机器所属的账户组，然后点击分配按钮时通过获取当前机器的信息去服务器进行当前账户的分配。分配成功后会返回当前机器的远程id和连接时候的密码。<br>
分析到这里好像已经解决了我们的需求。但是理想很丰满，现实很骨感。一顿骚操作以后发现模拟数据去请求后台也并不能在后台显示这台绑定的设备，这种方法宣告失败。</p>
<p>  我们再回头分析一下,Teamviewer内部的绑定并不是透明的，我们仅仅通过抓包的数据去进行hook好像并不代表它内部的所有流程。可能在进行网络请求后还进行了其他的操作，但是我们并不能知道。分析到这里下一步好像应该去做反编译去获取到它内部的流程操作。但是笔者再一顿骚操作后发现其内部进行了混淆，并且之前对反编译也没有什么研究，那么这种解决思路暂时先放一放。</p>
<p>  我们再分析一下正常绑定的流程，手动打开一个链接-&gt;通过浏览器调起应用-&gt;点击应用内的分配按钮-&gt;分配成功。整个过程关键的一步是手动点击按钮去实现。机智的你可能已经知道我们下一步的思路是通过模拟点击去进行自动绑定的实现。</p>
<p>  但是模拟点击的实现有个问题，我们不可能每次开机以后都去进行一次模拟点击的操作，在已经绑定的情况下再去做重复的点击无疑是多此一举。那么就需要去分析是否已经绑定过，正常的思路有两个：</p>
<ul>
<li>通过api去获取当前机器是否已经绑定</li>
<li>本地是否有数据记录是否绑定</li>
</ul>
<p>  毫无疑问去分析本地数据会更快一点，再结合之前说到的情况：机器恢复出厂设置的情况下已经绑定的远程会失效。那么我们可以分析得知本地肯定会存储一些必要的数据。那我们直接去data/data 里面去找一下。找了半天，终于在/data/data/com.teamviewer.host.market/files/global.conf路径下面发现了点东西。</p>
<figure data-type="image" tabindex="4"><img src="https://alsowell.github.io//post-images/1572931170363.jpg" alt=""></figure>
<!-- more -->
<p>  可以发现OwningManagerAccountName和OwningManagerCompanyName表示当前所属账户信息的。在没有绑定的情况下这两个字段是不存在的。那么问题就解决了。在每次开机时通过判断这两个字段是否去需要绑定。<br>
  是否绑定的问题已经解决了，那么接下来就到了重点。上面的流程分析提到：显示弹窗-&gt;点击弹窗——&gt;绑定完成。首先是判断是否已经进入到绑定的承载界面:</p>
<pre><code class="language-kotlin">    private fun getTopService(): Boolean {
        val exec = Shell(true).exec(&quot;dumpsys activity | grep  mFocusedActivity&quot;)
        return exec.message.contains(&quot;com.teamviewer.host.ui.HostActivity&quot;)
    }
</code></pre>
<h3 id="判断弹窗">判断弹窗</h3>
<p>  通过获取位于栈顶的进程来判断是否浏览器成功调起应用，然后是判断弹窗是否显示以及按钮的位置，方法比较多：1.我们知道Android的窗口都是通过WinddowManager来管理的，WindowManager是一种方式；<br>
2.另外一种方法是通过uiautomatorviewer来获取。这里着重讲一下uiautomatorviewer的方式。平常在开发过程中我们经常会使用Android sdk tools下面的uiautomatorviewer来获取当前屏幕正在显示的View层级关系以及所属位置。<br>
<img src="https://alsowell.github.io//post-images/1572934681994.jpg" alt=""><br>
<img src="https://alsowell.github.io//post-images/1572934977185.jpg" alt=""></p>
<p>  同样的我们可以直接在Android 的shell环境下直接执行</p>
<pre><code class="language-kotlin"> Shell(true).exec(&quot;uiautomator dump&quot;)
</code></pre>
<p>  执行这个命令，会直接在sdcard下生成一个window_dump.xml文件。我们通过解析xml分析出来当前是否处于弹窗状态以及需要模拟点击的按钮位置。</p>
<h3 id="模拟点击">模拟点击</h3>
<p>  说到模拟点击，你脑子里第一个想到的是什么？大多数情况下可能想到的都是AccessibilityService。AccessibilityService根据官方的介绍，是指开发者通过增加类似contentDescription的属性，从而在不修改代码的情况下，让残障人士能够获得使用体验的优化，大家可以打开AccessibilityService来试一下，点击区域，可以有语音或者触摸的提示，帮助残障人士使用App（这段介绍是我抄的）。但是AccessibilityService使用的前提是需要用户手动授权，Android默认是关闭的，对于笔者的业务场景是无法满足需求的。</p>
<p>  那可以考虑另外一种思路，直接输入input事件。我们在平常开发中经常会用到adb shell input tap xx xx 来表示一个点击事件。xx xx 代表Android坐标系下的坐标。同样的还有swipe代表滑动。插一句题外话 adb shell 工具使用的好对于平常的开发是大有裨益的。</p>
<pre><code class="language-kotlin">Shell(true).exec(&quot;input tap xxx xxx&quot;)
</code></pre>
<p>  到此，我们已经解决了模拟点击的步骤。点击完成再去本地文件中看一下发现所属的账户信息已经写入成功了。同时在后台也发现了这台设备已经在线，可以愉快的连接上去搞事情啦。</p>
<h3 id="结语">结语</h3>
<p>  以上就是笔者面对这个需求从懵逼到最后实现整个需求的过程。事后看来有很多没有按照Android开发规范来进行操作，如获取弹窗是直接dump出xml来进行解析而不是通过WindowManager来进行操作。但是想分享的是整个需求的实现思路。希望能对你有一点点帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android WebView的一些优化]]></title>
        <id>https://alsowell.github.io//post/android-webview</id>
        <link href="https://alsowell.github.io//post/android-webview">
        </link>
        <updated>2019-11-04T11:45:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-h5容器">Android H5容器</h1>
<p>  WebView是android上面加载h5界面的基础组件。4.4之前使用webkit作为内核,之后采用Chromium内核。高版本的内核在性能以及流畅性方面均会有较大提升。</p>
<p>  android上查看当前WebView内核版本的两种方式：</p>
<ul>
<li>chrome浏览器输入  chrome://inspect</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://alsowell.github.io//post-images/1572868102476.png" alt=""></figure>
<ul>
<li>adb shell am start -a android.intent.action.VIEW -d  https://liulanmi.com/labs/core.html<br>
<img src="https://alsowell.github.io//post-images/1572868135876.png" alt=""></li>
</ul>
<h3 id="性能优化">性能优化</h3>
<p>  一个正常的natvie使用WebView加载网页的流程如下:<br>
<img src="https://alsowell.github.io//post-images/1572868151124.png" alt=""></p>
<p>  接下来将围绕整个WebView加载流程来进行android端的一些优化。</p>
<h4 id="webview单独进程进行加载">webview单独进程进行加载</h4>
<p>   WebView采用单独进程进行,App中大量Web页面的使用容易导致App内存占用巨大，存在内存泄露，崩溃率高等问题，WebView独立进程的使用是解决Android WebView相关问题的一个合理的方案。</p>
<p>  下图为加载WebView前后内存占用对比（仅打开百度首页）,可以观察,对大内存应用来讲WebView在不断打开网页过程中产生的内存极有可能造成OOM.</p>
<ul>
<li>未加载webview<br>
<img src="https://alsowell.github.io//post-images/1572868163142.png" alt=""></li>
<li>webview打开百度<br>
<img src="https://alsowell.github.io//post-images/1572868178190.png" alt=""></li>
</ul>
<p>   主流的方案都是直接采用新开activity单独进程进行WebView加载方案来进行优化。但是针对于单Activity+多fragment架构中,此方案就不能采用在Activity中开启多进程的方式来进行优化。</p>
<p>  开启多进程的方式有两种：</p>
<ul>
<li>通过在manifest中声明的方式开启。</li>
<li>通过Jni fork的方式产生,此方式难度较大。</li>
</ul>
<p>  考虑到Android四大组件中均可以通过声明的方式进行多进程的创建,可采用在service中动态创建WebView 然后动态添加到WindowManager中（此步需要有悬浮窗权限）。</p>
<h4 id="预加载优化">预加载优化</h4>
<p>  关于WebView加载耗时,分别测试直接加载webview预先加载webview时间对比。</p>
<ul>
<li>直接加载webview
<ul>
<li>通过动态添加view形式模拟webview启动耗时</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">			val startTime = System.currentTimeMillis()
            val webView = WebView(this)
            cl.addView(webView)
            val layoutParams = webView.layoutParams
            layoutParams.width=ViewGroup.LayoutParams.MATCH_PARENT
            layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT
            webView.layoutParams=layoutParams
            webView.loadUrl(&quot;http://www.baidu.com&quot;)
            webView.webViewClient = object : WebViewClient() {
                override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                    super.onPageStarted(view, url, favicon)
                    val loadTime = System.currentTimeMillis() - startTime
                    Log.d(TAG,&quot;time:$loadTime&quot;)
                }
            }

06-27 16:58:22.353 30779-30779/? D/WebViewLoad: time:488

</code></pre>
<ul>
<li>预加载WebView性能
<ul>
<li>通过预先在service中预先加载一个WebView</li>
</ul>
</li>
</ul>
<pre><code class="language-kotlin">

val startTime = System.currentTimeMillis()
Log.d(TAG,&quot;preLoad start:$startTime&quot;)
val intent = Intent(this, WebViewService::class.java)
intent.action = &quot;load&quot;
startService(intent)

// service代码

if (intent?.action == &quot;load&quot;) {
 webview.webViewClient= object : WebViewClient() {
 override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
 super.onPageStarted(view, url, favicon)
 Log.d(&quot;WebViewLoad&quot;, &quot;当前时间：${System.currentTimeMillis()}&quot;)
             }
       }
webview.loadUrl(&quot;http://www.baidu.com&quot;)
}

06-27 17:22:11.606 19569-19569/net.example.webview D/WebViewLoad: preLoad start:1561627331606
06-27 17:22:11.642 19569-19569/net.example.webview D/WebViewLoad: 当前时间：1561627331642
result:36
</code></pre>
<p>  可以看到WebView的动态加载创建会耗费大量时间,因此在Android端可以全局创建一个WebView避免重复的资源开销,但随之而来伴随着可能造成的内存泄露需要在开发时注意。</p>
<h4 id="缓存优化">缓存优化</h4>
<p>  打开H5网页的过程中往往伴随着大量的js请求以及图片等占用网络的请求,并且每个请求都是串行进行的,这样的实现不仅耗费流量并且在网络情况不佳的情况下对用户带来的观感就是极其影响体验。<br>
  Android WebView本身已经支持5种缓存策略。</p>
<ul>
<li>浏览器 缓存机制</li>
<li>Application Cache 缓存机制</li>
<li>Dom Storage 缓存机制</li>
<li>Web SQL Database 缓存机制</li>
<li>Indexed Database 缓存机制</li>
</ul>
<p>  对于Android开发来说设置缓存最常用的方式是<br>
获取WebView的setting设置缓存模式</p>
<pre><code class="language-kotlin">	WebSettings.LOAD_DEFAULT
	WebSettings.LOAD_NO_CACHE
	WebSettings.LOAD_CACHE_ELSE_NETWORK
	WebSettings.LOAD_CACHE_ONLY
    WebSettings.LOAD_NO_CACHE
   
</code></pre>
<p>缓存模式具体分析<a href="https://www.jianshu.com/p/5e7075f4875f">参考</a></p>
<p>  Android端如何实现一套更自己可控制的缓存方案,H5页面中每个网络请求的均会回调</p>
<pre><code class="language-kotlin">override fun shouldInterceptRequest(view: WebView?, request: WebResourceRequest?): WebResourceResponse?
</code></pre>
<ul>
<li>优化方案
<ul>
<li>通过重写shouldInterceptRequest方法对特定资源进行本地文件缓存复用</li>
<li>实现方案
<ul>
<li>针对特定类型后缀文件HTML、Javascript、CSS、png等网络请求进行拦截使用nativie本身okhttp等网络框架库,同时针对下载文件进行本地缓存策略管理 如：LruDiskCache</li>
<li>h5端逻辑代码 js、cs变更如果未变更链接 此时代码仍然不是最新,此方案需要跟前端约定好版本概念。</li>
<li>shouldInterceptRequest是WebView维护线程进行异步请求，所以可以放心耗时操作</li>
</ul>
</li>
<li>具体优化实现<a href="https://github.com/yale8848/CacheWebView">可参考CacheWebView</a></li>
</ul>
</li>
</ul>
<h4 id="jsbridge">JsBridge</h4>
<ul>
<li>
<p>Android和Js通过WebView.addJavascriptInterface()进行映射</p>
<ul>
<li>
<p>Android端 需要在设置WebSetting是允许调用js方法,然后通过动态注册的方式把natvie提供的方法注册进bridge中</p>
<ul>
<li>settings.javaScriptEnabled=true</li>
<li>webView.addJavascriptInterface()</li>
</ul>
<pre><code class="language-kotlin">
web_view.addJavascriptInterface(JsInterface(), &quot;client&quot;)

inner class JsInterface {
@JavascriptInterface
fun backToMall() {
    runOnUiThread {
        Toast.makeText(this@MainActivity,&quot;back&quot;,Toast.LENGTH_SHORT).show()
    }
    Log.d(&quot;bigScreen&quot;, &quot;返回拍照&quot;)
    val open = LauncherHelper.instance.open(&quot;net.changjinglu.mall&quot;, &quot;net.changjinglu.mall.HomeActivity&quot;)
    if (open == 0) {
        Log.d(&quot;bigScreen&quot;, &quot;跳转成功&quot;)
        destroyWebView()
    } else {
        Log.d(&quot;bigScreen&quot;, &quot;跳转失败 返回:$open&quot;)
    }
}
@JavascriptInterface
fun loadComplete() {
    Log.d(&quot;bigScreen&quot;, &quot;页面加载完成&quot;)
    hasLoadSuccess.set(true)
}
</code></pre>
</li>
</ul>
<p>}</p>
<pre><code>  ```
</code></pre>
<ul>
<li>
<p>JS端调用</p>
<pre><code class="language-javascript">window.client.loadComplete()

</code></pre>
</li>
<li>
<p>Android调用Js方法写法：</p>
<pre><code class="language-kotlin">	//通知h5端网络状态变化
   web_view?.loadUrl(&quot;javascript:isOnLine(true)&quot;)
   
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url</p>
<ul>
<li>其中代表<a href="https://github.com/lzyzsd/JsBridge">JsBridge</a></li>
</ul>
</li>
<li>
<p>WebChromeClient 的onJsPrompt()、onJsAlert()、onJsConfirm() 与第二种方法类似</p>
</li>
</ul>
<h4 id="离线包">离线包</h4>
<p>  离线包的概念即客户端与H5端和服务端共同约定好的一套协议。h5开发完后打包为静态资源通过服务端的配置接口通知到客户端。客户端通过提前拉取的方式进行资源的下载,在客户端真正打开的时候通过shouldInterceptRequest()方法来直接读取本地资源,基本能够达到秒开的优化。</p>
<p>  此外,在离线包的基础上还可以根据H5每次发布版本的差异进行H5离线包中css、js等资源的差分化,由客户端本地进行增量更新,这样每次下载的文件将会消耗较少的流量。</p>
<p>  而且，在某个高版本H5离线包发现问题时可以通过事前定义好的jsbridge强制降级到客户端的某个低版本。</p>
<ul>
<li>方案难点
<ul>
<li>需要多端协同、共同遵守协议。</li>
<li>差分包需要H5端有版本管理平台</li>
<li>需要考虑h5端版本发布通知到客户端的到达率问题</li>
</ul>
</li>
</ul>
<h4 id="安全性优化">安全性优化</h4>
<ul>
<li>
<p>http 与https混合</p>
<ul>
<li>android5.0后如果网页请求中同时包含http与https可能会出现无法加载的情况
<ul>
<li>解决方案:websetting 设置mixcontent</li>
</ul>
<pre><code class="language-kotlin">settings.mixedContentMode=WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
</code></pre>
</li>
</ul>
</li>
<li>
<p>网页劫持</p>
<ul>
<li>网页劫持一般出现原因为h5界面出现广告等不相干元素</li>
<li>出现原因一般为DNS污染(解析到错误域名)或者因为http劫持</li>
<li>解决办法：
<ul>
<li>全局替换为更安全的HTTPS</li>
<li>上面有说道Android所有请求都会走到shouldInterceptRequest方法,可以通过使用阿里云的httpDns服务首先对host进行一次域名解析然后将host替换为IP进行请求 此种情况可避免Dns被污染或者http劫持问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
    ......
      URL url = new URL(request.getUrl().toString());
      conn = (HttpURLConnection) url.openConnection();
      // 接口获取IP
      String ip = httpdns.getIpByHostAsync(url.getHost());
      if (ip != null) {
        // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
        Log.d(TAG, &quot;Get IP: &quot; + ip + &quot; for host: &quot; + url.getHost() + &quot; from HTTPDNS successfully!&quot;);
        String newUrl = path.replaceFirst(url.getHost(), ip);
        conn = (HttpURLConnection) new URL(newUrl).openConnection();
        // 添加原有头部信息
        if (headers != null) {
          for (Map.Entry&lt;String, String&gt; field : headers.entrySet()) {
            conn.setRequestProperty(field.getKey(), field.getValue());
          }
        }
        // 设置HTTP请求头Host域
        conn.setRequestProperty(&quot;Host&quot;, url.getHost());
      } 
}

</code></pre>
<p>  更详细解决办法<a href="https://help.aliyun.com/document_detail/60181.html">参考</a></p>
]]></content>
    </entry>
</feed>