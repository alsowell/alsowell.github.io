<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alsowell.github.io/</id>
    <title>ALSOWELL`Blog</title>
    <updated>2019-12-20T12:31:30.565Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alsowell.github.io/"/>
    <link rel="self" href="https://alsowell.github.io//atom.xml"/>
    <subtitle>Never Stop</subtitle>
    <logo>https://alsowell.github.io//images/avatar.png</logo>
    <icon>https://alsowell.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, ALSOWELL`Blog</rights>
    <entry>
        <title type="html"><![CDATA[再学Android：handler机制流程分析]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidhandler-ji-zhi-liu-cheng-fen-xi</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidhandler-ji-zhi-liu-cheng-fen-xi">
        </link>
        <updated>2019-12-17T08:59:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p><code>Handler</code>对于Android开发者来说都不陌生，其本身是Android自带的内部消息机制，通过构建一个<code>Message</code>对象，获取到handler，然后sendMessage这样就可以很方便的做到线程间的通信。那么其内部究竟怎么实现的，今天就来瞅一瞅。</p>
<h4 id="handler">Handler</h4>
<p><code>Handler</code>其实并不复杂，其源码也仅仅只有不到1000行，相对于View几万行的源码，真的算是小巫见大巫了。首先来看一下类注释：</p>
<table><tr><td bgcolor="#f7f6f3">
对于handler来说主要有两个用途:<br>
1.循环执行任务。<br>
2.执行与当前线程不同的线程发送过来的指令，也就是线程间的通信
</td></tr></table>
<h5 id="关于使用">关于使用</h5>
<p>还是从使用来进行分析:</p>
<pre><code class="language-kotlin">    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val handler = MyHandler(WeakReference(this))
        val message = Message()
        message.what = 1
        message.obj = &quot;test&quot;
        handler.sendMessage(message)
    }
        private class MyHandler(val activity: WeakReference&lt;Activity&gt;) : Handler() {
        override fun handleMessage(msg: Message) {
            super.handleMessage(msg)
            when (msg.what) {
                1 -&gt; {
                    val get = activity.get()
                    get?.runOnUiThread {
                        Toast.makeText(get, msg.obj.toString(), Toast.LENGTH_SHORT).show()
                    }
                }
                else -&gt; {
                }
            }
        }
    }
</code></pre>
<p>可以看到，关于handler的使用也是非常简单的，在Activity的<code>onCreate()</code>方法中会初始化一个自定义的handler对象，然后构造一个message对象，紧接着通过<code>sendMessage()</code>方法去发送，然后在我们自定义的匿名静态内部类中去处理这个消息。至于为什么在activity中我们使用的是匿名静态内部类的方式，其实是如果handler使用不当会造成内存的泄漏。</p>
<p>其实除了sendMessage之外，handler还可以post一个<code>runnable</code>。但是你观察源码会发现其内部都是通过调用senMessaggeAtTime的方法。后面我们会详细分析，接下来会先从构造开始。</p>
<h5 id="初始化handler">初始化handler</h5>
<pre><code class="language-java">    public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class&lt;? extends Handler&gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
</code></pre>
<p>可以看到，handler在初始化的时候首先会对调用者的使用方式进行判断，比方说我们直接在activity中去初始化一个<code>handler</code>但是并没有在静态匿名内部类中去接收消息，那么就有可能造成内存泄漏，因为会持有activity的应用，导致并没有被销毁。仅接着通过<code>Looper.myLooper()</code>拿到当前线程的looper对象，如果looper为null会直接抛出异常。</p>
<p>关于Looper，这里有两个点:</p>
<ul>
<li>我们在子线程中使用handler中需要手动调用looper.prepare和looper.loop 这样才能进行消息的循环。</li>
<li>而在主线程中我们可以直接使用的原因是应用在启动的时候，在<code>ActivityThread</code>的main方法中系统已经调用过looper.prepareMainLooper方法和loop方法。</li>
</ul>
<p>回到handler的初始化，接着就是将looper中的MessageQueue对象赋值到当前，以及一些其他参数的设置。到这里关于handler的初始化就已经完成了。</p>
<h5 id="looper">Looper</h5>
<p>上文有说到looper，handler的使用必须保证当前线程的looper已经被prepare并且loop方法也被调用。因为handler的核心就是一个死循环，不断的从队列中取出任务，关于这点后面会讲到。</p>
<p>还是来看一下<code>Looper</code>的类注释：</p>
<table><tr><td bgcolor="#f7f6f3">
一个用来做线程内消息循环的类，线程默认并没有一个looper对象与之管理，通过prepare去创建一个looper对象，然后通过loop方法去进行消息循环，知道线程终止。
</td></tr></table>
<h5 id="looperprepare">Looper.prepare()</h5>
<pre><code class="language-java">    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
    
        private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }
</code></pre>
<p>prepare的时候首先会通过threadLocal去判断当前是否已经存在一个looper对象，每个线程都只允许存在一个looper。<a href="http://www.jasongj.com/java/threadlocal/">关于ThreadLocal</a>。紧接着通过new looper的方式去初始化实例，并将其放入到threadLocal中。在初始化的时候也会去初始化一个MessageQueue对象。</p>
<h5 id="looperloop">Looper.loop()</h5>
<pre><code class="language-java">        for (;;) {
            //暂时去除代码
        }
</code></pre>
<p>loop方法中有一个很重要的地方，就是这里的死循环，这里会不断的通过Message的next方法去取出需要执行的任务。关于相似分析见下文。我们先按照调用顺序来进行分析</p>
<h4 id="sendmessageattime">sendMessageAtTime()</h4>
<p>上文中有说到，不管是调用sendMessage还是post(runnable run)方法最终都是会调用handler中的sendMessageAtTime方法，读者可以自己看一下，这里就不截图了。</p>
<pre><code class="language-java">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
</code></pre>
<p>这里的代码也是很简单啊，拿到MessageQueue对象进行了一次判断是否为null。然后调用enqueueMessage方法，哦 这里的Boolean返回值为是否成功将消息添加到队列的意思。再补充一下，当通过handler.post调用时，内部会构造一个Message对象，然后将runnable放入到Message中继续后面的步骤。</p>
<h5 id="enqueuemessage">enqueueMessage</h5>
<pre><code class="language-java">    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
</code></pre>
<p>enqueueMessage内部也只是调用MessageQueue的enqueueMessage方法。</p>
<pre><code class="language-java">    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<p>说了这么久终于要进入关键步骤了。</p>
<ul>
<li>
<p>首先判断是否有target，target默认是当前的Handler对象</p>
</li>
<li>
<p>判断是否是已经放进来过。如果已经存入就抛出异常</p>
</li>
<li>
<p>使用<code>synchronized</code>来进行线程同步</p>
</li>
<li>
<p>接着判断当前thread是否已经处于dead的状态</p>
</li>
<li>
<p>把当前的Message标记为use状态</p>
</li>
<li>
<p>给Message设置执行时间。</p>
<ul>
<li>注意这个执行时间并不是系统当前的时间而是SystemClock.uptimeMillis()，其是系统开机到目前的时间，期间不包括休眠的时间，这里获得的时间是一个相对的时间。使用这种方式而不是当前时间是因为handler会受到阻塞、挂起、睡眠等待。这种情况下，delay的事件时不应该被执行的</li>
</ul>
</li>
<li>
<p>先判断当前有没有任务正在执行或者当前是个需要马上被执行的消息、或者当前的消息比马上正要执行的消息的when要小。</p>
<ul>
<li>上面可能有点难以理解，大家可以想一下，我们使用handler的过程中可能会post很多延时消息同时也会直接send一个message，如果Post在send之前调用，那么MessageQueue内部就需要判断在同一个线程中的任务的执行顺序。</li>
</ul>
</li>
<li>
<p>如果没有满足上面的条件，那么就把当前的消息根据when的大小来进行排序插入到当前的链表中。</p>
</li>
<li>
<p>然后通过needWake参数来判断是否需要唤醒执行任务。</p>
</li>
</ul>
<p>以上就是整个将Message添加到队列中的全部过程。</p>
<h4 id="消息的分发">消息的分发</h4>
<p>经过上文的分析我们知道handler是通过looper的loop方法从MessageQueue中取到需要执行的任务，然后执行。那么就来看一下具体实现：</p>
<pre><code class="language-java">        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                        msg.callback + &quot;: &quot; + msg.what);
            }

            final long traceTag = me.mTraceTag;
            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
            if (thresholdOverride &gt; 0) {
                slowDispatchThresholdMs = thresholdOverride;
                slowDeliveryThresholdMs = thresholdOverride;
            }
            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);
            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);

            final boolean needStartTime = logSlowDelivery || logSlowDispatch;
            final boolean needEndTime = logSlowDispatch;

            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }

            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
            final long dispatchEnd;
            try {
                msg.target.dispatchMessage(msg);
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
            if (logSlowDelivery) {
                if (slowDeliveryDetected) {
                    if ((dispatchStart - msg.when) &lt;= 10) {
                        Slog.w(TAG, &quot;Drained&quot;);
                        slowDeliveryDetected = false;
                    }
                } else {
                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,
                            msg)) {
                        // Once we write a slow delivery log, suppress until the queue drains.
                        slowDeliveryDetected = true;
                    }
                }
            }
            if (logSlowDispatch) {
                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);
            }

            if (logging != null) {
                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                        + Long.toHexString(ident) + &quot; to 0x&quot;
                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                        + msg.target.getClass().getName() + &quot; &quot;
                        + msg.callback + &quot; what=&quot; + msg.what);
            }

            msg.recycleUnchecked();
        }
</code></pre>
<p>首先通过queue.next方法取出一个任务，然后通过<code>msg.target.dispatchMessage(msg);</code>进行消息的分发；整个过程好像是非常简单的。这里有几个点比较有意思</p>
<ul>
<li>在进行消息分发的前后会通过<code>SystemClock.uptimeMillis()</code>来获取到系统开机到目前的时间(不包括被阻塞和挂起的时间)来进行必要的日志输出。</li>
<li>最终将已经分发过的消息进行recycle</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上就是整个handler的大概流程分析，当然可能还存在一些不严谨的地方，只是作为本人对于handler理解的一些记录。如果有错误的地方，希望海涵。</p>
<h4 id="拓展">拓展:</h4>
<h5 id="为什么handlerpostdelay方法不会造成anr呢">为什么handler.postDelay方法不会造成ANR呢？</h5>
<ul>
<li>Looper.loop( )是会让主线程进入死循环。但是不会卡主程序，卡住程序主要是handleMessage处理消息的时候来不及处理导致的。Android的消息处理机制是事件驱动型的。</li>
</ul>
<h5 id="应用在使用过程中发生了anr-是发生在哪个方法">应用在使用过程中发生了ANR 是发生在哪个方法？</h5>
<ul>
<li>通过上面的分析，消息的分发都是通过dispatchMessage来做的，所以如果发生了anr都会在这里产生。</li>
</ul>
<h4 id="参考资料">参考资料</h4>
<p><a href="http://www.jasongj.com/java/threadlocal/">Java进阶（七）正确理解Thread Local的原理与适用场景</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：Activity启动流程]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidactivity-qi-dong-liu-cheng</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidactivity-qi-dong-liu-cheng">
        </link>
        <updated>2019-12-11T07:12:46.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>Android开发最常接触到的就是activity了，关于activity的启动也一直是面试中问道比较多的问题。在之前的文章中有分析过应用的启动流程，对于activity的启动也只是一笔带过，本篇文章将更详细的分析activity启动的整体流程。首先看一张流程图：<br>
<img src="https://i.loli.net/2019/12/10/WDVUioF2hgsaeNz.png" alt=""></p>
<h4 id="流程分析">流程分析</h4>
<p>我们在应用启动流程中说过Android中通过<code>zygote</code>孵化出来的应用进程是通过<code>ActivityThread</code>来绑定进程的，那么就先来看一下<code>ActivityThread</code>。</p>
<h5 id="activitythread">ActivityThread</h5>
<p>注：本文分析是基于Android api 28.<br><br>
Android与Java不同的地方在于系统并没有暴露<code>main()</code>方法出来，但是它毕竟是个爪哇，在<code>ActivityThread</code>中可以看到是有<code>main()</code>方法的实现的。</p>
<h6 id="main方法">main方法</h6>
<p>在main方法中首先会进行<code>Looper.prepareMainLooper();</code>进行主线程的初始化，这也就是为什么主线程不需要我们手动调用looper.prepare()。子线程中获取handler就需要调用的原因。接着是构造出来一个<code>ActivityThread</code>对象。紧接着调用<code>attach()</code>方法来进行activityThread和进程的绑定，然后开始调用<code>looper.loop()</code>来进行消息队列的循环。</p>
<h6 id="attach方法">attach方法</h6>
<pre><code class="language-java">    private void attach(boolean system, long startSeq)
</code></pre>
<p>attach方法是有两个参数的，<code>system</code>代表是否为系统进程，一般我们开发的应用都是属于用户进程的。</p>
<ul>
<li>
<p>用户进程</p>
<ul>
<li>首先会调用<code>ensureJitEnabled()</code>方法，还记得我们在<a href="https://alsowell.github.io/post/zai-xue-androidxi-tong-kai-ji-liu-cheng/">再学Android：系统开机流程</a>的拓展中介绍过不同版本Android系统的虚拟机变更，在Android7.0以上，Google又把jit编译模式添加了回来，用于更快的安装应用，并且配合art模式可以保证运行效率。</li>
<li>接着通过binder机制获取到ams的<strong>代理实例</strong><pre><code class="language-java">//attach 方法中获取代理实例
final IActivityManager mgr = ActivityManager.getService();
//跟踪进去ActivityManager 
    public static IActivityManager getService() {
    return IActivityManagerSingleton.get();
}
//通过ipc调用 获取到系统提供的ams服务，是不是很熟悉？
private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
        new Singleton&lt;IActivityManager&gt;() {
            @Override
            protected IActivityManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                final IActivityManager am = IActivityManager.Stub.asInterface(b);
                return am;
            }
        };
</code></pre>
</li>
<li>接着通过获取到的代理对象调用<code>attachApplication()</code>方法</li>
</ul>
<pre><code class="language-java">
    public final void attachApplication(IApplicationThread thread, long startSeq) {
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid, callingUid, startSeq);
        Binder.restoreCallingIdentity(origId);
    }
}
</code></pre>
<ul>
<li>可以看到是通过<code>attachApplicationLocked()</code>方法来进行thread与application的绑定。</li>
</ul>
</li>
<li>
<p>系统进程</p>
<pre><code class="language-java">try {
mInstrumentation = new Instrumentation();
mInstrumentation.basicInit(this);
ContextImpl context = ContextImpl.createAppContext(
        this, getSystemContext().mPackageInfo);
mInitialApplication = context.mPackageInfo.makeApplication(true, null);
mInitialApplication.onCreate();
} catch (Exception e) {
    throw new RuntimeException(
            &quot;Unable to instantiate Application():&quot; + e.toString(), e);
}
</code></pre>
<p>从上面的关键代码可以看到，首先是初始化了一个<code>Instrumentation()</code>，关于这个东西后面有机会会讲到。然后通过<code>ContextImpl</code>创建了application的context,紧接着通过<code>makeApplication()</code>方法构造出来一个application实例，然后调用其onCreate方法。关于详细分解，我们留待下文。</p>
</li>
</ul>
<h4 id="用户进程绑定application">用户进程绑定Application</h4>
<p>我们这里着重来分析下用户进程的进程绑定，上文说到我们获取到<code>ActivityManagerService</code>的代理实例，然后调用其<code>attachApplication()</code>方法。<code>attachApplication</code>又是调用<code>attachApplicationLocked</code>来进行进程绑定。这里有一个关键参数<code>IApplicationThread</code>。</p>
<pre><code class="language-java">thread.bindApplication(processName, appInfo, providers,
        app.instr.mClass,
        profilerInfo, app.instr.mArguments,
        app.instr.mWatcher,
        app.instr.mUiAutomationConnection, testMode,
        mBinderTransactionTrackingEnabled, enableTrackAllocation,
        isRestrictedBackupMode || !normalMode, app.persistent,
        new Configuration(getGlobalConfiguration()), app.compat,
        getCommonServicesLocked(app.isolated),
        mCoreSettingsObserver.getCoreSettingsLocked(),
        buildSerial, isAutofillCompatEnabled);

</code></pre>
<p>方法的最终是调用这个方法来进行进程的关联，这里离不开<code>ApplicationThread</code>。我们接着来分析下；</p>
<h4 id="applicationthread">ApplicationThread</h4>
<p>可以看到<code>ApplicationThread</code>是<code>ActivityThread</code>的内部类，其是继承了<code>IApplicationThread.Stub</code>。关于跨进程通信中有分析过，对于server端来说。binder是其内部的实体对象，是对于定义的方法的具体实现。既然关键方法是<code>bindApplication()</code>。看一下具体内部实现:</p>
<pre><code class="language-java">    //省略代码
    //setCoreSettings 内部是发了一个`H.SET_CORE_SETTINGS`的消息
    setCoreSettings(coreSettings);
    //省略代码
    AppBindData data = new AppBindData();
    //省略代码  
    //发送一个`H.BIND_APPLICATION`的消息，并将封装的data作为参数一起传入 
    sendMessage(H.BIND_APPLICATION, data);

</code></pre>
<p>可以知道，bindApplication也是通过调用handler的消息机制来发送出来一个消息，具体是通过<code>handleMessage</code>方法来处理。</p>
<h4 id="handlemesagge">handleMesagge</h4>
<p>前文有说到，在<code>main</code>方法中已经开启了<code>looper.loop()</code>来进行消息轮询。那么bindApplication中发送了BIND_APPLICATION的消息，那么对应的也会被处理。</p>
<h5 id="handlebindapplication">handleBindApplication</h5>
<p>整个bindApplication的方法其实是很长的，这里挑选出来几句关键的代码。</p>
<pre><code class="language-java">//省略代码
//获取到`ContextImp`的类加载器，通过loadClass去实例化一个`Instrumentation`。
final ClassLoader cl = instrContext.getClassLoader();
mInstrumentation = (Instrumentation)
    cl.loadClass(data.instrumentationName.getClassName()).newInstance();
//省略代码 
//构建一个application的实例对象
app = data.info.makeApplication(data.restrictedBackupMode, null);
//省略代码 
mInitialApplication = app;
//省略代码
//调用applicaton的onCreate方法
mInstrumentation.callApplicationOnCreate(app);
</code></pre>
<p>可以看到在创建application的过程中，<code>Instrumentation</code>出现了很多次，并且创建过程也是通过它调用的，那么它究竟是个什么东西呢？</p>
<h4 id="instrumentation">Instrumentation</h4>
<p><code>Instrumentation</code>直译过来大概是一个仪器，结合场景可以理解为可以观察的仪表盘。我们先看一下类注释:<br></p>
<p><em><strong>Instrumentation会在应用程序的任何代码运行之前被实例化，它能够允许你监视应用程序和系统的所有交互</strong>。</em></p>
<p>通过上文的分析可以知道<code>Instrumentation</code>是在application初始化之前就已经构造了。那么它是怎么实现见识应用程序和系统的交互呢?<br>
<img src="https://i.loli.net/2019/12/11/Xyfsx21ieLrNzYw.png" alt=""></p>
<p>查看这个类的方法可以看到，activity包括applicaton的生命周期回调都是通过这个类来进行的。</p>
<p>这么做的好处在哪里呢？<code>Instrumentation</code>作为抽象，其实是对这个观察仪表盘进行了抽象的功能。其实就是多态的运用。</p>
<p>既然我们在创建applicaton过程中是调用的<code>Instrumentation</code>中的<code>callApplicatonOnCreate()</code>方法。那么详细来看一下，但是！你会发现内部其实就是调用了一下app的onCreate方法。是不是有点不太对劲。没关系，再来想想：在调用<code>mInstrumentation.callApplicationOnCreate(app)</code>之前，其实是通过<code>data.info.makeApplication(data.restrictedBackupMode, null)</code>来创建一个app实例，data.info其实是<code>loadedApk</code>。</p>
<h4 id="loadedapk">LoadedApk</h4>
<p>既然是将Activity的启动流程，activity需要依附于application。我们还是直接来看makeApplicaton的具体实现。</p>
<pre><code class="language-java">
java.lang.ClassLoader cl = getClassLoader();
if (!mPackageName.equals(&quot;android&quot;)) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
            &quot;initializeJavaContextClassLoader&quot;);
    initializeJavaContextClassLoader();
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}
ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
app = mActivityThread.mInstrumentation.newApplication(
        cl, appClass, appContext);
</code></pre>
<p>这里是获取到当前的类加载器，关于<code>ClassLoader</code>的分析已在其他文章中讲过，这里不作具体介绍。然后通过<code>ContextImpl</code>创建出app的上下文，最后通过<code>instrumentation</code>的newApplicaton方法去构造出真正的applicaton实例。</p>
<p>通过上面的分析我们知道：app还是通过<code>Instrumentation</code>创建的。来看一下具体的方法:</p>
<pre><code class="language-java">public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException, 
        ClassNotFoundException {
    Application app = getFactory(context.getPackageName())
            .instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
//反射创建applicaton 
public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,
        @NonNull String className)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Application) cl.loadClass(className).newInstance();
}

</code></pre>
<p><code>newApplicaton</code>方法也是真的很简单易懂，首先通过反射创造出实例（注：class.loadClass只是构建出实例，并没有进行初始化，而class.forName会进行初始化，这点可以在源码中发现）。紧接着调用<code>app.attach()</code>方法，内部其实调用了<code>attachBaseContext(context);</code>。这也能解释<mark>为什么<code>attachBaseContext</code>在<code>onCreate</code>之前的问题。</mark></p>
<h4 id="activity创建">activity创建</h4>
<p>说完了<code>Application</code>的创建问题，我们再来看一下本文的主题创建activity并启动。<br><br>
上文的流程图的源码是基于SDK26,本文中是基于28,部分代码已经被google改动过，26中还有LAUNCH_ACTIVITY标识的消息，在28中已经被去除。<br><br>
既然前文有看到<code>Instrumentation</code>都会观察activity的创建，我们通过反推来看一下activity是怎么被创建出来的。通过源码观察指导是<code>ActivityThread</code>中的<code>performLaunchActivity</code>方法来调用newActivity方法通过反射来生成activity的实例的。在通过一系列的源码追踪，终于能找到activity创建的来龙去脉。</p>
<ul>
<li>首先调用<code>handleLaunchActivity()</code>方法</li>
<li>紧接着调用<code>performLaunchActivity()</code><pre><code class="language-java">    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
        cl, component.getClassName(), r.intent);
    //调用Instrumentation中的newActivity方法
    public Activity newActivity(ClassLoader cl, String className,
        Intent intent)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    String pkg = intent != null &amp;&amp; intent.getComponent() != null
            ? intent.getComponent().getPackageName() : null;
    return getFactory(pkg).instantiateActivity(cl, className, intent);
}
//同样通过反射实例化出来activity 
    public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className,
        @Nullable Intent intent)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Activity) cl.loadClass(className).newInstance();
}
</code></pre>
<ul>
<li>可以看到同样是获取到classLoader，然后通过反射的方式来获取Activity的实例对象。</li>
</ul>
</li>
<li>在<code>performLaunchActivity</code>方法中获取到activity的实例之后，会有一些细节方面的初始化:
<ul>
<li>初始化配置，包括fontScale/mcc/mnc等</li>
<li>初始化Window（Window是Android系统窗口的抽象基类，这个后续文章会分析到）</li>
<li>调用activity.attach方法
<ul>
<li>在attach方法中会将fragment依附在activity中，初始化<code>PhoneWindow</code>，然后设置windowManager,设置键盘输入模式，设置主题色等等。</li>
</ul>
</li>
<li>紧接着就是调用<code>mInstrumentation.callActivityOnCreate</code>来调用activity.onCreate().（顺带提一下，在activity.onCreate()中会调用<code>getApplication().dispatchActivityCreated(this, savedInstanceState);</code>这也是为什么我们可以在applicaton中注册actvity的生命周期回调的原因）</li>
</ul>
</li>
<li>后续就是按照正常的activity的生命周期往下走啦。</li>
</ul>
<h4 id="总结">总结</h4>
<p>上面说了这么多我们来大概总结下整个activity的创建流程(从用户点击桌面上的启动图标开始)</p>
<ul>
<li>Android为每个应用都分配了至少一个进程，而进程是通过<code>zygote</code>孵化而来</li>
<li>java作为Android的实现语言，Android也是保留了Java的特性，程序的主入口为main方法，但是Android并没有暴露出来。</li>
<li>在<code>ActivityThread</code>的<code>main()</code>方法中，会调用<code>Looper.prepareMainLooper()</code>,然后new出来一个<code>ActivityThread</code>对象，调用attach()方法来将应用与<code>zygote</code>孵化出来的进程绑定。主要流程如下:
<ul>
<li>获取到ams的代理实例对象</li>
<li>调用ams的attachApplicaton方法并传入ApplicaionThread</li>
<li>在<code>ActivityManagerService</code>中调用<code>attachApplicaton（）</code>实际调用的是applicatonThread的<code>bindApplicaton()</code>方法,在此方法中会发送一个<code>BIND_APPLICATION</code>的消息</li>
<li>在handleMessage中调用<code>handleBindApplication</code>然后会通过Instrumentation反射出一个app实例。</li>
<li>紧接着回调attachToBaseContext和onCreate。</li>
</ul>
</li>
<li>activity的创建也是通过instrumentaion中的<code>newActivity</code>方法来进行的，这里同样也是通过反射。</li>
<li>但是与7.0和8.0的区别在于源码中已经去除LAUNCH_ACTIVITY的消息标识。统一通过RELAUNCH_ACTIVITY标识来进行activity的创建。</li>
<li>在接收到消息之后还是会调用到<code>handleLaunchActivity</code></li>
<li>在其中继续调用<code>performLaunchActivity</code>，然后通过反射构建出activity的对象。紧接着调用activity.attach方法来进行一些默认的参数设置。</li>
<li>最后通过instrumentation回调activity的oncreate方法。（回到的同时也会回调applicaon中注册的activity生命周期监听）</li>
</ul>
<p>以上就是大概的activity整体启动流程分析，其中涉及到很多地方都是一笔带过。但是基本上能让人了解activity创建的大概步骤，后续有机会会再开单章对细节进行分析。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/entry/58f5b68e61ff4b005807ab47">3分钟看懂Activity启动流程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：应用启动流程]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidying-yong-qi-dong-liu-cheng</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidying-yong-qi-dong-liu-cheng">
        </link>
        <updated>2019-12-10T02:51:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="基础理论">基础理论</h4>
<p>Android系统是基于Linux，每个APP都是运行在独立的空间内，进程是系统上应用的最小单元。Android为每个进程都分配了独立的jvm,所以基本上是应用隔离的。<br></br><br>
Android并没有自己程序的main方法，但是内部的组件可以被其他程序的组件启动。同样本身也可以启动其他的。</p>
<h4 id="点击启动">点击启动</h4>
<p>直接从打开一个没有启动过的应用来讲:</p>
<ul>
<li>用户在launcher桌面点击应用图标，对于launcher来讲已经知道对应的应用对应什么包名以及入口activity，这个都是安装的时候以及解析出来的了。</li>
<li>调用<code>startActivity()</code>方法，通过ipc告诉<code>ActivityManagerService</code>我要启动这个activity了。</li>
<li>ams在在内部会进行如下操作:
<ul>
<li>通过<code>PackageManager</code>的<code>resloveIntent()</code>方法来收集这个intent对象的指向信息。</li>
<li>指向信息被储存到一个intent对象中。</li>
<li>通过<code>grantUriPermissionLocaked()</code>方法来判断当前应用是否有权限来调用对应的activity。</li>
<li>有权限，ams会在新的task中启动activity(我们在自身应用打开其他应用的界面都是需要添加newTask的flag的)</li>
<li>现在去检查ProcessRecord是否存在，如果不存在，那么ams会创建新的进程来实例化activity</li>
</ul>
</li>
<li>对于Android系统来说，当前需要被启动的activity已经属于一个新的应用了，但是还没有给它分配过uid。此时会通过<code>zygote</code>进程来孵化出一个进程来作为需要被打开的应用的承载。(zygote是所有Java进程的爸爸，这个在系统启动分析中有说过)</li>
<li>ams会调用<code>startProcessLocked()</code>方法来创建新的进程，这个时候<code>zygote</code>会孵化自身，并调用zygote的main方法来实例化<code>ActivityThread</code>对象并且返回新进程的pid.</li>
</ul>
<p><code>activityThread</code>会依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>方法来开启消息循环。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qm7zgvbyj30xc0j878a.jpg" alt=""></figure>
<h4 id="绑定application">绑定Application</h4>
<p>接着就是将进程和<code>Application</code>绑定起来了。绑定流程是通过<code>ActivityThread</code>的<code>bindApplication()</code>方法来完成的。绑定过程中会构造一个<code>AppBindData</code>的对象，然后会将其作为参数通过<code>sendMessage()</code>方法发送一个<code>H.BIND_APPLICATION</code>标识的消息。然后通过<code>handleMessage()</code>方法来处理这条消息，接着调用<code>handleBindApplication()</code>，最终调用<code>makeApplication()</code>方法来构造出一个application对象，接着调用applicaton的onCrate()方法。<br></p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9rel617hnj30x50gfjvb.jpg" alt=""></figure>
<h4 id="启动activity">启动Activity</h4>
<p>经过前面的步骤，系统已经拥有了<code>Application</code>的进程。后面的调用顺序就是从一个已经存在的进程启动一个新进程的activity了。实际调用的方法是<code>realStartActivity()</code>,它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个<code>LAUNCH_ACTIVITY</code>消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。<br>
<img src="https://i.loli.net/2019/12/10/5JfkVocGy3PSKUI.png" alt=""><br>
至此，一个应用的启动流程就结束了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：系统开机流程]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidxi-tong-kai-ji-liu-cheng</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidxi-tong-kai-ji-liu-cheng">
        </link>
        <updated>2019-12-09T08:07:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="整体流程">整体流程</h4>
<ul>
<li>Android开机时按照<code>loader</code>-&gt;<code>kernel</code>-&gt;<code>framework</code>-&gt;<code>application</code>的流程来进行的。附上Android架构图<br></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qaqc8eosj30lm0fita7.jpg" alt=""><br>
<br><br>
再附图一张，启动流程图<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qazhj6tzj30tc0qowif.jpg" alt=""></p>
<h4 id="loader层">loader层</h4>
<p><code>boot rom</code>手机处于关机状态下，长按开机键开机，会引导芯片从烧录在rom里面预设的代码开始执行，加载引导程序到ram。<br><br>
<code>boot loader</code>:启动Android系统之前的引导程序，主要是检查ram,初始化参数。</p>
<h4 id="kernel层">kernel层</h4>
<p>指的就是Android内核层，一般指的是开机刚刚结束进入到Android系统，<code>kernel</code>层启动流程如下:</p>
<ul>
<li>启动<code>swapper</code>进程，pid=0。系统初始化kernel创建的第一个进程，用户初始化进程管理、内存管理、加载<code>display</code>,<code>camera</code>,<code>binder</code>等驱动。<mark>拓展：systemServer是什么时候启动的？binder服务是cs架构，既然ams等都是基于binder的那么先有鸡还是先有蛋</mark>分析见下文</li>
<li>启动<code>kthreadd</code>进程，这里是加载linux系统的内核进程，会创建内核工作线程<code>kworker</code>、软中断线程<code>ksoftirqd</code>和<code>thermal</code>等内核守护进程。<code>kthreadd</code>是所有内核进程的老爹。</li>
</ul>
<h4 id="native层">native层</h4>
<p>这里的<code>native</code>层主要包括由<code>init</code>进程孵化出来的用户空间的守护进程，<code>bootanim</code>开机动画和<code>hal</code>层等。<code>init</code>是<code>linux</code>系统的守护进程，是所有用户空间进程的老爹;<mark>注意区分内核进程和用户进程的区别</mark></p>
<ul>
<li>init进程还会孵化出<code>ueventd</code>,<code>logd</code>,<code>adbd</code>,<code>healthd</code>,<code>installd</code>,<code>adbd</code>等用户守护进程</li>
<li>init进程还会启动<code>serviceManager</code>进程(用来管理binder)，bootanim等服务</li>
<li>init进程还会孵化出<code>zygote</code>进程，<code>zygote</code>是Android系统上面第一个<code>java</code>进程，它是所有Java进程的爸爸。</li>
</ul>
<h4 id="framework层">framework层</h4>
<p><code>framework</code>层是由<code>native</code>和<code>java</code>层共同组成的，协调系统平稳有序的工作。<code>framework</code>层主要包括以下内容。</p>
<ul>
<li><code>Media Server</code>进程，是由<code>init</code>进程<code>fork</code>而来，负责启动和管理这个那个<code>c++ framework</code>,包含<code>AudioFlinger</code>,<code>cameraService</code>等服务。</li>
<li><code>zygote</code>进程是虚拟机孵化的第一个Java进程，是所有Java进程的老爹。</li>
<li><code>System server</code>是由<code>zygote</code>进程fork而来，是<code>zygot</code>进程的第一个子进程，负责启动和管理整个Java framework。包括不限于ams、pms。</li>
</ul>
<h4 id="app层">app层</h4>
<p><code>zygote</code>进程孵化的第一个<code>app</code>进程就是<code>launcher</code>.就是我们看到的桌面应用。因为在前面的framework中生成了各种守护进程和管理进程，对于<code>launcer</code>也就有对应的点击、长按、滑动、卸载等监听。<code>zygote</code>也会创建<code>browser</code>、<code>phone</code>、<code>email</code>等app进程。也就是说所有的app进程都是由<code>zygote</code>进程孵化而来。</p>
<h4 id="拓展">拓展:</h4>
<ul>
<li>
<p>为什么Android系统第一次开机时间会比较长</p>
<ul>
<li>Android系统刷机后第一次开机启动时，需要扫描所有预装的apk文件，提取dex字节码，优化并且拷贝到/data/dalvik-cache缓存目录中，因此，第一次启动耗时会明显更高。</li>
<li>如果手动的删除了<code>/data/dalvik-cache</code>目录下的东西，那么下次在卡机时也会重新走一遍dex优化流程。</li>
<li>sample：线下终端在升级读取流量卡号过程中，流程没有走完，导致<code>telephone.jar</code>没有被授予足够的权限，导致开机之后没法访问<code>telephoneService</code>。
<ul>
<li>修复办法：重新赋予权限，并且删除<code>data/dalvik-cache</code>下面的dex.oat文件，然后重启系统。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>dalvik&amp;art虚拟的区别？</p>
<ul>
<li>dalvik
<ul>
<li>是jit模式，just-in-time，即时编译的，在程序运行时候将代码逐行逐行便已成为机器码。</li>
</ul>
</li>
<li>art
<ul>
<li>AOT模式 ahead-of-time.预编译。</li>
</ul>
</li>
<li>art 优缺点总结：
<ul>
<li>优点
<ul>
<li>系统性能的显著提升</li>
<li>应用速度会更快</li>
<li>节省电量</li>
<li>硬件支持版本会更低</li>
</ul>
</li>
<li>缺点
<ul>
<li>应用占用的系统空间会更大</li>
<li>应用安装时间会更长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Android不同版本虚拟机演进史</p>
<ul>
<li>在5.0以前都是dalvik虚拟机，是jit编译模式</li>
<li>5.0以后添加了art虚拟机，ahead-of-time</li>
<li>7.0以后引入了全新的JIT编译器，在这个版本是art+jit混合编译。在初次安装的时候并不是全部预编译，而是通过jit编译期的分析结果进行编译。</li>
</ul>
</li>
<li>
<p>android在关机状态下是怎么做到定时开机的？</p>
<ul>
<li>可以定时开机的前提是有RTC部件，以及可以单独供电的纽扣电池。RTC会记录设置的时间，时间到之后会引导程序走开机流程。</li>
</ul>
</li>
<li>
<p>watchDog概念是什么？</p>
<ul>
<li>WatchDog <a href="http://gityuan.com/2016/06/21/watchdog/">WatchDog工作原理</a>
<ul>
<li><code>WatchDog</code>是一个运行在<code>system_server</code>名为<code>watchDog</code>的线程。</li>
<li>运行过程中，如果阻塞时间超过1分钟则会触发一次watchDog,会杀死<code>system_server</code>。触发上层重启。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>binder是什么时候被启动或者binder服务是先有鸡还是先有蛋</p>
<ul>
<li>通过前文分析是知道system_server是在<code>zygote</code>进程孵化出来的就是在系统启动framework层进行的</li>
</ul>
</li>
<li>
<p>怎么将一个应用变为系统系统？</p>
<ul>
<li>在manifest中添加:<code>andoid:shareUserId</code>=&quot;android.uid.system&quot;</li>
<li>使用通用签名打包</li>
<li>获取root权限，将apk Push到<code>system/app</code>目录下面自定义的目录。</li>
<li>给system/app目录下的app增加权限</li>
</ul>
</li>
<li>
<p>怎么将一个应用修改为launcher桌面？</p>
<ul>
<li>在主activity的intent-filter中添加</li>
</ul>
<pre><code class="language-java">&lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;

</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：EventBus源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androideventbus-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-28T10:04:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>EventBus对于Android开发着来讲可以说是再熟悉不过了。不管是最开始的mvc模式还是现在的组件化开发模式，EventBus一直没有没落下去，今天我们就来详细分析一下EventBus的内部原理。</p>
<h4 id="介绍">介绍</h4>
<p>官方介绍中，EventBus是一个Android或者Java可以使用的基于发布、订阅的框架。这里放上官方的流程图:<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/27/16eacfa9e88928f9?w=1280&amp;h=479&amp;f=png&amp;s=28898" alt=""><br>
通过流程图可以发现，EventBus的整体使用的是非常的简单，发布者post一个事件，所有消费者监听到之后消费。这就是一点典型的观察者模式的设计模式。</p>
<table><tr><td bgcolor="#f7f6f3">
观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
</td></tr></table>
<h4 id="上手使用">上手使用</h4>
<p>跟之前一样，我们还是先从使用开始，其实这步好像可以省略。大家对EventBus的使用应该非常熟悉，但是流程还是要走一下的。<br>
<img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb12aa3c70c7fa?w=1572&amp;h=616&amp;f=jpeg&amp;s=70991" alt=""><br>
在<code>onStart()</code>方法中注册，<code>onStop()</code>中销毁。再来定义一个event,在<code>onResume</code>中发送，并且直接注册一个观察者来接受这个event。</p>
<pre><code class="language-kotlin">    @Subscribe(threadMode = ThreadMode.MAIN)
    fun onReceiveEvent(event: TestEvent) {
        Log.d(&quot;EventBus&quot;, &quot;receive event&quot;)
    }
</code></pre>
<p>运行上面这段代码可以在控制台看到输出:</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/28/16eb13094fde6dc4?w=1142&amp;h=64&amp;f=jpeg&amp;s=16319" alt=""><br>
可以看到EventBus整个的使用流程是非常简单的，当然也可以在发送事件的时候携带参数，直接在event类中定义就ok。下面我们将详细分析一下EventBus的内部流程。</p>
<h4 id="源码探究">源码探究</h4>
<p>还是老规矩，我们将按照使用流程来一点点剥开它的外壳，发现它的内部纹路。</p>
<h5 id="获取eventbus">获取EventBus</h5>
<p>EventBus在构造方法执行的时候会通过<code>builder</code>模式来设置一些常用参数，先来看一下这些设置：</p>
<pre><code class="language-java">    EventBus(EventBusBuilder builder) {
        //log打印器
        logger = builder.getLogger();
        //Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType
        //以event为key,订阅列表为value，是一个线程安全的容器
        subscriptionsByEventType = new HashMap&lt;&gt;();
        //Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;
        //订阅者为key,event为value的容器 
        typesBySubscriber = new HashMap&lt;&gt;();
        //粘性事件的容器
        stickyEvents = new ConcurrentHashMap&lt;&gt;();
        //是否支持主线程
        mainThreadSupport = builder.getMainThreadSupport();
        //如果支持主线程，构建出来一个主线程发射器
        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
        //初始化BackgroundPoster
        backgroundPoster = new BackgroundPoster(this);
        //初始化AsyncPoster
        asyncPoster = new AsyncPoster(this);
        //是否有编译期已经生成的索引类，关于索引将会在列表中放出解析文章链接
        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
        //初始化注册时间寻找器，具体将在后续分析
        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                builder.strictMethodVerification, builder.ignoreGeneratedIndex);
        //是否打印出订阅异常
        logSubscriberExceptions = builder.logSubscriberExceptions;
        logNoSubscriberMessages = builder.logNoSubscriberMessages;
        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
        throwSubscriberException = builder.throwSubscriberException;
        eventInheritance = builder.eventInheritance;
        //当接收模式为backGroud和async时的线程调度器，默认为缓存线程池
        executorService = builder.executorService;
    }
</code></pre>
<p>当然如果我们在使用的时候也可以自定义配置。配置方式如下:</p>
<pre><code class="language-java">EventBus eventBus = EventBus.builder()
    .logNoSubscriberMessages(false)
    .sendNoSubscriberEvent(false)
    .build();
</code></pre>
<p>分析过构造方法之后再来看一下<code>getDefault()</code>:</p>
<pre><code class="language-java">    public static EventBus getDefault() {
        if (defaultInstance == null) {
            synchronized (EventBus.class) {
                if (defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }
        return defaultInstance;
    }
</code></pre>
<p>可以看到这里是使用了单例模式的<strong>双重检查模式</strong>,关于单例模式的多种不同写法可以<a href="https://blog.csdn.net/itachi85/article/details/50510124">参考</a>。只有第一次使用的时候才会初始化，最大限度的保证了资源的利用效率。</p>
<h4 id="注册">注册</h4>
<p>要想通过EventBus来观察被观察者，首先是需要注册，来告诉程序你需要观察某个对象的改变。我们来看一下<code>register</code>是做了什么事情。</p>
<pre><code class="language-java">    将给定的对象注册用来接收event，当不在需要观察event的变化时，必须调用unregister。
    同时，注册的对象内部必须有Subscribe注解的方法。
    public void register(Object subscriber) {
        Class&lt;?&gt; subscriberClass = subscriber.getClass();
        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
</code></pre>
<p>可以看到会通过<code>subscriberMethodFinder</code>当前对象注册的所有事件监听的方法，然后通过<code>subscribe()</code>方法来将注册的所有监听都添加到监听列表中。来分析下具体方法；</p>
<h6 id="findsubscribermethods">findSubscriberMethods</h6>
<p>根据方法名就可以很方便的理解，根据传入的观察者对象去寻找其内部定义的全部观察方法。首先根据<code>METHOD_CACHE.get(subscriberClass);</code>去获取到之前可能已经缓存的全部订阅方法。如果之前已经获取过那么直接返回，前面有提到过EventBus是全局单例，所以就很好理解了。如果缓存没有就需要重新去获取。</p>
<p>接着会根据build期间设置的是否忽略索引来获取，前文也有提到EventBus在编译期会提前生成索引，那么索引是怎么生成的呢？</p>
<table><tr>
<td bgcolor="#f7f6f3">
在3.0版本中，EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解，并解析和处理其中所包含的信息，然后生成java类来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。<br>
此处为引用
</td>
</tr></table>
<p>如果观察者内部并没有定义<code>@Subscribe</code>注解的方法会抛出异常。</p>
<p>通过<code>findSubscriberMethods</code>方法我们已经找到了观察者内部定义的全部标有<code>@Subscribe</code>的方法。接着就是在线程同步锁中调用<code>subcribe</code>方法。</p>
<h5 id="subscribe">subscribe</h5>
<p>前文已经拿到了当前订阅的事件类型，这里会根据<code>eventType</code>放入上文提到的<code>subscriptionsByEventType</code>线程安全的map中,当然会有一些安全检查。接着会根据注册时定义的优先级对订阅同一个事件的观察者进行排序。</p>
<p>紧接着将当前观察者中所有的订阅方法添加进以<code>subscriber</code>为key的map中。</p>
<p>最后是对粘性事件的处理,与<code>StickyBroadcast</code>是同一个概念。EventBus在定义订阅方法时，除了可以指定接收的线程之外还设有另外两个参数可以设定：</p>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Subscribe {
    //接收的线程
    ThreadMode threadMode() default ThreadMode.POSTING;
    //是否是粘性事件
    boolean sticky() default false;
    //事件优先级
    int priority() default 0;
}

</code></pre>
<p>继续看是怎么处理粘性事件的注册,直接判断当前注册进来的粘性事件是否存储在本地的<code>stickyEvents</code>。如果匹配上那么就会最终调用<code>postToSubscription()</code>方法。</p>
<h4 id="发送事件">发送事件</h4>
<p>EventBus的事件发送其实是非常简单的。我们来看一下:</p>
<ul>
<li>普通事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().post(TestEvent())
</code></pre>
<ul>
<li>粘性事件发送</li>
</ul>
<pre><code class="language-java">  EventBus.getDefault().postSticky(TestEvent())
</code></pre>
<h5 id="post方法">post方法</h5>
<pre><code class="language-java">   public void post(Object event) {
        PostingThreadState postingState = currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue = postingState.eventQueue;
        eventQueue.add(event);

        if (!postingState.isPosting) {
            postingState.isMainThread = isMainThread();
            postingState.isPosting = true;
            if (postingState.canceled) {
                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
            }
            try {
                while (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(0), postingState);
                }
            } finally {
                postingState.isPosting = false;
                postingState.isMainThread = false;
            }
        }
    }
</code></pre>
<ul>
<li>首先会从<code>currentPostingThreadState</code>中取出发送线程的状态机。<code>currentPostingThreadState</code>其实是一个<code>ThreadLocal</code>，关于<code>ThreadLocal</code>推荐一篇文章:<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a>。</li>
<li></li>
<li>拿到状态机中的事件队列</li>
<li>将事件添加到事件队列中</li>
<li>判断当前发送线程没有堆积任务正在处理才进入到发送逻辑</li>
<li>while循环中不断的从队列中取出第一个任务，调用<code>postSingleEvent</code>进行发送</li>
</ul>
<h5 id="postsingleevent方法">postSingleEvent方法</h5>
<p>上面说到，post方法实际上是将event添加到队列中，然后通过不断的从队列中取出第一个来进行处理。</p>
<pre><code class="language-java">   private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
        Class&lt;?&gt; eventClass = event.getClass();
        boolean subscriptionFound = false;
        if (eventInheritance) {
            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
            int countTypes = eventTypes.size();
            for (int h = 0; h &lt; countTypes; h++) {
                Class&lt;?&gt; clazz = eventTypes.get(h);
                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
        }
        if (!subscriptionFound) {
            if (logNoSubscriberMessages) {
                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);
            }
            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                    eventClass != SubscriberExceptionEvent.class) {
                post(new NoSubscriberEvent(this, event));
            }
        }
    }
</code></pre>
<p>对这个方法进行一个简单的总结:</p>
<ul>
<li>获取到发送的事件类型</li>
<li>调用<code>lookupAllEventTypes</code>方法从缓存中或者通过立即获取方式取到所有注册了此种事件类型的观察者们，包括被继承的类也会被找出来</li>
<li>调用<code>postSingleEventForEventType</code>来将事件发送</li>
</ul>
<p>postSingleEventForEventType实际上从本地缓存中取到对象中后还是调用我们上文分析粘性事件时最终调用的<code>postToSubscription</code>方法。</p>
<h5 id="posttosubscription-方法">postToSubscription 方法</h5>
<pre><code class="language-java">    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case MAIN_ORDERED:
                if (mainThreadPoster != null) {
                    mainThreadPoster.enqueue(subscription, event);
                } else {
                    // temporary: technically not correct as poster not decoupled from subscriber
                    invokeSubscriber(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
        }
    }
</code></pre>
<p>可以说这个方法是观察者接收事件时绝对会调用的方法。可以看到根据threadMode是区分了不同的逻辑，那threadMode是干嘛的呢？</p>
<pre><code class="language-java">//定义用来表示EventBus的方法在哪个线程被调用的枚举类
public enum ThreadMode {
    //与post方是在同一个线程
    POSTING,
    //直接在主线程中调用这个方法
    MAIN,
    //同样也是在主线程中调用 ，但是与Main有区别的地方在于它是通过队列来进行的，不是直接调用
    MAIN_ORDERED,
    //Android上将会在异步线程调用subscribler的方法，如果本身post方不是主线程，那么会直接在当前线程执行，跟`post`类似。如果是在主线程post，那么会直接在一个新的异步线程执行。
    BACKGROUND,
    //这个模式下，总是在一个单独的线程执行，不会在post线程以及主线程。可以用来执行一些耗时任务。内部是采用线程池来做线程的复用
    ASYNC
}
</code></pre>
<p>分析到这里也就差不多可以理解<code>postToSubscription</code>是按照方法注解中定义的<code>ThreadMode</code>来进行观察者接收事件的线程调度管理。不轮其是直接调用方法还是放入队列中进行管理最终都是通过反射在当前线程对方法进行调用。</p>
<h5 id="poststicky方法">postSticky方法</h5>
<pre><code class="language-java">  public void postSticky(Object event) {
        synchronized (stickyEvents) {
            stickyEvents.put(event.getClass(), event);
        }
        // Should be posted after it is putted, in case the subscriber wants to remove immediately
        post(event);
    }
</code></pre>
<p>可以看到<code>postSticky</code>内部逻辑也是非常简单，就是将event注册为粘性事件存放入本地缓存。后续逻辑与正常事件的发送一样。</p>
<h4 id="取消注册">取消注册</h4>
<p>分析完了注册和发送，我们必须要来讲一下反注册。我们平常在activity中使用广播的时候有注册，那么在activity销毁的时候一定要记得进行反注册，不然就会引起内存泄漏。同样的道理，假如我们某个观察者类在销毁的时候没有从eventBus中进行取消注册。eventBus全局单例就一直会持有当前观察者的引用，从而造成了内存泄漏。</p>
<pre><code class="language-java">    public synchronized void unregister(Object subscriber) {
        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);
        if (subscribedTypes != null) {
            for (Class&lt;?&gt; eventType : subscribedTypes) {
                unsubscribeByEventType(subscriber, eventType);
            }
            typesBySubscriber.remove(subscriber);
        } else {
            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
        }
    }
</code></pre>
<p>可以看到，取消注册的逻辑其实是非常简单的，无非是将要取消注册的观察者对象从本地缓存中和相关的map中都统一移除。</p>
<h4 id="总结">总结</h4>
<p>写到这里，基本上<code>EventBus</code>整个使用流程的代码分析都已完成，我们来大概总结一下：</p>
<ul>
<li>EventBus核心是使用观察者模式</li>
<li>通过builder模式设置参数，一般情况下使用默认</li>
<li>EventBus是使用<strong>双重检查模式</strong>的全局单例</li>
<li>注册时通过索引或者反射来获取订阅者中的所有订阅方法，粘性事件注册时会根据本地粘性事件map是否存在当前注册进来需要监听的订阅类型来决定要不要发送一次。</li>
<li>发送时根据事件类型等从本地在注册时就已经换成的对象进行发送，发送有接收线程、优先级以及是否粘性事件的区分。最终都是通过反射调用方法来进行通知的</li>
<li>取消注册，将订阅者对象从EventBus类的相关缓存中移除</li>
</ul>
<p>以上就是EventBus整体的大概流程分析，大概还是会有很多语意不明或者逻辑漏洞的地方，希望大家指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://blog.csdn.net/a553181867/article/details/52531479">EventBus 3.0进阶：源码及其设计模式 完全解析</a><br><br>
<a href="https://blog.csdn.net/qq_19431333/article/details/81173432">EventBus配置、粘性事件、优先级和取消事件分发</a><br><br>
<a href="https://www.jianshu.com/p/ed417a9cd7d6">EventBus3.0新特性之Subscriber Index</a><br><br>
<a href="https://juejin.im/post/5ac2eb52518825555e5e06ee">ThreadLocal就是这么简单</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:Retrofit源码探究]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidretrofit-yuan-ma-tan-jiu">
        </link>
        <updated>2019-11-26T08:17:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>之前的文章，我们分析了okhttp一个网络请求的一些关键的步骤。今天会再来分析一下基本相当于其孪生兄弟的存在<strong>Retrofit</strong>。他们都是<strong>square</strong>公司出品的Android常用开发框架。那么关于<strong>Retrofit</strong>很多人其实都说是一个网络请求框架，类似于okhttp。那么它真的是这样的吗？我们今天就来看一下:</p>
<h4 id="使用retrofit进行一次网络请求">使用Retrofit进行一次网络请求</h4>
<p>既然是开发框架，按照规矩当然是首先会使用啦。关于使用文档，官方提供了<a href="https://square.github.io/retrofit/">github.io页面</a>。既然官方提供了示例，我们按照说明来操作一下，这是获取github某个用户repo的示例。</p>
<h5 id="api定义">API定义</h5>
<p>retrofit的使用首先要定义一个接口来说明需要请求的接口:</p>
<pre><code class="language-java">public interface GithubService {
    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
    
}
</code></pre>
<p>注意:retrofit中使用了大量的注解，在这个请求定义中可以看到。使用@get表示这个请求为get类型,使用path来与url中已经定义好的参数做映射。</p>
<h5 id="发出请求">发出请求</h5>
<pre><code class="language-kotlin"> private fun makeRetrofitCall() {
        val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            //相对官方示例，我们多了添加gson解析器这一步。一般如果不添加这里会抛出can not convert exception.
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val githubService = retrofit.create(GithubService::class.java)
        githubService.listRepos(&quot;alsowell&quot;).enqueue(object : retrofit2.Callback&lt;List&lt;Any&gt;&gt; {
            override fun onFailure(call: retrofit2.Call&lt;List&lt;Any&gt;&gt;, t: Throwable) {

            }
            override fun onResponse(
                call: retrofit2.Call&lt;List&lt;Any&gt;&gt;,
                response: retrofit2.Response&lt;List&lt;Any&gt;&gt;
            ) {
            Log.d(&quot;Retrofit&quot;,response.body().toString())
            }
        })
    }
</code></pre>
<p>到这里，使用retrofit进行的一个完整的网络请求就完成了。retrofit会使用我们设置的GsonConvertFactory来将response解析成用户希望的格式。使用的时候直接调用response.body()就可以拿到我们想要的数据。下面我一点一点的分析retrofit内部究竟做了什么。</p>
<h4 id="retrofitbuilder">Retrofit.builder()</h4>
<p>上面的网络请求中发现，首先要构造出来一个retrofit对象。retrofit跟okhttpclient一样也是使用建造者模式构建出来的，我们来看一下里面有哪些参数:</p>
<pre><code class="language-java">    private final Platform platform;
    private @Nullable okhttp3.Call.Factory callFactory;
    private @Nullable HttpUrl baseUrl;
    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();
    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();
    private @Nullable Executor callbackExecutor;
    private boolean validateEagerly;
</code></pre>
<h5 id="platform">Platform</h5>
<p>platform是retrofit判断当前运行平台的类。目前支持Android、java两个运行平台。在调用Retrofit.builder()方法时就通过调用Platform.get()方法来获取平台类型。同时也会进行一些对应平台的初始化工作。</p>
<h5 id="callfactory">callFactory</h5>
<p>字面意思就是请求工厂类。可以看到其类型是okhttp3定义的call对象。这里其实可以知道retrofit内部请求使用的仍然是okhttp，只不过是对其进行了一次封装，用户可以更方便的进行使用。关于callFactory也是支持用户进行设置进去的。</p>
<pre><code class="language-kotlin">  val retrofit = Retrofit.Builder()
            .baseUrl(&quot;https://api.github.com/&quot;)
            .addConverterFactory(GsonConverterFactory.create())
            .callFactory(OkHttpClient.Builder().build())
            .build()
</code></pre>
<p>可以看到通过callFactory方法，就可以使用用户自己定义的<strong>OkHttpClient</strong>对象了。那如果用户没有设置呢？</p>
<pre><code class="language-kotlin"> public Retrofit build() {
    //省略代码
      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }
      //省略代码
    }
</code></pre>
<p>会发现，在调用build方法时,retrofit会对当前的callFactory进行空判断。如果当前为null，那么会直接new OkHttpClient()。</p>
<h5 id="httpurl">HttpUrl</h5>
<p>HttpUrl其实也是okHttp包中的类，通过源码可以看到我们设置baseUrl为https://api.github.com/时，内部也是通过HttpUrl.get()方法来进行一些url合法性的校验，以及解析设置后续网络请求会用到的一些参数。具体可在之前OkHttp系列文章中找到。</p>
<h5 id="converterfactories">converterFactories</h5>
<p>看见名字我们就知道其实是转换器的工厂。例如我们在前面进行请求时设置了一个GsonConvertFactory来将网络请求的数据解析成我们真正想要的返回。关于Converte和Factory我们将在下文进行详细的分析，这里先保留一些疑问。</p>
<h5 id="calladapterfactories">callAdapterFactories</h5>
<p>翻译过来就是请求适配器工厂,见名知其意即为对请求进行包装来适配不同框架的工厂集。一般我们在使用retrofit时都会结合RxJava来一起使用,那么就是通过callAdapter来进行使用的。同样我们也还是保持一些疑问留给下文详细探究。</p>
<h5 id="callbackexecutor">callbackExecutor</h5>
<p>回调执行器，是不是很好理解?就是我们请求完成之后对我们回调的数据进行线程切换的执行器。同样也可以通过在build过程中用户动态的设置进来。如果没有设置那么retrofit是怎么做的呢?</p>
<pre><code class="language-java">  Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }
</code></pre>
<p>上文我们有说到过platform其实就是运行平台的意思。defaultCallbackExecutor()其实是Platform中定义的方法,每个平台对应其有自己的实现。在Android平台下:</p>
<pre><code class="language-kotlin">    @Override public Executor defaultCallbackExecutor() {
      return new MainThreadExecutor();
    }
    //静态内部类
     static class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());

      @Override public void execute(Runnable r) {
        handler.post(r);
      }
    }
</code></pre>
<p>可以看到默认是在主线程回调返回的，拿到主线程的handler对象，拿到解析完成后的响应数据后通过mainHandler的post方法直接回调到主线程，让用户可以直接在主线程中去更新UI。</p>
<h5 id="validateeagerly">validateEagerly</h5>
<p>用来配置在使用retrofit.crate()时是否对接口中定义的所有方法进行解析。</p>
<p><br></br><br>
上文说到通过Retrofit.builder.xxx.xxx.build()方法最终是拿到一个Retrofit对象的。那我们来接着看一下</p>
<h4 id="retrofit">Retrofit</h4>
<p>首先看一下构造方法:</p>
<pre><code class="language-java"> Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,
      @Nullable Executor callbackExecutor, boolean validateEagerly) {
    this.callFactory = callFactory;
    this.baseUrl = baseUrl;
    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
    this.callbackExecutor = callbackExecutor;
    this.validateEagerly = validateEagerly;
  }
</code></pre>
<p>既然是通过builder.build方法来构建出来我们需要的retrofit对象，那就详细的来看一下build做了哪些操作:</p>
<pre><code class="language-java">   public Retrofit build() {
      if (baseUrl == null) {
        throw new IllegalStateException(&quot;Base URL required.&quot;);
      }

      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }

      Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }

      // Make a defensive copy of the adapters and add the default Call adapter.
      List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);
      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));

      // Make a defensive copy of the converters.
      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(
          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

      // Add the built-in converter factory first. This prevents overriding its behavior but also
      // ensures correct behavior when using converters that consume all types.
      converterFactories.add(new BuiltInConverters());
      converterFactories.addAll(this.converterFactories);
      converterFactories.addAll(platform.defaultConverterFactories());

      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
    }
</code></pre>
<p>按照调用步骤分析如下:</p>
<ul>
<li>先判断baseUrl是否为null,为null直接抛出异常</li>
<li>判断是否有设置callFactory和callBackExecutor，无则使用默认的。具体前文有介绍</li>
<li>将平台默认的适配器添加到最后，来看一下Android平台默认的适配器<pre><code class="language-java">//这里传入的executor为上文中用户自定义或者android平台的默认MainExecutor
//关于DefaultCallAdapterFactory将在后续详细分析
List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(
  @Nullable Executor callbackExecutor) {
return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
}
</code></pre>
</li>
<li>定义一个大小为1+用户设置转换器集合size+系统默认转换器size的集合</li>
<li>将retrofit内置的转换器添加进去</li>
<li>将用户设置的转换器添加进去</li>
<li>添加平台默认的转换器
<ul>
<li>Android平台下仅仅在api&gt;24时候添加进来一个OptionalConverterFactory,其他时候为一个空数组</li>
</ul>
</li>
<li>最终通过调用Retrofit的构造方法来成功构建出Retrofit对象</li>
</ul>
<p>构造无非是把我们在builder中设置的参数传递进来并赋值给类中定义的变量。我们来看一下Retrofit类中定义的一些变量:</p>
<pre><code class="language-java">  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();
  final okhttp3.Call.Factory callFactory;
  final HttpUrl baseUrl;
  final List&lt;Converter.Factory&gt; converterFactories;
  final List&lt;CallAdapter.Factory&gt; callAdapterFactories;
  final @Nullable Executor callbackExecutor;
  final boolean validateEagerly;
</code></pre>
<p>除了serviceMethodCache，其他变量均已经在我们在build时设置过。</p>
<h5 id="servicemethodcache">serviceMethodCache</h5>
<p>可以看到serviceMethodCache是一个HahshMap集合,实际上是对我们在接口中定义的方法的缓存。是否还记得我们通过注解定义了请求方法类型、请求参数等。我们来看一下ServiceMethod这个类</p>
<pre><code class="language-java">abstract class ServiceMethod&lt;T&gt; {
  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {
    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);

    Type returnType = method.getGenericReturnType();
    if (Utils.hasUnresolvableType(returnType)) {
      throw methodError(method,
          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
    }
    if (returnType == void.class) {
      throw methodError(method, &quot;Service methods cannot return void.&quot;);
    }

    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
  }

  abstract @Nullable T invoke(Object[] args);
}

</code></pre>
<p>这里是定义的一个带有泛型的抽象类，通过parseAnnotations()来对我们在定义方法时候的注解进行解析。我们具体来看一下parseAnnotations()方法</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea72855f7c884f?w=2150&amp;h=1094&amp;f=jpeg&amp;s=410765" alt=""><br>
可以看到这里是根据HTTP协议来传入方法类型以及是否有body体，具体实现也是很简单。</p>
<h4 id="retrofitcreate">Retrofit.create()</h4>
<p>按照调用流程我们拿到retrofit对象之后会通过retrofit.create(service)方法来拿到一个Service。来看一下具体实现:</p>
<pre><code class="language-java"> public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();
          private final Object[] emptyArgs = new Object[0];

          @Override public @Nullable Object invoke(Object proxy, Method method,
              @Nullable Object[] args) throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
          }
        });
  }
</code></pre>
<p>简单翻译一下注释:是我们在service接口中定义的方法的具体实现。具体来看代码:</p>
<ul>
<li>通过validateEagerly变量来判断是否提前将接口类中的所有方法解析出来。具体解析分析见下文</li>
<li>验证接口类的合法性
<ul>
<li>必须是接口定义</li>
<li>接口类中不能有内部接口类</li>
</ul>
</li>
<li>返回动态代理的具体实现（关于动态代理，这里提供一篇优秀的文章:<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a>）
<ul>
<li>先来看一下Proxy.newProxyInstance这个方法传入的参数。
<ul>
<li>ClassLoader:对应我们传入的service的classLoader</li>
<li>Class&lt;?&gt;[]:需要被代理的接口类,这里传入我们定义的service</li>
<li>InvocationHandler:使用默认的InvocationHandler</li>
</ul>
</li>
<li>具体看一下InvocationHandler方法里面做了什么事情?
<ul>
<li>首先拿到当前运行的平台（这里特指android）</li>
<li>定义一个空的对象数组</li>
<li>看一下invoke方法里面的调用逻辑
<ul>
<li>如果代理的方法是从一个object中的那么直接走原来的方法</li>
<li>根据平台类型来判断执行分支(android version 24以后可能是发生了改动)Android platform这里是做了兼容是不会进来的</li>
<li>返回loadServiceMethod.invoke()方法的返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="loadservicemethod">loadServiceMethod</h5>
<p>经过上面的分析知道，retrofit.create()方法返回的是loadServiceMethod.invoke()的代理实现。那来看一下这个是做了什么事情。<br></p>
<ul>
<li>注:上文说到的提前解析其实也是调用的这个方法，在for循环中进行</li>
</ul>
<pre><code class="language-java">  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
    if (result != null) return result;

    synchronized (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      if (result == null) {
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }
</code></pre>
<ul>
<li>首先从缓存中去取看是否已经存在,存在的话直接返回</li>
<li>在代码锁中再次尝试从缓存中取出，我的理解是为了防止请求进行时，之前提前解析时才完成，这样就避免重复的去解析接口中定义的方法造成资源浪费</li>
<li>通过ServiceMethod.parseAnnotations()方法将定义的请求解析出来并缓存(关于解析的具体逻辑，上文也说到过看似复杂其实就是按照特定的规则将定义的信息取出，感兴趣的同学可以具体看一下)。这里详细解析一下在解析之外做的事情，见下文。</li>
</ul>
<h5 id="httpservicemethod">HttpServiceMethod</h5>
<p>在loadServiceMethod方法中调用了ServiceMethod.parseAnnotations()来解析我们在接口方法中定义的一些参数,最终返回的是HttpServiceMethod.parseAnnotations（）的返回。</p>
<p>HttpServiceMethod其实继承于ServiceMethod,ServiceMethod定义了一个invoke的抽象方法。还记得在retrofit create中返回的是ServiceMethod.invoke()吗？</p>
<p>还是先看一下在HttpServiceMethod的parseAnnotations中做了什么事情</p>
<pre><code class="language-java"> static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
      Retrofit retrofit, Method method, RequestFactory requestFactory) {
    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
    boolean continuationWantsResponse = false;
    boolean continuationBodyNullable = false;

    Annotation[] annotations = method.getAnnotations();
    Type adapterType;
    if (isKotlinSuspendFunction) {
      Type[] parameterTypes = method.getGenericParameterTypes();
      Type responseType = Utils.getParameterLowerBound(0,
          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
      if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) {
        // Unwrap the actual body type from Response&lt;T&gt;.
        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
        continuationWantsResponse = true;
      } else {
        // TODO figure out if type is nullable or not
        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
        // Find the entry for method
        // Determine if return type is nullable or not
      }

      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
    } else {
      adapterType = method.getGenericReturnType();
    }
    //创建请求适配器
    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =
        createCallAdapter(retrofit, method, adapterType, annotations);
    Type responseType = callAdapter.responseType();
    if (responseType == okhttp3.Response.class) {
      throw methodError(method, &quot;'&quot;
          + getRawType(responseType).getName()
          + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;);
    }
    if (responseType == Response.class) {
      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);
    }
    // TODO support Unit for Kotlin?
    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) {
      throw methodError(method, &quot;HEAD method must use Void as response type.&quot;);
    }
    //创建响应体转换器 
    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =
        createResponseConverter(retrofit, method, responseType);

    okhttp3.Call.Factory callFactory = retrofit.callFactory;
    if (!isKotlinSuspendFunction) {
      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);
    } else if (continuationWantsResponse) {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);
    } else {
      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory,
          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,
          continuationBodyNullable);
    }
  }
</code></pre>
<p>这里我们来分析几个主要的函数:</p>
<ul>
<li>createCallAdapter
<ul>
<li>创建请求适配器，这里只放一些关键代码。<pre><code class="language-java">//createCallAdapter
return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);

//retrofit.callAdapter
return nextCallAdapter(null, returnType, annotations);

//nextCallAdapter
int start = callAdapterFactories.indexOf(skipPast) + 1;
for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {
  CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
  if (adapter != null) {
    return adapter;
  }
}

</code></pre>
<ul>
<li>可以看到这里是从我们之前在创建retrofit时候定义的callAdapterFactories中取出一个CallAdapter(DefaultCallAdapterFactory)</li>
</ul>
</li>
</ul>
</li>
<li>createResponseConverter
<ul>
<li>创建响应转换器<pre><code class="language-java">//createResponseConverter
return retrofit.responseBodyConverter(responseType, annotations);
//retrofit.responseBodyConverter
return nextResponseBodyConverter(null, type, annotations);
//nextResponseBodyConverter
int start = converterFactories.indexOf(skipPast) + 1;
for (int i = start, count = converterFactories.size(); i &lt; count; i++) {
  Converter&lt;ResponseBody, ?&gt; converter =
      converterFactories.get(i).responseBodyConverter(type, annotations, this);
  if (converter != null) {
    //noinspection unchecked
    return (Converter&lt;ResponseBody, T&gt;) converter;
  }
}
</code></pre>
<ul>
<li>可以看到createResponseConverter与createCallAdapter类似，均是从之前定义的列表中返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<tr>
<td bgcolor="f7f6f3">
题外话：曾经遇到一道面试题:retrofit是什么时候将接口中定义的方法解析出来的？是一次性将所有方法解析出来还是使用到的时候在解析?<br>
分析到这里，答案其实很简单了。默认情况下，用户没有通过validateEagerly()方法设置提前解析的话，retrofit是地用到具体方法的时候才会将方法解析出来，这样就可能尽可能的降低内存消耗。如果设置为true的情况，那么就是直接在create创建retrofit对象的时候将接口类中定义的方法一次性全部解析出来。
</td>
</tr>
</table>
<h4 id="方法调用">方法调用</h4>
<p>我们分析了retrofit的create方法其实动态代理了我们在接口中定义的方法。那接着来看一下在调用方法的时候是干了什么</p>
<pre><code class="language-java">    @GET(&quot;users/{user}/repos&quot;)
    Call&lt;List&lt;Object&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
</code></pre>
<pre><code class="language-kotlin"> val listRepos = githubService.listRepos(&quot;alsowell&quot;)
</code></pre>
<p>可以看到我们在接口中定义的方法的返回其实是一个call对象，还记得okhttp中的call吗？你是不是以为是一个东西？但是其实这个是retrofit内部自己定义的。</p>
<p>经过前文的分析我们知道当我们调用接口里面的方法时候，其实会调用invoke方法。并且这里实际调用的是HttpServiceMethod的invoke()方法。我们来看一下做了什么操作。</p>
<pre><code class="language-java">  @Override final @Nullable ReturnT invoke(Object[] args) {
    Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);
    return adapt(call, args);
  }
</code></pre>
<p>这里的okhttpCall其实是retrofit对okhttp的封装，这里是进行了简单的赋值操作。<br>
最终返回的是adapt(call,args)。继续往下看，adapt其实是CallAdapter接口中定义的方法。还记得我们在build retrofit时默认的DefaultCallAdapterFactory吗？具体的实现是由它来做的。</p>
<pre><code class="language-java">   return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
      @Override public Type responseType() {
        return responseType;
      }

      @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
        return executor == null
            ? call
            : new ExecutorCallbackCall&lt;&gt;(executor, call);
      }
    };
</code></pre>
<p>可以看到最终会返回ExecutorCallbackCall，他也是继承于Call</p>
<h5 id="executorcallbackcall">ExecutorCallbackCall</h5>
<pre><code class="language-java"> static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
    final Executor callbackExecutor;
    final Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
      this.callbackExecutor = callbackExecutor;
      this.delegate = delegate;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      checkNotNull(callback, &quot;callback == null&quot;);

      delegate.enqueue(new Callback&lt;T&gt;() {
        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              if (delegate.isCanceled()) {
                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));
              } else {
                callback.onResponse(ExecutorCallbackCall.this, response);
              }
            }
          });
        }

        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) {
          callbackExecutor.execute(new Runnable() {
            @Override public void run() {
              callback.onFailure(ExecutorCallbackCall.this, t);
            }
          });
        }
      });
    }

    @Override public boolean isExecuted() {
      return delegate.isExecuted();
    }

    @Override public Response&lt;T&gt; execute() throws IOException {
      return delegate.execute();
    }

    @Override public void cancel() {
      delegate.cancel();
    }

    @Override public boolean isCanceled() {
      return delegate.isCanceled();
    }

    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.
    @Override public Call&lt;T&gt; clone() {
      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());
    }

    @Override public Request request() {
      return delegate.request();
    }
  }
</code></pre>
<p>上文介绍过retrofit的call对象其实是对okhttpcall的封装。基本上与ok的方法相同。通过create动态代理拿到接口的代理类后可以直接调其中定义的方法。那么在执行enqueue方法时的具体实现可以在上文中代码看到，retrofit是定义了</p>
<pre><code class="language-java"> final Call&lt;T&gt; delegate;
</code></pre>
<p>这么一个泛型对象来进行真正的执行。其实在上文也分析到了这里的delegate其实是retrofit内部封装的OkHttpCall类，这个也是我们在build retrofit时通过addConverterFactory设置进来或者默认的。</p>
<ul>
<li>所以可以说retrofit执行网络请求的底层依然是okhttp，此结论成立。</li>
</ul>
<p>执行完毕后会推过设置的callBackExecutor回调出去，默认是主线程。</p>
<h4 id="解析阶段">解析阶段</h4>
<p>上文既然说到我们是通过retrofit封装的OkhttpCall对象实际调用的还是okhttp来进行网络请求，之后拿到响应再回调到主线程。但是我们在ExecutorCallbackCall好像并没有看到解析response的过程，那用户是怎么拿到解析之后的返回呢？</p>
<p>既然这里没有，那我们肯定要追根溯源去实际返回响应的地方找一下:</p>
<pre><code class="language-java">   call.enqueue(new okhttp3.Callback() {
      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
        Response&lt;T&gt; response;
        try {
          response = parseResponse(rawResponse);
        } catch (Throwable e) {
          throwIfFatal(e);
          callFailure(e);
          return;
        }

        try {
          callback.onResponse(OkHttpCall.this, response);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }

      @Override public void onFailure(okhttp3.Call call, IOException e) {
        callFailure(e);
      }

      private void callFailure(Throwable e) {
        try {
          callback.onFailure(OkHttpCall.this, e);
        } catch (Throwable t) {
          throwIfFatal(t);
          t.printStackTrace(); // TODO this is not great
        }
      }
    });
</code></pre>
<p>可以看到里面有一句关键的代码<strong>parseResponse(rawResponse);</strong>，继续往下看:</p>
<pre><code class="language-java">      T body = responseConverter.convert(catchingBody);
</code></pre>
<p>在这个方法里面找到这个关键的一句，经过我们之前设置的converter转换之后返回的是我们在方法里面定义的泛型。</p>
<h4 id="总结">总结</h4>
<p>上面分析了这么多，先来总结一下Retrofit的大概流程</p>
<ul>
<li>定义一个接口类，定义出我们需要请求的方法</li>
<li>通过builder模式构建出retrofit对象</li>
<li>调用create()方法通过动态代理的方式返回实际的代理对象</li>
<li>通过代理对象来调用接口中定义的方法</li>
<li>enqueue或者excute实际上是调用addCallAdapterFactory中设置的(默认是okhttp)</li>
<li>通过okhttp来进行实际的网络请求</li>
<li>通过设置的converter来对返回的response进行解析成用户定义的格式</li>
<li>通过callBackExecutor回调给调用方（默认是主线程）</li>
</ul>
<p>至此，我们对Retrofit源码的探究终于可以说是告一段落了，跟OkHttp一样，retrofit的源码同样有很多值得我们学习的地方，例如动态代理的实现。整篇文章下来可能有很多不严谨的地方，这里只是记录个人对于Retrofit的理解，希望大家多多指正。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee">Retrofit源码解析</a><br><br>
<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">10分钟看懂动态代理设计模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android:OkHttp源码探究(七)CallServerInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-qi-callserverinterceptor">
        </link>
        <updated>2019-11-26T02:53:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>终于！我们来到了ok内置五大拦截器最后一个拦截器的探究。关于这个拦截器我们直接来看一下源码的注释:</p>
<table><tr><td>
This is the last interceptor in the chain. It makes a network call to the server.
</td></tr></table>
<p>看到这里是不是有种拨开云雾见明月的感觉。话不多说我们继续先看下源码:</p>
<pre><code class="language-kotlin">
  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

    exchange.writeRequestHeaders(request)

    var responseHeadersStarted = false
    var responseBuilder: Response.Builder? = null
    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) {
      // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100
      // Continue&quot; response before transmitting the request body. If we don't get that, return
      // what we did get (such as a 4xx response) without ever transmitting the request body.
      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase = true)) {
        exchange.flushRequest()
        responseHeadersStarted = true
        exchange.responseHeadersStart()
        responseBuilder = exchange.readResponseHeaders(true)
      }
      if (responseBuilder == null) {
        if (requestBody.isDuplex()) {
          // Prepare a duplex body so that the application can send a request body later.
          exchange.flushRequest()
          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
          requestBody.writeTo(bufferedRequestBody)
        } else {
          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.
          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
          requestBody.writeTo(bufferedRequestBody)
          bufferedRequestBody.close()
        }
      } else {
        exchange.noRequestBody()
        if (!exchange.connection()!!.isMultiplexed) {
          // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 connection
          // from being reused. Otherwise we're still obligated to transmit the request body to
          // leave the connection in a consistent state.
          exchange.noNewExchangesOnConnection()
        }
      }
    } else {
      exchange.noRequestBody()
    }

    if (requestBody == null || !requestBody.isDuplex()) {
      exchange.finishRequest()
    }
    if (!responseHeadersStarted) {
      exchange.responseHeadersStart()
    }
    if (responseBuilder == null) {
      responseBuilder = exchange.readResponseHeaders(false)!!
    }
    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
    var code = response.code
    if (code == 100) {
      // server sent a 100-continue even though we did not request one.
      // try again to read the actual response
      response = exchange.readResponseHeaders(false)!!
          .request(request)
          .handshake(exchange.connection()!!.handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
      code = response.code
    }

    exchange.responseHeadersEnd(response)

    response = if (forWebSocket &amp;&amp; code == 101) {
      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
      response.newBuilder()
          .body(EMPTY_RESPONSE)
          .build()
    } else {
      response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
    }
    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase = true) ||
        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase = true)) {
      exchange.noNewExchangesOnConnection()
    }
    if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) {
      throw ProtocolException(
          &quot;HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}&quot;)
    }
    return response
  }
  
</code></pre>
<h4 id="流程分析">流程分析</h4>
<p>是不是感觉臭长臭长的，但是莫慌！我们来一点一点攻克它。<br>
我们先来看下面几行代码</p>
<pre><code class="language-kotlin">    val realChain = chain as RealInterceptorChain
    val exchange = realChain.exchange()
    val request = realChain.request()
    val requestBody = request.body
    val sentRequestMillis = System.currentTimeMillis()

</code></pre>
<p>这里几行基本上取出对应的参数，并且设置当前时间为请求发出时间。关键的是从realChain中取出Exchange对象，这个对象是后续操作的比较关键的，之前在connectInterceptor中构建出来并且传递到当前的。</p>
<p>接着网下看:通过 exchange.writeRequestHeaders(request)方法来开始写入请求头，接着根据请求方式和请求体是否为空来进入分支逻辑:</p>
<h4 id="请求体不为空主要针对post请求br">请求体不为空(主要针对POST请求)<br></h4>
<h5 id="100-continue">100-continue</h5>
<p>刚开始看到这里笔者也是有点懵逼的，这是什么鬼header。于是开始Google大法:</p>
<table>
<tr>
<td bgcolor="#f7f6f3">
http 100-continue用于客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。在现实应用中，通常在POST大数据时，才会使用100-continue协议。<br>
来源:https://zhuanlan.zhihu.com/p/30830041
</td>
</tr>
</table>
<p>接着就是读取响应头，同时通知eventListener响应头开始读取。我们看源码的调用链是调用ExchangeCodec的readResponseHeaders()方法来读取响应头，具体类似于BridgeInterceptor中的intercept方法。</p>
<p>紧接着根据responseBuilder是否为null来进入分支逻辑，这个responseBuilder是根据又是根据header中的Expect是否为<strong>100-continue</strong>来判断的。接下来就是比较简单了，根据request构建出来一个requesBody，并且把其写入到请求的body中。</p>
<h4 id="请求体为空">请求体为空</h4>
<p>请求体为null的情况下就比较简单了直接调用noRequestBody()方法。表示当前request阶段已经完成.</p>
<h4 id="response阶段">Response阶段</h4>
<p>我们知道请求响应的开始也是从读取header。在上面经过发起Request结束之后，ok就已经做好准备进行response的接收。同样事件的发生也是会回调eventListener对应的监听。</p>
<pre><code class="language-kotlin">    var response = responseBuilder
        .request(request)
        .handshake(exchange.connection()!!.handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build()
</code></pre>
<p>可以看到经过一系列操作，我们已经拿到了服务器的返回。最终就是通过:</p>
<pre><code class="language-kotlin"> response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build()
</code></pre>
<p>这个方法来将服务端解析为客户端真正可用的resonse。</p>
<h4 id="总结">总结</h4>
<p>CallServerInterceptor的流程解析基本上到这里就结束了。纵观ok内置几个拦截器的源码，其实都不是很复杂，内部是采用了优秀的设计模式将以此请求中的每个阶段都做了分层，然后采用递归调用的思想通过几个拦截器将一个请求由上而下、再由下而上的完成。其中的设计模式以及代码的分离都是非常值得我们来学习的。</p>
<p>基本上关于拦截器的分析到这里就告一段了。整个流程下来笔者对于ok内部的很多东西也是一笔带过，后续将会好机会再详细分析。通过对ok一次请求的整体流程的探究，深知<strong>纸上得来终觉浅，绝知此事要躬行</strong>，这句话也跟大家一起共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（六）ConnectInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-liu-connectinterceptor">
        </link>
        <updated>2019-11-25T07:28:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>不知不觉已经到了要分析ok内置拦截器第四个的文章了，本篇的主角就是ConnectInterceptor，看名字也就知道它是负责与服务器建立连接的拦截器也。</p>
<h4 id="源码分析">源码分析</h4>
<p>话不多说，上代码:</p>
<pre><code class="language-kotlin">   @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    val request = realChain.request()
    val transmitter = realChain.transmitter()

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    val doExtensiveHealthChecks = request.method != &quot;GET&quot;
    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)

    return realChain.proceed(request, transmitter, exchange)
  }
</code></pre>
<p>可以看到这个拦截器里面的代码是异常的精简，纵观全部发现关键步骤是在于调用transmitter.newExchange()方法。前面的文章中简单分析过transmitter类还有印象吗？这里再简单回顾下</p>
<h5 id="transmitter">Transmitter</h5>
<p>Transmitter是应用层和网络层之间的桥梁，对外暴露了网络连接过程中的connection、request、response、streams。</p>
<p>我们接着看newExchange方法做了什么事情</p>
<pre><code class="language-kotlin">  /** Returns a new exchange to carry a new request and response. */
  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
    synchronized(connectionPool) {
      check(!noMoreExchanges) { &quot;released&quot; }
      check(exchange == null) {
        &quot;cannot make a new request because the previous response is still open: &quot; +
            &quot;please call response.close()&quot;
      }
    }

    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)

    synchronized(connectionPool) {
      this.exchange = result
      this.exchangeRequestDone = false
      this.exchangeResponseDone = false
      return result
    }
  }
</code></pre>
<p>首先是通过exchangeFinder调动find方法拿到codec，那这几个又是什么东西呢？</p>
<h5 id="exchangefinder">ExchangeFinder</h5>
<p>不知大家对介绍重试拦截器的过程是否还有印象？在重试拦截器中有通过transmitter调用prepareToConnect()。exchangeFinder对象同时也是那个时候初始化的，当时的介绍是为了后续的网络连接做准备。我们今天就来看看其在ConnectionInterceptor过程中是怎么做的网络连接。</p>
<p>还是简单翻译一下ExchangeFinder的类注释：</p>
<table><tr><td bgcolor=""#f7f6f3>
尝试找到请求队列中的已经存在的连接,使用下列策略：<br>
1.如果当前请求已经连接上，那么就直接使用。
2.如果连接池中有可以服用的连接，那么根据RealConnection.isEligible来判断是否使用。
3.如果当前没有存在的连接，那么就尝试从新建立一个新的连接。
</td></tr></table>
<p>可以看到ok在建立连接的时候是遵循尽量服用连接池的做法，因为这样可以大大降低在网络连接过程解析DNS耗时、以及握手耗时。<br></p>
<p>那么find()方法是做了什么事情呢？还是先看一下代码:</p>
<pre><code class="language-kotlin"> fun find(client: OkHttpClient,chain: Interceptor.Chain,doExtensiveHealthChecks: Boolean
  ): ExchangeCodec {
    //参数设置代码省略。。。。。。。
    try {
    //找到目前可用的连接
      val resultConnection = findHealthyConnection(
          connectTimeout = connectTimeout,
          readTimeout = readTimeout,
          writeTimeout = writeTimeout,
          pingIntervalMillis = pingIntervalMillis,
          connectionRetryEnabled = connectionRetryEnabled,
          doExtensiveHealthChecks = doExtensiveHealthChecks
      )
      return resultConnection.newCodec(client, chain)
    } catch (e: RouteException) {
      trackFailure()
      throw e
    } catch (e: IOException) {
      trackFailure()
      throw RouteException(e)
    }
  }
</code></pre>
<p>抛却一大推设置参数的代码可以发现主要是findHealthyConnection()来找到一个可用的connection。那它究竟是怎么找的呢？（为了分析请求流程这里可能会有大量代码）。进入到findHealthyConnection()方法中我们发现在while循环中，主要是通过findConnection()来寻找可用connection。并且方法注释如下:</p>
<pre><code class="language-kotlin">  /**
   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
   * until a healthy connection is found.
   */
</code></pre>
<h5 id="findconnection">findConnection()</h5>
<pre><code class="language-kotlin"> /**
   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
   * then the pool, finally building a new connection.
   */
</code></pre>
<p>这是每次请求过程中真正找到connection的方法，至于是使用已经存在的还是新建立的我们通过代码来分析:(方法代码有点长，为了流程连贯，将在代码中使用注释分析)</p>
<pre><code class="language-kotlin">@Throws(IOException::class)
  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    //使用代码块锁 保证线程同步 
    synchronized(connectionPool) {
    //前文分析过这里只会是用户主动取消，如果取消抛出异常
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)
      hasStreamFailure = false // This is a fresh attempt.

      releasedConnection = transmitter.connection
      //这里判断如果数据传输已经完成就返回需要关闭的sokcet，反之为null
      toClose = if (transmitter.connection != null &amp;&amp; transmitter.connection!!.noNewExchanges) {
        transmitter.releaseConnectionNoEvents()
      } else {
        null
      }
        //已经有一个分配好的连接 并且处于可用状态 
      if (transmitter.connection != null) {
        // We had an already-allocated connection and it's good.
        result = transmitter.connection
        releasedConnection = null
      }
    //按照之前的策略，如果当前没有已经连接好的连接，会尝试从连接池中找到一个可用的。
      if (result == null) {
        // Attempt to get a connection from the pool.
        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        } else if (retryCurrentRoute()) {
          selectedRoute = transmitter.connection!!.route()
        }
      }
    }
    //关闭之前socket 
    toClose?.closeQuietly()

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection!!)
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result!!
    }
    
    // If we need a route selection, make one. This is a blocking operation.
    var newRouteSelection = false
    if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection!!.hasNext())) {
      newRouteSelection = true
      routeSelection = routeSelector.next()
    }

    var routes: List&lt;Route&gt;? = null
    synchronized(connectionPool) {
      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection!!.routes
        //再次尝试从连接池中找到可用连接
        if (connectionPool.transmitterAcquirePooledConnection(
                address, transmitter, routes, false)) {
          foundPooledConnection = true
          result = transmitter.connection
        }
      } 
        
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }
        //再次尝试从连接池中找到可用连接失败，创建一个connection 
        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }
    //刚刚创建出来的connection 调用connect方法进行网络连接 
    // Do TCP + TLS handshakes. This is a blocking operation.
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    //将当前域名从失败的黑名单中移除掉
    connectionPool.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      //在连接过程中最后一次尝试从连接池中找到已经有的连接，防止同时有两个相对host的请求发出，这样就能复用已有的连接
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = transmitter.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
      //将这次连接放入连接池中，为了后续可能直接复用
        connectionPool.put(result!!)
        transmitter.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }

</code></pre>
<p>经过分析代码可以发现，ok在进行连接建立的时候不是直接去建立的connection，而是尽可能的寻找已经存在的连接去进行复用。如果实在没有可利用的再去创建一条新的连接并且将其放入连接池给后续请求去复用。</p>
<p>经过上面苦苦一番寻找，我们终于拿到了一条建立好的可使用的连接RealConnection。然后直接调用newCodec()方法返回一个ExchangeCodec对象。我们再来看一下是干嘛的:</p>
<pre><code class="language-kotlin"> @Throws(SocketException::class)
  internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec {
    val socket = this.socket!!
    val source = this.source!!
    val sink = this.sink!!
    val http2Connection = this.http2Connection

    return if (http2Connection != null) {
      Http2ExchangeCodec(client, this, chain, http2Connection)
    } else {
      socket.soTimeout = chain.readTimeoutMillis()
      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)
      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)
      Http1ExchangeCodec(client, this, source, sink)
    }
  }
</code></pre>
<p>可以看到关键方法就是根据当前请求协议是HTTP1还是HTTP2来返回一个codec，我们跟进到codec类去看一下注释，大概翻译如下:</p>
<table><tr><td bgcolor="#f7f6f3">
一个用来发送http/1.1消息的socket连接，并且严格遵守下列的生命周期:<br>
- 发送请求的headers[writeRequest]<br>
- 打开一个水槽（直译）去写入请求体<br>
- 开始写入请求体然后关闭这个水槽<br>
- 读取响应头
- 申请一部分资源开始读取响应体
- 读取完成响应体后关闭资源
</td></tr></table>
经过上面寻找可用连接的操作之后基本上到了newExchange的最后一步去构建出来一个Exchange并且返回。
<h5 id="exchange">Exchange</h5>
<p>类注释很简单:传输一个http的请求和响应，是真正上处理IO操作的。事件的管理是被ExchangeCodec管控。</p>
<h4 id="总结">总结</h4>
<p>到这里,关于ConnectInterceptor的源码探究基本上就告一段落了。我们大概来总结下:</p>
<ul>
<li>从chain对象中获取到Transmitter对象</li>
<li>调用transmitter的newExchange()方法</li>
<li>根据调度策略找到可用的连接并返回</li>
<li>调用proceed调用下一个拦截器</li>
</ul>
<p>上面基本上就是ConnectionInterceptor的调用流程，接下来我们会继续分析ok内置的最后一个拦截器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（五）CacheInterceptor]]></title>
        <id>https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor</id>
        <link href="https://alsowell.github.io//post/zai-xue-androidokhttp-yuan-ma-tan-jiu-wu-cacheinterceptor">
        </link>
        <updated>2019-11-22T09:42:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>前面的文章我们分析了重试拦截器和BridgeInterceptor(用来处理header、设置gzip、user-agent等)。本篇文章将开始分析ok内置拦截器比较实用的缓存拦截器<strong>CacheInterceptor</strong>。</p>
<p>顾名思义，CacheInterceptor就是处理与缓存相关的。关于http中的缓存知识可以参考<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a>。这篇文章写得非常浅显易懂。</p>
<h4 id="源码探究">源码探究</h4>
<pre><code class="language-kotlin"> @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val cacheCandidate = cache?.get(chain.request())

    val now = System.currentTimeMillis()

    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
    val networkRequest = strategy.networkRequest
    val cacheResponse = strategy.cacheResponse

    cache?.trackResponse(strategy)

    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
      // The cache candidate wasn't applicable. Close it.
      cacheCandidate.body?.closeQuietly()
    }

    // If we're forbidden from using the network and the cache is insufficient, fail.
    if (networkRequest == null &amp;&amp; cacheResponse == null) {
      return Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(HTTP_GATEWAY_TIMEOUT)
          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)
          .body(EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build()
    }

    // If we don't need the network, we're done.
    if (networkRequest == null) {
      return cacheResponse!!.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build()
    }

    var networkResponse: Response? = null
    try {
      networkResponse = chain.proceed(networkRequest)
    } finally {
      // If we're crashing on I/O or otherwise, don't leak the cache body.
      if (networkResponse == null &amp;&amp; cacheCandidate != null) {
        cacheCandidate.body?.closeQuietly()
      }
    }

    // If we have a cache response too, then we're doing a conditional get.
    if (cacheResponse != null) {
      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
        val response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers, networkResponse.headers))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()

        networkResponse.body!!.close()

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache!!.trackConditionalCacheHit()
        cache.update(cacheResponse, response)
        return response
      } else {
        cacheResponse.body?.closeQuietly()
      }
    }

    val response = networkResponse!!.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build()

    if (cache != null) {
      if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        val cacheRequest = cache.put(response)
        return cacheWritingResponse(cacheRequest, response)
      }
      
      if (HttpMethod.invalidatesCache(networkRequest.method)) {
        try {
          cache.remove(networkRequest)
        } catch (_: IOException) {
          // The cache cannot be written.
        }
      }
    }

    return response
  }

</code></pre>
<h5 id="request阶段">Request阶段</h5>
<p>可以看到，首先是通过请求的url去缓存中读取，当然取出的缓存对象可能为空。主要方法:</p>
<pre><code class="language-kotlin">   val cacheCandidate = cache?.get(chain.request())
</code></pre>
<p>那么Cache又是什么呢？还记得我们在分析OkHttpClient构造时候的cache参数吗？其实cache是ok内部实现的一个DiskLruCache。是不是很熟悉？也是三级缓存的原理。关于<a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a>,又是JakeWarton的一大杰作。多提一句，我们在构建client的时候可以通过builder模式设置我们想要缓存的文件夹以及最大缓存，下面放出代码。不过注意加好权限哦。</p>
<pre><code class="language-kotlin">     val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .cache(Cache(Environment.getDownloadCacheDirectory(),10000))
            .build()
</code></pre>
<p>接着是记录当前时间，他与从缓存取出的Response都是构建缓存策略的构造参数。说到缓存策略：</p>
<pre><code class="language-kotlin"> val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
</code></pre>
<p>其实结合http中的缓存原理（见上文连接）就可以很简单的理解了，无非是根据请求参数和本地的缓存是否需要使用本地或者说两者结合。</p>
<p>继续往下面看，根据networkRequest和cacheResponse 的值来判断后续流程。既然他们都是从CacheStrategy中拿到的，那我们先来了解下这两个家伙：</p>
<pre><code class="language-kotlin"> /** The request to send on the network, or null if this call doesn't use the network. */
 val networkRequest: Request?,
 /** The cached response to return or validate; or null if this call doesn't use a cache. */
 val cacheResponse: Response?
</code></pre>
<p>看了注释就非常好理解了，networkRequest在使用缓存的情况下为空，cahceRespoonse在没有使用缓存的情况下为空。<br>
那么两个都为空的情况下就直接返回一个空的响应体，并且设置状态吗为504。</p>
<p>使用缓存情况下，直接就返回缓存中存储的数据，这点在代码里可以体现：</p>
<pre><code class="language-kotlin">// If we don't need the network, we're done.
   if (networkRequest == null) {
     return cacheResponse!!.newBuilder()
         .cacheResponse(stripBody(cacheResponse))
         .build()
   }
</code></pre>
<p>那么如果我们不适用缓存呢？机智的你肯定会想起来拦截器的机制，没错就是继续通过chain.proceed方法调用下一个拦截器。既然本篇是关于缓存的，我们就继续看一下在使用缓存情况下是怎么处理response的。</p>
<h5 id="response阶段">Response阶段</h5>
<p>如果你看了上面关于HTTP缓存分析的文章，你会知道在http协议中，如果数据没有发生改变那么响应码将会是304。同样ok既然作为一个网络库也是遵守同样的规则的。</p>
<p>在本地缓存不为空情况下，如果服务器返回304，那么ok将会更新header里面的一些参数，更新请求发起时间、响应接收时间等。在此之后返回networkResponse和cacheResponse结合之后的response。</p>
<p>如果用户设置了自定义的缓存目录以及大小并且当前请求是可以被缓存的，那么调用put方法将响应存储到本地磁盘中。但是如果请求的方法是 patch、put、delete、move等不支持缓存的方法，会将缓存从磁盘中清楚。</p>
<h4 id="总结">总结</h4>
<p>以上就是CacheInterceptor的全部分析啦。我们大概类总结一下流程：</p>
<ul>
<li>首先通过请求的url通过DiskLruCache拿到可能存在的响应体</li>
<li>通过请求时间和缓存中的响应体拿到缓存策略</li>
<li>通过策略判断本次请求是直接读取缓存还是请求网络获取</li>
<li>网络请求返回的数据更新到本地缓存中</li>
</ul>
<p>回头来看，其实缓存管理也是按照我们网络协议里面的规则，ok是基于这个规则对其进行了一定的封装。关键部分还是要充分的理解HTTP缓存机制，再次强烈推荐这篇<a href="https://www.cnblogs.com/chenqf/p/6386163.html">文章</a>。</p>
<h4 id="参考资料">参考资料</h4>
<p><a href="https://www.jianshu.com/p/963ad9ca214d">OKhttp源码学习（六）—— CacheInterceptor</a></p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再学Android：OkHttp源码探究（四）BridgeInterceptor]]></title>
        <id>https://alsowell.github.io//post/okhttp_two</id>
        <link href="https://alsowell.github.io//post/okhttp_two">
        </link>
        <updated>2019-11-22T02:17:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h4 id="前言">前言</h4>
<p>在上一篇文章中我们已经分析过了ok内置五个拦截器中的第一个RetryAndFollowUpInterceptor，本篇我们将继续按照顺序去探究一下BridgeInterceptor。</p>
<h4 id="介绍">介绍</h4>
<p>首先来看一下类注释：</p>
<table><tr><td bgcolor=#f7f6f3>
 Bridges from application code to network code. First it builds a network request from a user
 request. Then it proceeds to call the network. Finally it builds a user response from the network response.
<br></br>
释义：应用层和网络层之间的桥接，首先往用户发起的请求中添加一部分网络层需要的参数，接着调用网络，最后从响应体中解析出用户请求的结果
</td></tr></table>
接着我们直接上代码：
<pre><code class="language-kotlin">  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val userRequest = chain.request()
    val requestBuilder = userRequest.newBuilder()

    val body = userRequest.body
    if (body != null) {
      val contentType = body.contentType()
      if (contentType != null) {
        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())
      }
      val contentLength = body.contentLength()
      if (contentLength != -1L) {
        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())
        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)
      } else {
        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
        requestBuilder.removeHeader(&quot;Content-Length&quot;)
      }
    }
    if (userRequest.header(&quot;Host&quot;) == null) {
      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())
    }

    if (userRequest.header(&quot;Connection&quot;) == null) {
      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)
    }

    // If we add an &quot;Accept-Encoding: gzip&quot; header field we're responsible for also decompressing
    // the transfer stream.
    var transparentGzip = false
    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {
      transparentGzip = true
      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
    }

    val cookies = cookieJar.loadForRequest(userRequest.url)
    if (cookies.isNotEmpty()) {
      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))
    }

    if (userRequest.header(&quot;User-Agent&quot;) == null) {
      requestBuilder.header(&quot;User-Agent&quot;, userAgent)
    }

    val networkResponse = chain.proceed(requestBuilder.build())

    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
    
    val responseBuilder = networkResponse.newBuilder()
        .request(userRequest)
    if (transparentGzip &amp;&amp;
        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase = true) &amp;&amp;
        networkResponse.promisesBody()) {
      val responseBody = networkResponse.body
      if (responseBody != null) {
        val gzipSource = GzipSource(responseBody.source())
        val strippedHeaders = networkResponse.headers.newBuilder()
            .removeAll(&quot;Content-Encoding&quot;)
            .removeAll(&quot;Content-Length&quot;)
            .build()
        responseBuilder.headers(strippedHeaders)
        val contentType = networkResponse.header(&quot;Content-Type&quot;)
        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
      }
    }
    return responseBuilder.build()
  }
</code></pre>
<p>相对于上一篇的重试拦截器，bridge拦截器的代码相对来说是非常容易看懂的。我们将按照interceptor的调用来分为两个阶段分析：</p>
<h4 id="request阶段">Request阶段</h4>
<ul>
<li>
<p>取出body的contentType设置到header里面</p>
</li>
<li>
<p>获取请求体的长度放入header</p>
<ul>
<li>Transfer-Encoding 字面意思也很好理解，即为传输过程中的编码格式<br>
根据网上资料:首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP1.1的传输编码方式仅对分块传输编码有效。值为 chunked 表示请求体的内容大小是未知的。    因此Transfer-Encoding与Content-Length两个首部不能共存。</li>
</ul>
</li>
<li>
<p>将请求的host放入到header里面</p>
<ul>
<li>
<p>Host即对应请求中的域名 对此HttpUrl中有详细的注释解释</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left"><code>host()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>http://android.com/</code></td>
<td style="text-align:left"><code>&quot;android.com&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://127.0.0.1/</code></td>
<td style="text-align:left"><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://[::1]/</code></td>
<td style="text-align:left"><code>&quot;::1&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>http://xn--n3h.net/</code></td>
<td style="text-align:left"><code>&quot;xn--n3h.net&quot;</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>其中toHostHeader()方法会取到对应的域名并且拼接上默认的端口 http默认端口80 、https默认端口443</p>
</li>
</ul>
</li>
<li>
<p>指定连接模式为 Keep-Alive 这样就能方便的复用连接池。</p>
</li>
<li>
<p>如果用户没有设置Accept-Encoding，那么会指定数据接收格式为gzip。顺带提一下：gzip格式压缩能大大减少网络流量的消耗。</p>
</li>
<li>
<p>header中放入cookie</p>
</li>
<li>
<p>请求头中放入 user-agent 如果用户没有设置，那么放入默认 agent:okhttp/x.x.x</p>
</li>
</ul>
<h4 id="response阶段">Response阶段</h4>
<ul>
<li>首先是根据url拿到返回的cookie。</li>
<li>如果Content-Encoding是gzip类型，并且content-length &gt;0 取出body进行处理</li>
<li>对请求响应体做一遍处理，因为响应体的body的传输格式是gzip类型，通过封装的方法类解析处理</li>
<li>解析成为用户真正可使用的body</li>
</ul>
<h4 id="总结">总结</h4>
<p>以上就是整个BridgeInterceptor的全部流程了。大概可以分为三步</p>
<ul>
<li>对用户的请求做一遍处理，如果用户设置了参数使用用户配置，如果未设置那么就使用默认的。</li>
<li>通过chain调用下一个拦截器。</li>
<li>对接口的请求做一遍处理，比如gzip、cookie 最后解析成用户真正可使用的body。</li>
</ul>
<p>可以看到整个BridgeInterceptor的流程还是非常简单的，无非就是对网络传输协议中一些必须参数的封装，这样应用层在调用的时候就省去了这些步骤。</p>
]]></content>
    </entry>
</feed>